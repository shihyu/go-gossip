<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title></title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <div id="layout" style="height: auto !important;">
<p><a href="index.html#menu" id="menuLink" class="menu-link"><span></span></a></p>
<div id="menu">
<div class="pure-menu">
<p><a href="../" class="pure-menu-heading">回 OPENHOME 首頁</a></p>
</div>
</div>
<div id="main" role="main" style="height: auto !important;">
<div class="header">
<h1 id="語言技術go-語言"><a class="header" href="#語言技術go-語言">語言技術：Go 語言</a></h1>
</div>
<p>使用 Go 1.13 … XD</p>
<div class="ad-2" style="text-align: center;">
<div id="aswift_2_host" style="border: none; height: 280px; width: 800px; margin: 0px; padding: 0px; position: relative; visibility: visible; background-color: transparent; display: inline-block; overflow: visible;">
<div class="iframe">
</div>
</div>
</div>
<p>起步走</p>
<p>語言的起步走，需要的時間最好是長一些，因為慢一點才會快一點 ...</p>
<ul>
<li>Go 平台概要</li>
</ul>
<p>在開始認識語言本身之前，先來瞭解 Go 提供的基本工具集，這是 Go 的一大特色。</p>
<ul>
<li>
<ul>
<li><a href="HelloWorld.html">來個 Hello, World</a></li>
<li><a href="Package.html">Go 套件管理</a></li>
<li><a href="gofmt.html">gofmt 格式化原始碼</a></li>
<li><a href="godoc.html">go doc 文件即註解</a></li>
<li><a href="Testing.html">Go 測試套件</a></li>
</ul>
</li>
</ul>
<!-- -->
<ul>
<li>型態、變數、常數、運算子</li>
</ul>
<p>也許看似基本，然而沒你想像中的那麼簡單。</p>
<ul>
<li>
<ul>
<li><a href="PreDeclaredType.html">認識預定義型態</a></li>
<li><a href="VariableConstantDeclaration.html">變數宣告、常數宣告</a></li>
<li><a href="String.html">位元組構成的字串</a></li>
</ul>
</li>
<li>
<ul>
<li><a href="Array.html">身為複合值的陣列</a></li>
<li><a href="Slice.html">底層為陣列的 slice</a></li>
<li><a href="Map.html">成對鍵值的 map</a></li>
</ul>
</li>
</ul>
<!-- -->
<ul>
<li>運算與流程控制</li>
</ul>
<p><code>Go 有指標，switch</code> 很有彈性，沒有 <code>while</code>，存在 <code>goto</code> ... XD</p>
<ul>
<li>
<ul>
<li><a href="Operator.html">運算子</a></li>
<li><a href="IfElseSwitch.html">if ... else、switch 條件式</a></li>
<li><a href="For.html">for 迴圈</a></li>
<li><a href="BreakContinueGoto.html">break、continue、goto</a></li>
</ul>
</li>
</ul>
<p>函式、結構與介面</p>
<p>        封裝演算、定義行為、組織程式元件。</p>
<ul>
<li>
<p>函式</p>
</li>
<li>
<ul>
<li><a href="Function.html">函式入門</a></li>
<li><a href="FirstClassFunction.html">一級函式</a></li>
<li><a href="Closure.html">匿名函式與閉包</a></li>
<li><a href="DeferPanicRecover.html">defer、panic、recover</a></li>
</ul>
</li>
</ul>
<!-- -->
<ul>
<li>結構</li>
</ul>
<p>把相關的東西放在一起。</p>
<ul>
<li>
<ul>
<li><a href="Struct.html">結構入門</a></li>
<li><a href="Method.html">結構與方法</a></li>
<li><a href="StructComposition.html">結構組合</a></li>
</ul>
</li>
</ul>
<!-- -->
<ul>
<li>介面</li>
</ul>
<p>將行為定義出來。</p>
<ul>
<li>
<ul>
<li><a href="Interface.html">介面入門</a></li>
<li><a href="TypeAssertion.html">型態斷言</a></li>
<li><a href="InterfaceComposition.html">介面組合</a></li>
</ul>
</li>
</ul>
<p>常用 API</p>
<p>        從常用 API 中學習如何撰寫 Go 程式碼。</p>
<ul>
<li>基本 IO</li>
</ul>
<p>從 <code>io.Reader</code>、<code>io.Writer</code> 開始認識。</p>
<ul>
<li>
<ul>
<li><a href="StdOutInErr.html">從標準輸入、輸出認識 io</a></li>
<li><a href="ReaderWriter.html">io.Reader、io.Writer</a></li>
<li><a href="bufio.html">bufio 套件</a></li>
<li><a href="File.html">檔案操作</a></li>
</ul>
</li>
</ul>
<!-- -->
<ul>
<li>error 處理</li>
</ul>
<p>到處都在 <code>if err != nil</code>？</p>
<ul>
<li>
<ul>
<li><a href="ErrNil.html">err 是否 nil？</a></li>
<li><a href="ErrorComparison.html">錯誤的比對</a></li>
<li><a href="errors.html">errors 套件</a></li>
</ul>
</li>
</ul>
<!-- -->
<ul>
<li>資料結構</li>
</ul>
<p><code>sort</code>、<code>list</code>、<code>heap</code> 與 <code>ring</code> 套件。</p>
<ul>
<li>
<ul>
<li><a href="Sort.html">sort 套件</a></li>
<li><a href="List.html">list 套件</a></li>
<li><a href="Heap.html">heap 套件</a></li>
<li><a href="Ring.html">ring 套件</a></li>
</ul>
</li>
</ul>
<!-- -->
<ul>
<li>文字</li>
</ul>
<p>有關字串、位元組、規則表示式等的處理。</p>
<ul>
<li>
<ul>
<li><a href="StrconvStrings.html">strconv、strings 套件</a></li>
<li><a href="Bytes.html">bytes 套件</a></li>
<li><a href="Unicode.html">unicode 套件</a></li>
<li><a href="XText.html">編碼轉換</a></li>
<li><a href="https://openhome.cc/Gossip/Regex/MatchGo.html">Match 比對</a></li>
<li><a href="https://openhome.cc/Gossip/Regex/RegexpGo.html">Regexp 實例</a></li>
</ul>
</li>
</ul>
<!-- -->
<ul>
<li>反射</li>
</ul>
<p>探測資料的結構與相關數值。</p>
<ul>
<li>
<ul>
<li><a href="Reflect.html">反射入門</a></li>
<li><a href="FieldTag.html">結構欄位標籤</a></li>
</ul>
</li>
</ul>
<!-- -->
<ul>
<li>並行</li>
</ul>
<p>簡單的並行模型。</p>
<ul>
<li>
<ul>
<li><a href="Goroutine.html">Goroutine</a></li>
<li><a href="Channel.html">Channel</a></li>
</ul>
</li>
</ul>
<p>其他</p>
<p>        一些雜七雜八的東西，暫時放這分類。</p>
<ul>
<li>相依管理</li>
</ul>
<p>go module 能終結混亂嗎？</p>
<ul>
<li>
<ul>
<li><a href="Vendor.html">vendor</a></li>
<li><a href="Module.html">模組入門</a></li>
</ul>
</li>
</ul>
<!-- -->
<ul>
<li>WebAssembly 支援</li>
</ul>
<p>Go 也可以在瀏覽器裏跳舞？</p>
<ul>
<li>
<ul>
<li><a href="WebAssembly.html">哈囉！WebAssembly！</a></li>
<li><a href="JavaScript.html">Go 呼叫 JavaScript</a></li>
<li><a href="Callback.html">JavaScript 回呼 Go</a></li>
</ul>
</li>
</ul>
<p>附錄</p>
<ul>
<li><a href="http://c-faq.com/">Go 官方套件說明文件</a></li>
<li><a href="https://golang.org/doc/code.html">How to Write Go Code</a></li>
<li><a href="https://golang.org/cmd/">Go Commands</a></li>
<li><a href="https://golang.org/doc/effective_go.html">Effective Go</a></li>
<li>...</li>
</ul>
<div class="ad336-280" style="text-align: center;">
<div id="aswift_3_host" style="border: none; height: 280px; width: 336px; margin: 0px; padding: 0px; position: relative; visibility: visible; background-color: transparent; display: inline-block;">
</div>
</div>
<div class="recommend" style="text-align: center;">
<hr />
<div id="aswift_4_host" style="border: none; height: 480px; width: 800px; margin: 0px; padding: 0px; position: relative; visibility: visible; background-color: transparent; display: inline-block;">
</div>
</div>
</div>
</div>
<div class="analytics">
</div>
<div id="aswift_0_host" style="border: none; height: 0px; width: 0px; margin: 0px; padding: 0px; position: relative; visibility: visible; background-color: transparent; display: inline-block;">
<div class="iframe">
</div>
</div>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td></td><td></td></tr>
</tbody></table>
</div><div class="ad-300-flex ad_zone external-add leaderboard_ad_top_responsive logoutAd" style="width: 1px; height: 1px; position: absolute; left: -10000px; top: -10006px;">
</div>
<div class="iframe">
</div>
<div id="aswift_5_host" style="border: none !important; height: 100vh !important; width: 100vw !important; margin: 0px !important; padding: 0px !important; position: relative !important; visibility: visible !important; background-color: transparent !important; display: inline-block !important; inset: auto !important; clear: none !important; float: none !important; max-height: none !important; max-width: none !important; opacity: 1 !important; overflow: visible !important; vertical-align: baseline !important; z-index: auto !important;">
<div class="iframe">
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><div id="main" role="main" style="height: auto !important;">
<div class="header">
<h1 id="來個-hello-world"><a class="header" href="#來個-hello-world">來個 Hello, World</a></h1>
</div>
<p>我在這邊使用的是 Windows 中的 Go 1.13 版本，你可以至 <a href="https://golang.org/">Go 的官方網站</a> 下載安裝 Go。</p>
<p>如果想來點不同的安裝方式，可以參考〈<a href="http://openhome.cc/Gossip/CodeData/DockerLayman/DockerLayman4.html">門外漢的 Go 輕量開發環境</a>〉，在 Raspberry Pi 上的 Docker 容器中建立相關環境，就目前為止。</p>
<p>你至少得設定 <code>GOROOT</code> 環境變數，這會是你的 Go 安裝目錄。</p>
<h1 id="go-run"><a class="header" href="#go-run">go run</a></h1>
<p>要撰寫第一個 Hello, World 程式，你可以建立一個 main.go，在當中撰寫以下的內容：</p>
<pre><code class="language-prettyprint">package main

import "fmt"

func main() {
    fmt.Println("Hello, World")
    fmt.Println("哈囉！世界！")
}
</code></pre>
<div class="google-auto-placed" style="width: 100%; height: auto; clear: both; text-align: center;">
</div>
<p>每個 .go 原始碼，都必須從 <code>package</code> 定義開始，而對於包括程式進入點 <code>main</code> 函式的 .go 原始碼，必須是在 <code>package main</code> 之中，為了要能輸出訊息，這邊使用了 <code>fmt</code> 套件（package）之中的 <code>Println</code> 函式，開頭的大寫 P 表示這是個公開的函式，可以在套件之外進行呼叫。</p>
<p>Go 的創建者之一也是 UTF-8 的創建者，因此，Go 可以直接處理多國語言，只要你確定編輯器編碼為 UTF-8 就可以了，如果你使用 vim，可以在 vim 的命令模式下輸入 <code>:set encoding=utf-8</code>，或者是在 .vimrc 之中增加一行 <code>set encoding=utf-8</code>。</p>
<p>Go 可以用直譯的方式來執行程式，第一個 Hello, World 程式就是這麼做的，執行 <code>go run</code> 指定你的原始碼檔名就可以了：</p>
<pre><code class="language-prettyprint">$ go run main.go
Hello, World
哈囉！世界！
</code></pre>
<h1 id="package-與-gopath"><a class="header" href="#package-與-gopath">package 與 GOPATH</a></h1>
<div class="google-auto-placed" style="width: 100%; height: auto; clear: both; text-align: center;">
</div>
<p>那麼，一開始的 <code>package</code> 是怎麼回事？試著先來建立一個 hello.go：</p>
<pre><code class="language-prettyprint">package hello

import "fmt"

func HelloWorld() {
    fmt.Println("Hello, World")
}
</code></pre>
<p>記得，<code>package</code> 中定義的函式，名稱必須是以大寫開頭，其他套件外的程式，才能進行呼叫，若函式名稱是小寫，那麼會是套件中才可以使用的函式。</p>
<p>接著，原本的 main.go 修改為：</p>
<pre><code class="language-prettyprint">package main

import "hello"

func main() {
    hello.HelloWorld()
}
</code></pre>
<p>現在顯然地，main.go 中要用到方才建立的 <code>hello</code> 套件中的 <code>HelloWorld</code> 函式，這時 <code>package</code> 的設定就會發揮一下效用，你得將 hello.go 移到 src/hello 目錄之中，也就是目錄名稱必須符合 <code>package</code> 設定之名稱。</p>
<p>同樣地，你可以將 main.go 移到 src/main 目錄之中，以符合 <code>package</code> 的設定。</p>
<p>而 src 的位置，必須是在 <code>GOROOT</code> 或者是 <code>GOPATH</code> 的路徑中可以找到，當 Go 需要某套件中的元素時，會分別到這兩個環境變數的目錄之中，查看 src 中是否有相應於套件的原始碼存在。</p>
<p>為了方便，通常會設定 <code>GOPATH</code>，例如，指向目前的工作目錄：</p>
<pre><code class="language-prettyprint">set GOPATH=c:\workspace\go-exercise
</code></pre>
<p>如果沒有設定 <code>GOPATH</code> 的話，Go 預設會是使用者目錄的 go 目錄，雖然目前 <code>GOPATH</code> 中只一個目錄，不過 <code>GOPATH</code> 中可以設定數個目錄，現在我的 go-exercise 目錄底下會有這些東西：</p>
<pre><code class="language-prettyprint">go-exercise
          └─src
              ├─hello
              │      hello.go
              │
              └─main
                      main.go
</code></pre>
<p>接著在 go 目錄中執行指令 <code>go run src/main/main.go</code> 的話，你就會看到 Hello, World 了。</p>
<h1 id="go-build"><a class="header" href="#go-build">go build</a></h1>
<p>如果想編譯原始碼為可執行檔，那麼可以使用 <code>go build</code>，例如，直接在 go 目錄中執行 <code>go build src/main/main.go</code>，就會在執行指令的目錄下，產生一個名稱為 main.exe 的可執行檔，可執行檔的名稱是來自己指定的原始碼檔案主檔名，執行產生出來的可執行檔就會顯示 Hello, World。</p>
<p>你也可以建立一個 bin 目錄，然後執行 <code>go build -o bin/main.exe src/main/main.go</code>，這樣產生出來的可執行檔，就會被放在 bin 底下。</p>
<h1 id="go-install"><a class="header" href="#go-install">go install</a></h1>
<p>每次使用 <code>go build</code>，都是從原始碼編譯為可執行檔，這比較沒有效率，如果想要編譯時更有效率一些，可以使用 <code>go install</code>，例如，在目前既有的目錄與原始碼架構之下，於 go 目錄中執行 <code>go install hello</code> 的話，你就會發現有以下的內容：</p>
<pre><code class="language-prettyprint">go-exercise
        ├─bin
        │      main.exe
        │
        ├─pkg
        │  └─windows_amd64
        │          hello.a
        │
        └─src
            ├─hello
            │      hello.go
            │
            └─main
                    main.go
</code></pre>
<p><code>go install packageName</code> 表示要安裝指定名稱的套件，如果是 <code>main</code> 套件，那麼會在 bin 中產生可執行檔，如果是公用套件，那麼會在 pkg 目錄的 <code>$GOOS</code>_<code>$GOARCH</code> 目錄中產生 .a 檔案，你可以使用 <code>go env</code> 來查看 Go 使用到的環境變數，例如：</p>
<pre><code class="language-prettyprint">set GO111MODULE=
set GOARCH=amd64
set GOBIN=
set GOCACHE=C:\Users\Justin\AppData\Local\go-build
set GOENV=C:\Users\Justin\AppData\Roaming\go\env
set GOEXE=.exe
set GOFLAGS=
set GOHOSTARCH=amd64
set GOHOSTOS=windows
set GONOPROXY=
set GONOSUMDB=
set GOOS=windows
set GOPATH=C:\Users\Justin\go
set GOPRIVATE=
set GOPROXY=https://proxy.golang.org,direct
set GOROOT=C:\Winware\Go
set GOSUMDB=sum.golang.org
set GOTMPDIR=
set GOTOOLDIR=C:\Winware\Go\pkg\tool\windows_amd64
set GCCGO=gccgo
set AR=ar
set CC=gcc
set CXX=g++
set CGO_ENABLED=1
set GOMOD=
set CGO_CFLAGS=-g -O2
set CGO_CPPFLAGS=
set CGO_CXXFLAGS=-g -O2
set CGO_FFLAGS=-g -O2
set CGO_LDFLAGS=-g -O2
set PKG_CONFIG=pkg-config
set GOGCCFLAGS=-m64 -mthreads -fno-caret-diagnostics -Qunused-arguments -fmessage-length=0 -fdebug-prefix-map=C:\Users\Justin\AppData\Local\Temp\go-build282125542=/tmp/go-build -gno-record-gcc-switches
</code></pre>
<p>.a 檔案是編譯過後的套件，因此，你看到的 hello.a，就是 hello.go 編譯之後的結果，如果編譯時需要某個套件，而對應的 .a 檔案存在，且原始碼自上次編譯後未曾經過修改，那麼就會直接使用 .a 檔案，而不是從原始碼開始編譯起。</p>
<h1 id="osargs"><a class="header" href="#osargs">os.Args</a></h1>
<p>那麼，如果想在執行 Go 程式時使用命令列引數呢？可以使用 <code>os</code> 套件的 <code>Args</code>，例如，寫一個 main.go：</p>
<pre><code class="language-prettyprint">package main

import "os"
import "fmt"

func main() {
    fmt.Printf("Command: %s\n", os.Args[0])
    fmt.Printf("Hello, %s\n", os.Args[1])
}
</code></pre>
<p><code>os.Args</code> 是個陣列，索引從 0 開始，索引 0 會是編譯後的可執行檔名稱，索引 1 開始會是你提供的引數，例如，在執行過 go build 或 go install 之後，如下直接執行編譯出來的執行檔，會產生的訊息是…</p>
<pre><code class="language-prettyprint">$ ./bin/main Justin
Command: ./bin/main
Hello, Justin
</code></pre>
<h1 id="go-doc"><a class="header" href="#go-doc">go doc</a></h1>
<p><code>fmt</code> 的 Printf，就像是 C 的 <code>printf</code>，可用的格式控制可參考 <a href="https://golang.org/pkg/fmt/">Package fmt</a> 的說明。實際上，Go 本身附帶了說明文件，可以執行 <code>go doc &lt;pkg&gt; &lt;sym&gt;[.&lt;method&gt;]</code> 來查詢說明。例如：</p>
<pre><code class="language-prettyprint">$ go doc fmt.Printf
func Printf(format string, a ...interface{}) (n int, err error)

    Printf formats according to a format specifier and writes to standard
    output. It returns the number of bytes written and any write error
    encountered.
</code></pre>
<div class="ad336-280" style="text-align: center;">
</div>
<div class="recommend" style="text-align: center;">
<hr />
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><div id="main" role="main" style="height: auto !important;">
<div class="header">
<h1 id="go-套件管理"><a class="header" href="#go-套件管理">Go 套件管理</a></h1>
</div>
<p>在〈<a href="http://openhome.cc/Gossip/Go/HelloWorld.html">來個 Hello, World</a>〉中，你已經看到 Go 開發中，一個 workspace 的基本樣貌，你可以看到，裏頭會有 src、pkg、bin 目錄，你會設置 <code>GOPATH</code> 環境變數指向這個目錄，這些都是規範好的，也是強制的，正如〈<a href="https://golang.org/doc/code.html">How to Write Go Code</a>〉中說到的：</p>
<blockquote>
<p><em>The go tool is designed to work with open source code maintained in public repositories. Although you don't need to publish your code, the model for how the environment is set up works the same whether you do or not.</em></p>
</blockquote>
<p>在〈<a href="http://openhome.cc/Gossip/Go/HelloWorld.html">來個 Hello, World</a>〉已經稍微瞭解了 <code>package</code> 與 <code>GOPATH</code> 的關係，原始碼會是在 <code>GOPATH</code> 中設定的目錄之 src 中，並有著對照於 <code>package</code> 設定名稱之目錄包括著它，當 Go 的工具（<code>go build</code>、<code>go install</code> 等）需要原始碼時，會到 <code>GOROOT</code> 底下，或者是 <code>GOPATH</code> 底下，查看是否有相應於套件的原始碼存在，編譯出來的結果，會是在相對應的 pkg 或 bin 底下。</p>
<h1 id="本地套件"><a class="header" href="#本地套件">本地套件</a></h1>
<p>在當時，為了簡化說明，原始碼主檔名故意與 <code>package</code> 設定的名稱同名，這不是必要的，一個相應於 <code>package</code> 的目錄底下，可以有許多個原始碼，而每個原始碼開頭，只要 <code>package</code> 設定的名稱都與目錄相符就可以了。例如，你可以有個原始碼是 hello.go，位於 src/goexample 底下：</p>
<pre><code class="language-prettyprint">package goexample

import "fmt"

func Hello() {
    fmt.Println("Hello")
}
</code></pre>
<p>還可以有個 hi.go，位於 src/goexample 底下：</p>
<pre><code class="language-prettyprint">package goexample

import "fmt"

func Hi() {
    fmt.Println("Hi")
}
</code></pre>
<p>也就是說，一個 <code>package</code> 可以有數個原始碼檔案，各自組織自己的任務，在執行 <code>go install goexample</code> 之後，上面兩個原始碼會在 pkg 目錄的 <code>$GOOS</code>_<code>$GOARCH</code> 目錄中產生 goexample.a 檔案。這包括了 <code>goexample</code> 套件編譯後的結果，如果想使用 <code>goexample</code> 套件的功能，只需要撰寫個 main.go：</p>
<pre><code class="language-prettyprint">package main

import "goexample"

func main() {
    goexample.Hi()
    goexample.Hello()
}
</code></pre>
<p>你可以在套件目錄之前增加父目錄，例如，可以建立一個 src/cc/openhome 目錄，然後將方才的 hello.go 與 hi.go 移至該目錄之中，接著執行 <code>go install cc/openhome/goexample</code>，那麼，在 pkg 目錄的 $GOOS_$GOARCH 目錄中，會產生對應的 cc/openhome 目錄，其中放置著 goexample.a 檔案，想要使用這個套件的話，可以撰寫個 main.go：</p>
<pre><code class="language-prettyprint">package main

import "cc/openhome/goexample"

func main() {
    goexample.Hi()
    goexample.Hello()
}
</code></pre>
<h1 id="遠端套件"><a class="header" href="#遠端套件">遠端套件</a></h1>
<p>由於 Go 的 workspace 設置，都必須是如此規範，因此，若你想將原始碼發佈給他人使用時就很方便，例如，你可以建立 src/github.com/JustinSDK 目錄，然後將方才的 goexample 目錄移到 src/github.com/JustinSDK 當中，這麼一來，顯然地，你的 main.go 就要改成：</p>
<pre><code class="language-prettyprint">package main

import "github.com/JustinSDK/goexample"

func main() {
    goexample.Hi()
    goexample.Hello()
}
</code></pre>
<p>也就是說，你可以直接將 /src/github.com/JustinSDK/goexample 當作檔案庫（repository）發佈到 Github，那麼，其他人需要你的原始碼時，有個很方便的 <code>go get</code> 指令可以用，我將這個範例發佈在 Github 的 <a href="https://github.com/JustinSDK/goexample">JustinSDK/goexample</a> 了，因此，你可以執行以下指令：</p>
<pre><code class="language-prettyprint">go get github.com/JustinSDK/goexample
</code></pre>
<p><code>go get</code> 會自行判斷該使用的協定，以這邊的例子來說，就會使用 <code>git</code> 來複製檔案庫至 src 目錄底下，結果就是 src/github.com/JustinSDK 底下，會有個 goexample 目錄，其中就是原始碼，<code>go get</code> 在下載原始碼之後，就會開始進行編譯，因此，你也會在 pkg 目錄中的 $GOOS_$GOARCH 目錄底下，github.com/JustinSDK 中找到編譯好的 .a 檔案。</p>
<p>接著，你就可以如上頭的程式撰寫 <code>import "github.com/JustinSDK/goexample"</code> 來使用這個套件。</p>
<p>當然，執行 <code>go install main</code> 的話，你的 pkg 目錄中的 <code>$GOOS_$GOARCH</code> 目錄，會有個 github.com/JustinSDK 目錄，裏頭放置著 goexample.a 檔案，而編譯出來的可執行檔，則會放置在 bin 目錄之中，此時，你的目錄應該會像是：</p>
<pre><code class="language-prettyprint">go-exercise
        ├─bin
        │      main.exe
        │
        ├─pkg
        │  └─windows_amd64
        │      └─github.com
        │          └─JustinSDK
        │                  goexample.a
        │
        └─src
            ├─github.com
            │  └─JustinSDK
            │      └─goexample
            │              .gitignore
            │              hello.go
            │              hi.go
            │              LICENSE
            │              README.md
            │
            └─main
                    main.go
</code></pre>
<h1 id="gopath-中多個路徑"><a class="header" href="#gopath-中多個路徑">GOPATH 中多個路徑</a></h1>
<p>如果你在 <code>GOPATH</code> 中設定多個路徑，那麼，在哪個路徑底下的 src 找到套件的原始碼，編譯出來的 .a 檔案就會放在哪個路徑底下的 pkg 目錄之中。</p>
<p>如果是包括程式進入點的 <code>main</code> 套件，那麼執行 <code>go install main</code> 的話，預設會放在找到 <code>main</code> 套件原始碼的 bin 目錄之中。你可以設定 <code>GOBIN</code>，指定編譯出來的可執行檔放置的目錄。</p>
<p>如果你在 <code>GOPATH</code> 中設定多個路徑，那麼，<code>go get</code> 複製回來的原始碼，會被放置在 <code>GOPATH</code> 中設置的第一個目錄 src 之中，同理，對應的 .a 檔案，也會是 <code>GOPATH</code> 中設置的第一個目錄的 pkg 之中。</p>
<h1 id="有關-import"><a class="header" href="#有關-import">有關 import</a></h1>
<p>在 <code>import</code> 時預設會使用套件名稱作為呼叫套件中函式等的前置名稱，你可以在 <code>import</code> 時指定別名。例如：</p>
<pre><code class="language-prettyprint">package main

import f "fmt"

func main() {
    f.Println("哈囉！世界！")
}
</code></pre>
<p>若指定別名時使用 <code>.</code>，就不需要套件名稱作為前置名稱，例如：</p>
<pre><code class="language-prettyprint">package main

import . "fmt"

func main() {
    Println("哈囉！世界！")
}
</code></pre>
<p>你不能只是 <code>import x "x"</code> 來試圖只執行套件的初始函式，因為 Go 編譯器不允許 <code>import</code> 了某個套件而不使用，然而若指定別名時使用 <code>_</code>，則不會導入套件，只會執行套件的初始函式，也就是套件中使用 <code>func init()</code> 定義的函式。</p>
<p>每個套件可以有多個 <code>init</code> 定義在各個不同的原始檔案中，套件被 <code>import</code> 時會執行，若是 <code>main</code> 套件，則會在所有 <code>init</code> 函式執行完畢後，再執行 <code>main</code> 函式，Go 執行套件初始化時，不會保證套件中多個 <code>init</code> 的執行順序。</p>
<div class="ad336-280" style="text-align: center;">
</div>
<div class="recommend" style="text-align: center;">
<hr />
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><div id="main" role="main" style="height: auto !important;">
<div class="header">
<h1 id="gofmt-格式化原始碼"><a class="header" href="#gofmt-格式化原始碼">gofmt 格式化原始碼</a></h1>
</div>
<p>如果你是個有點責任感的開發者，在新接觸一門語言的時候，應該會問一個問題：「我該用什麼格式寫程式？」所以了，在 Go 裏要用什麼格式寫程式？這個問題可以直接請 <code>gofmt</code> 來幫你解答。</p>
<h1 id="使用-gofmt"><a class="header" href="#使用-gofmt">使用 gofmt</a></h1>
<p>使用 <code>gofmt</code> 最簡單的方式之一，就是直接執行 <code>gofmt</code>，這會接受你在標準輸入（Standard input）鍵入的的程式碼，輸入完成後按下 Ctrl + Z，<code>gofmt</code> 就會告訴你怎麼要用什麼格式，例如，來個 Hello, World：</p>
<div class="pure-g">
<div class="pure-u-1">
<img src="images/gofmt-1.JPG" class="pure-img-responsive" alt="gofmt" />
</div>
</div>
<p>在上頭的例子中，我故意製作了一些其他的格式慣例，而從輸出中可以看到 <code>gofmt</code> 建議的格式會是什麼樣子，例如，Go 建議的格式是使用 Tab 縮排，你鍵入的程式碼不用是完整的程式，也可以只是個陳述句，例如：</p>
<div class="pure-g">
<div class="pure-u-1">
<img src="images/gofmt-2.JPG" class="pure-img-responsive" alt="gofmt" />
</div>
</div>
<p>你也可以指定檔案，格式化後的結果會輸出至標準輸出（Standard output），或者是一個目錄，這會遞迴地將其中的 .go 檔案讀入並格式化後，輸出至標準輸出，也可以加上 <code>-w</code> 指定以格式化後的結果重寫原有的 .go 文件。</p>
<p>有些格式在 Go 中是強制的，例如，大括號 <code>{}</code> 必須是右上左下的形式，因此，如果你將大括號置於同一側，執行 <code>gofmt</code> 就會得到錯誤訊息：</p>
<div class="pure-g">
<div class="pure-u-1">
<img src="images/gofmt-3.JPG" class="pure-img-responsive" alt="gofmt" />
</div>
</div>
<h1 id="gofmt-簡單重構"><a class="header" href="#gofmt-簡單重構">gofmt 簡單重構</a></h1>
<p><code>gofmt</code> 也可以使用 <code>-r</code> 指定規則來實現簡單的重構，例如在〈<a href="https://golang.org/cmd/gofmt/">Command gofmt</a>〉文件說明中，有個 <code>gofmt -r '(a) -&gt; a' -l *.go</code> 可以列出 .go 檔案中有多餘括號的檔案名稱（透過 <code>-l</code> 引數來列出名稱），要直接移除 .go 檔案中多餘的括號並重寫原有的 .go 檔案，可以使用 <code>gofmt -r '(a) -&gt; a' -w *.go</code>。</p>
<p><code>-r</code> 接受的規則是 <code>pattern -&gt; replacement</code>，其中 <code>pattern</code> 與 <code>replacement</code> 必須是合法的 Go 語法，而單一、小寫的字元會被作為萬用字元（Wildcard），因此，如果有個原始碼內容是：</p>
<pre><code class="language-prettyprint">package goexample

func Hello(who string) {
    var helloWho = ("Hello, ") + (who)
}
</code></pre>
<p>執行過後，會產生以下的結果：</p>
<pre><code class="language-prettyprint">package goexample

func Hello(who string) {
    var helloWho = "Hello, " + who
}
</code></pre>
<p>再來看個無聊的例子，如果你的程式碼是：</p>
<pre><code class="language-prettyprint">package goexample

func Hello(who string) {
    var helloWho = who + "Hello, "
}
</code></pre>
<p>若你想要 <code>gofmt</code> 幫你改成：</p>
<pre><code class="language-prettyprint">package goexample

func Hello(who string) {
    var helloWho = "Hello, " + who
}
</code></pre>
<p>你可以執行 <code>gofmt -r 'a + "Hello, " -&gt; "Hello, " + a' -w *.go</code>，甚至 <code>gofmt -r 'a + b -&gt; b + a' -w</code> 來達到這個目的。</p>
<p><code>gofmt</code> 還有個 <code>-s</code> 引數，可以嘗試為你簡化原始碼，你可以看看〈<a href="https://golang.org/cmd/gofmt/">Command gofmt</a>〉文件中的說明，瞭解它會做哪些簡化，文件中也談到，簡化後的 Go 原始碼，可能會與舊版的 Go 不相容。</p>
<p>至於方才提及的 <code>goimports</code>，也可以透過 <code>go get golang.org/x/tools/cmd/goimports</code> 來安裝，例如：</p>
<h1 id="go-fmt"><a class="header" href="#go-fmt">go fmt</a></h1>
<p><code>go</code> 本身也可以附帶 <code>fmt</code>，也就是使用 <code>go fmt</code> 的方式來進行程式碼的格式化，<code>go fmt</code> 內部使用 <code>gofmt</code>，可以使用 <code>-n</code> 來顯示要被使用或已被使用的指令：</p>
<div class="pure-g">
<div class="pure-u-1">
<img src="images/gofmt-5.JPG" class="pure-img-responsive" alt="go fmt" />
</div>
</div>
<p>可以看到，<code>go fmt</code> 包裝了 <code>gofmt -l -w</code> 指令，簡化了常用的指令輸入，你只要指定套件就可以了。</p>
<div class="ad336-280" style="text-align: center;">
</div>
<div class="recommend" style="text-align: center;">
<hr />
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><div id="main" role="main" style="height: auto !important;">
<div class="header">
<h1 id="go-doc-註解即文件"><a class="header" href="#go-doc-註解即文件">go doc 註解即文件</a></h1>
</div>
<p>如果你想查詢套件、函式等的說明，可以使用 <code>go doc</code> 指令。</p>
<h1 id="查詢文件"><a class="header" href="#查詢文件">查詢文件</a></h1>
<p>如果你想要查詢套件的文件說明，可以使用 <code>go doc packageName</code>，例如 <code>go doc fmt</code> 可查詢 <code>fmt</code> 套件的說明，</p>
<div class="pure-g">
<div class="pure-u-1">
<img src="images/godoc-1.JPG" class="pure-img-responsive" alt="go doc" />
</div>
</div>
<p>可以看到，這顯示了整個套件的說明，通常我們會想要查詢套件中某個函式，這可以使用 <code>go doc packageName.funcName</code>，例如，查詢 <code>fmt</code> 中的 <code>Println</code>，可以使用 <code>go doc fmt.Println</code>：</p>
<div class="pure-g">
<div class="pure-u-1">
<img src="images/godoc-2.JPG" class="pure-img-responsive" alt="go doc" />
</div>
</div>
<p>你也可以加上 <code>-src</code> 來查詢原始碼，雖然整個套件也可以查詢，不過我想，這直接開 Go 目錄的 src 中原始碼來看比較快，或許加上 <code>-src</code> 的機會，會是在查詢函式的原始碼時比較多：</p>
<div class="pure-g">
<div class="pure-u-1">
<img src="images/godoc-3.JPG" class="pure-img-responsive" alt="go doc" />
</div>
</div>
<p>如同 <code>go xxx</code> 的指令說明，想要得到 <code>go doc</code> 的說明，可以使用 <code>go help doc</code> 指令。</p>
<div class="pure-g">
<div class="pure-u-1">
<img src="images/godoc-6.JPG" class="pure-img-responsive" alt="go doc" />
</div>
</div>
<h1 id="註解即文件"><a class="header" href="#註解即文件">註解即文件</a></h1>
<p>實際上，<code>go doc</code> 的文件說明來自於原始碼中的註解，這樣的概念有點類似 Java 的 JavaDoc，或者是 Python 的 DocString，不過 Go 的理念是讓它更簡單，不使用特殊標記，不使用特別的格式，希望可以在沒有 <code>go doc</code> 的場合中，也可以藉由閱讀原始碼中的註解，輕易地得到文件說明。</p>
<p>當然，基本上還是要有一些約定，例如，在函式之前，緊接著函式的註解，中間沒有空白行，就是函式的文件說明來源。</p>
<p>類似地，在套件之前，緊接著套件的註解，就是套件的文件說明來源，通常，一個套件的文件說明，會是來自於套件中，一個 doc.go 中 <code>package</code> 宣告前的註解，例如，你可以在 <a href="https://golang.org/src/fmt/"><code>fmt</code> 的原始碼目錄</a> 中，找到一個 <a href="https://golang.org/src/fmt/doc.go">doc.go</a>，其中除了 <code>package fmt</code> 之外，沒有任何原始碼，剩下的只有註解。</p>
<p>除了函式、套件之外，最頂層的型態宣告、變數、常數等前緊接著的註解，都可以是文件的來源，不相鄰的註解則會被 <code>godoc</code> 忽略，如果有已知的 Bug，可以使用 <code>BUG()</code> 標示，例如 <a href="https://golang.org/src/bytes/bytes.go">bytes.go</a> 中有個：</p>
<pre><code class="language-prettyprint">// BUG(rsc): The rule Title uses for word boundaries does not handle Unicode punctuation properly.
func Title(s []byte) []byte {
    ....
</code></pre>
<p>這會出現在文件的 <a href="https://golang.org/pkg/bytes/#pkg-note-BUG">Bugs 區段</a>。</p>
<p>如果你想要從註解產生 HTML 文件（使用 <code>-html</code> 引數），那麼有幾個簡單的規則（用過 Markdown 的應該感覺有點熟悉），參考一下 Go 的原始碼，應該能很快地掌握。</p>
<p>基本上，<code>go doc</code> 會在 <code>GOROOT</code> 與 <code>GOPATH</code> 中的原始碼查詢註解作為文件，如果想改變查詢時的 Go 目錄，可以使用 <code>-goroot</code> 指定。</p>
<p>有關註解與文件間的關係，也可以進一步參考 <a href="https://golang.org/doc/effective_go.html#commentary">Effective Go 的 Commentary</a>。</p>
<h1 id="godoc-文件伺服器"><a class="header" href="#godoc-文件伺服器">godoc 文件伺服器</a></h1>
<p>Go 1.2rc1 之後，曾經從 <code>go doc</code> 改用 <code>godoc</code> 指令了，不過，從 <a href="https://golang.org/doc/go1.5">Go 1.5 Release Notes</a> 中看到，Go 1.5 有個新的 <code>go doc</code> 指令，專門用於命令列模式下的文件查詢，這使得 <code>godoc</code> 主要剩下文件服器的功能，因而在 Go 1.13 中，<code>godoc</code> 被移除。</p>
<p>如果在一個網路受限的環境，又想要在網頁上查詢文件，還是可以安裝 <code>godoc</code>：</p>
<pre><code class="language-prettyprint">go get -u golang.org/x/tools/cmd/godoc
</code></pre>
<p>這時執行 bin 中的 <code>godoc</code>，並附帶一個 <code>-http</code> 引數指定連接埠，例如，<code>./bin/godoc -http=:6060</code>，這會在本機啟動一個 HTTP 伺服器，使用瀏覽器連接 http://localhost:6060（或 http://主機IP:6060）就可以查詢文件：</p>
<div class="pure-g">
<div class="pure-u-1">
<img src="images/godoc-4.JPG" class="pure-img-responsive" alt="godoc" />
</div>
</div>
<div class="ad336-280" style="text-align: center;">
</div>
<div class="recommend" style="text-align: center;">
<hr />
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><div id="main" role="main" style="height: auto !important;">
<div class="header">
<h1 id="go-測試套件"><a class="header" href="#go-測試套件">Go 測試套件</a></h1>
</div>
<p>Go 本身附帶了 <code>testing</code> 套件，搭配 <code>go test</code> 指令，可以自動對套件中的程式碼進行測試，在套件中，測試程式碼必須是 _test.go 結尾，一個套件中可以有多個 _test.go，例如，<a href="https://golang.org/src/fmt/">fmt 套件的原始碼</a> 中，可以看到 export_test.go、fmt_test.go 等，就是測試程式碼。</p>
<h1 id="功能測試"><a class="header" href="#功能測試">功能測試</a></h1>
<p>想要使用 Go 的 <code>testing</code> 套件撰寫測試程式碼，必須 <code>import "testing"</code>，在 _test.go 中撰寫形式 <code>func TestXxx(t *testing.T)</code> 的函式，Xxx 可以是任意名稱，例如，在 src/mymath 目錄中，寫個 basic_test.go：</p>
<pre><code class="language-prettyprint">package mymath

import "testing"

func TestSomething(t *testing.T) {
    // write some test
}
</code></pre>
<div class="google-auto-placed" style="width: 100%; height: auto; clear: both; text-align: center;">
</div>
<p>接著只要執行 <code>go test mymath</code>，就會自動尋找 <code>mymath</code> 套件中的 _test.go 中 Test 開頭的函式並執行，由於目前沒撰寫任何測試內容，測試是以 PASS 結束。</p>
<div class="pure-g">
<div class="pure-u-1">
<img src="images/Testing-1.JPG" class="pure-img-responsive" alt="Go 測試套件" />
</div>
</div>
<p>如果函式中使用了 <code>testing</code> 的 <code>Error</code>、<code>Fail</code> 等與失敗相關的方法，那麼測試就會失敗，例如：</p>
<pre><code class="language-prettyprint">package mymath

import "testing"

func TestSomething(t *testing.T) {
    t.Fail()
}
</code></pre>
<div class="pure-g">
<div class="pure-u-1">
<img src="images/Testing-2.JPG" class="pure-img-responsive" alt="Go 測試套件" />
</div>
</div>
<div class="google-auto-placed" style="width: 100%; height: auto; clear: both; text-align: center;">
</div>
<p>如果想要在測試失敗時，留下一些訊息，可以使用 <code>Error</code> 方法，例如：</p>
<pre><code class="language-prettyprint">package mymath

import "testing"

func TestSomething(t *testing.T) {
    t.Error("something wrong")
}
</code></pre>
<div class="pure-g">
<div class="pure-u-1">
<img src="images/Testing-3.JPG" class="pure-img-responsive" alt="Go 測試套件" />
</div>
</div>
<p>來實際寫個測試，例如，測試一個 <code>Add</code> 函式：</p>
<pre><code class="language-prettyprint">package mymath

import "testing"

func TestAdd(t *testing.T) {
    if Add(1, 2) == 3 {
        t.Log("mymath.Add PASS")
    } else {
        t.Error("mymath.Add FAIL")
    }
}
</code></pre>
<p>由於目前還沒有撰寫 <code>Add</code> 函式，因此若執行 <code>go test mymath</code> 的話，會以 [build failed] 收場，如果在 basic.go 撰寫了正確的 <code>Add</code> 函式：</p>
<pre><code class="language-prettyprint">package mymath

func Add(a, b int) int {
    return a + b
}
</code></pre>
<p>不過，如果直接執行 <code>go test mymath</code> 的話，只會顯示 ok 等字眼，不會顯示 <code>Log</code> 的訊息，想看到 <code>Log</code> 的訊息的話，必須加上 <code>-v</code> 引數（代表 verbose），例如：</p>
<div class="pure-g">
<div class="pure-u-1">
<img src="images/Testing-4.JPG" class="pure-img-responsive" alt="Go 測試套件" />
</div>
</div>
<p>如果 <code>Log</code> 之後接上 <code>Fail</code> 函式，那麼不加上 <code>-v</code>，也會顯示 <code>Log</code> 的訊息，實際上，<code>Error</code> 函式就是相當於先以 <code>Log</code> 顯示指定的訊息，然後再接上 <code>Fail</code> 函式。</p>
<p>如果想要略過測試，那麼可以使用 <code>Skip</code> 函式，例如：</p>
<pre><code class="language-prettyprint">package mymath

import "testing"

func TestSomething(t *testing.T) {
    t.Skip()
}

func TestAdd(t *testing.T) {
    if Add(1, 2) == 3 {
        t.Log("mymath.Add PASS")
    } else {
        t.Error("mymath.Add FAIL")
    }
}
</code></pre>
<p><code>TestSomething</code> 中如果沒有執行 <code>Skip</code> 會是兩個 PASS 的測試結果，若如上執行了 <code>Skip</code>，會是一個 SKIP 與一個 PASS 的測試結果。例如：</p>
<div class="pure-g">
<div class="pure-u-1">
<img src="images/Testing-5.JPG" class="pure-img-responsive" alt="Go 測試套件" />
</div>
</div>
<p>如果你想指定某個測試，可以使用 <code>-run</code> 引數，這接受一個正則表示式，例如，若只想執行 <code>TestAdd</code>，那麼可以如下：</p>
<div class="google-auto-placed" style="width: 100%; height: auto; clear: both; text-align: center;">
</div>
<div class="pure-g">
<div class="pure-u-1">
<img src="images/Testing-6.JPG" class="pure-img-responsive" alt="Go 測試套件" />
</div>
</div>
<h1 id="效能評測"><a class="header" href="#效能評測">效能評測</a></h1>
<p>如果想進行效能評測（Benchmark），那麼 _test.go 中，評測函式必須是 <code>func BenchmarkXxx(b *testing.B)</code> 形式，例如：</p>
<pre><code class="language-prettyprint">package mymath

import "testing"

func TestSomething(t *testing.T) {
    t.Skip()
}

func TestAdd(t *testing.T) {
    if Add(1, 2) == 3 {
        t.Log("mymath.Add PASS")
    } else {
        t.Error("mymath.Add FAIL")
    }
}

func BenchmarkAdd(b *testing.B) {
    for i := 0; i &lt; b.N; i++ {
        Add(1, 2)
    }
}
</code></pre>
<p>為了進行評測，被測試的函式要執行多次，以求得每次執行的平均時間，要執行多次函式可以使用迴圈，並以 <code>b.N</code> 作為邊界，<code>b.N</code> 目標預設是 1000000000，評測預設會在一秒內，以越來越大的 <code>b.N</code> 執行迴圈，這是為了讓評測進入穩定狀態，以收集到可靠的評測資料；如果運行時間到了，<code>b.N</code> 目標值仍未達成，就以現有收集到的資料來回報評測結果。</p>
<p>你可以在執行 <code>go test</code> 時，加上 <code>-bench</code> 引數，這個引數後可以使用正則表示式，來指定符合的評測函式名稱，例如，想執行所有評測函式，可以使用 <code>-bench="."</code>：</p>
<div class="google-auto-placed" style="width: 100%; height: auto; clear: both; text-align: center;">
</div>
<div class="pure-g">
<div class="pure-u-1">
<img src="images/Testing-7.JPG" class="pure-img-responsive" alt="Go 測試套件" />
</div>
</div>
<p>評測的結果中顯示，達到了 <code>b.N</code> 預設目標 100000000 次，平均每次迴圈花了 0.58 奈秒（nanosecond）。</p>
<p>如果只想進行效能評測，可以使用 <code>-run</code> 引數，這本來是用來指定要執行的測試函式，只要指定一個不符合任何測試函式的正則表示式，就可以略過所有測試，只執行評測函式了，例如：</p>
<div class="pure-g">
<div class="pure-u-1">
<img src="images/Testing-8.JPG" class="pure-img-responsive" alt="Go 測試套件" />
</div>
</div>
<p>方才談到，評測預設的運行時間是一秒，如果在這個時間內，無法達到 <code>b.N</code> 的目標值，可以增加這個時間，這要使用 <code>-benchtime</code> 引數，指定的格式像是 1h30s，例如：</p>
<div class="pure-g">
<div class="pure-u-1">
<img src="images/Testing-9.JPG" class="pure-img-responsive" alt="Go 測試套件" />
</div>
</div>
<p>如果想固定 <code>b.N</code> 的值，Go 1.12 以後可以使用 <code>x</code> 後置，例如指定執行 100000000000 次（預設 <code>b.N</code> 目標的 10 倍）並收集結果：</p>
<div class="pure-g">
<div class="pure-u-1">
<img src="images/Testing-10.JPG" class="pure-img-responsive" alt="Go 測試套件" />
</div>
</div>
<p><code>-count</code> 可以指定評測重啟幾次：</p>
<div class="pure-g">
<div class="pure-u-1">
<img src="images/Testing-11.JPG" class="pure-img-responsive" alt="Go 測試套件" />
</div>
</div>
<p>想知道更多 Go 測試套件的細節，可以參考 <a href="https://golang.org/pkg/testing/">Package testing</a> 的說明。</p>
<div class="ad336-280" style="text-align: center;">
</div>
<div class="recommend" style="text-align: center;">
<hr />
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><div id="main" role="main" style="height: auto !important;">
<div class="header">
<h1 id="認識預定義型態"><a class="header" href="#認識預定義型態">認識預定義型態</a></h1>
</div>
<p>Go 包括了一些預先定義型態（Pre-declared Type），這包括了布林、數字與字串型態。</p>
<h1 id="布林型態"><a class="header" href="#布林型態">布林型態</a></h1>
<p>預定義型態也是具有名稱的型態（Named Type），布林型態名稱為 <code>bool</code>，只有兩個預先定義的常數 <code>true</code> 與 <code>false</code>，由於只有兩個值，因此在 <a href="https://golang.org/ref/spec#Boolean_types">Go 的規格書</a> 中，並沒有明確提及 <code>bool</code> 的大小，雖然在 Go 官方網站的 <a href="https://play.golang.org/">The Go Playground</a> 執行以下程式碼，會告訴你 <code>bool</code> 大小是 1：</p>
<pre><code class="language-prettyprint">package main

import (
    "fmt"
    "unsafe"
)

func main() {
    fmt.Println(unsafe.Sizeof(true))
    fmt.Println(unsafe.Sizeof(false))
}
</code></pre>
<p>附帶一提的是，Go 本身沒有提供 REPL 工具，不過 Go 官方網站的 <a href="https://play.golang.org/">The Go Playground</a> 是個方便的介面，你也可以在 <a href="http://stackoverflow.com/questions/8513609/does-go-provide-repl">Does Go provide REPL?</a> 找到一些其他開發者寫的 REPL。</p>
<h1 id="數字型態"><a class="header" href="#數字型態">數字型態</a></h1>
<p>數字型態為整數與浮點數的集合，整數部份支援無號與有號整數，名稱分別為 <code>uint</code> 與 <code>int</code>，<code>int</code> 長度會與 <code>uint</code> 相同，而 <code>uint</code> 長度視平台實作而異，可能是 32 位元或是 64 位元。</p>
<p>如果想要長度固定，無號整數的型態名稱為 <code>uint8</code>、<code>uint16</code>、<code>uint32</code>、<code>uint64</code>，顧名思義，使用的長度分別為 8 位元、16 位元、32 位元與 64 位元，舉例來說，<code>uint8</code> 可儲存的整數範圍為 0 到 255，這也是開發者熟悉的位元組型態，而在 Go 中，<code>byte</code> 正是　<code>uint8</code> 的別名。</p>
<p>有號整數的型態名稱為 <code>int8</code>、<code>int16</code>、<code>int32</code>、<code>int64</code>，顧名思義，使用的長度分別為 8 位元、16 位元、32 位元與 64 位元，舉例來說，<code>int32</code> 可儲存的整數範圍為 -2147483648 到 2147483647，而 <code>rune</code> 為 <code>int32</code> 的別名，可用來儲存 Unicode 碼點（code point）。</p>
<p>如果直接寫下一個整數實字（literal），例如 <code>10</code>，在沒有程式上下文（context）的情況下，<code>10</code> 是未定型態（Untyped），未定義型態整數的預設型態（Default type）為 <code>int</code> 型態，在必須得到一個型態而程式上下文未提供時（例如變數宣告與賦值要進行型態推斷時），就會使用預設型態。</p>
<p>寫下 <code>10</code> 這樣的整數，預設是 10 進位制；可以在數字前加上 0，Go 1.13 後可使用 0o 來表示八進位制，加上 0x 表示 16 進位制，此時 a-f and A-F 都可以用來表示 10 到 15，例如 <code>0xBadFace</code>，G○ 1.13 後可以使用 <code>0x1.0p-1021</code> 來表示浮點數。</p>
<p>Go 1.13 後，可以使用 <code>0b</code> 來定義二進位數字，例如 <code>0b00101101</code>；數字分隔底線在 Go 1.13 後可以使用，例如 <code>1_000_000</code>、<code>0b_1010_0110</code> 或 <code>3.1415_9265</code>。</p>
<p><code>math</code> 模組上定義了一些常數，可以讓你得知各整數型態的儲存範圍，例如以下程式顯示了各整數型態的儲存範圍：</p>
<pre><code class="language-prettyprint">package main

import (
    "fmt"
    "math"
    "reflect"
)

func main() {
    fmt.Printf("uint8  : 0 ~ %d\n", math.MaxUint8)
    fmt.Printf("uint16 : 0 ~ %d\n", math.MaxUint16)
    fmt.Printf("uint32 : 0 ~ %d\n", math.MaxUint32)
    fmt.Printf("uint64 : 0 ~ %d\n", uint64(math.MaxUint64))
    fmt.Printf("int8   : %d ~ %d\n", math.MinInt8, math.MaxInt8)
    fmt.Printf("int16  : %d ~ %d\n", math.MinInt16, math.MaxInt16)
    fmt.Printf("int32  : %d ~ %d\n", math.MinInt32, math.MaxInt32)
    fmt.Printf("int64  : %d ~ %d\n", math.MinInt64, math.MaxInt64)
    fmt.Printf("整數預設型態: %s\n", reflect.TypeOf(1))
}
</code></pre>
<p>執行結果如下：</p>
<pre><code class="language-prettyprint">uint8  : 0 ~ 255
uint16 : 0 ~ 65535
uint32 : 0 ~ 4294967295
uint64 : 0 ~ 18446744073709551615
int8   : -128 ~ 127
int16  : -32768 ~ 32767
int32  : -2147483648 ~ 2147483647
int64  : -9223372036854775808 ~ 9223372036854775807
整數預設型態: int
</code></pre>
<p>注意到，程式中使用了 <code>uint64</code> 函式，對 <code>math</code> 的一些常數做了明確的型態轉換（Type conversion），這是因為在 Go 中，常數可以是未定型態（Untyped），實際型態會視當時程式環境而定，如果沒有可參考的環境資訊，會使用預設型態。</p>
<p>在這邊的例子中，若是拿掉 <code>uint64</code>，<code>math.MaxUint64</code> 就會採用 <code>int</code> 型態而發生 overflow 的錯誤，使用 <code>uint64</code> 函式進行型態轉換，讓常數有明確的環境資訊可以參考，就不會產生這個錯誤。</p>
<p>在 Go 中，不同型態之間也無法直接進行運算，就算都是整數也不行，例如以下會發生 mismatched types 錯誤：</p>
<pre><code class="language-prettyprint">package main

import "fmt"

func main() {
    var x int32 = 10
    var y int16 = 20
    fmt.Println(x + y) // mismatched types error
}
</code></pre>
<p>想要避免錯誤，你必須明確進行型態轉換，例如寫為 <code>x + int32(y)</code>（或者是 <code>int16(x) + y</code>）。那麼，下面這個會不會發生錯誤呢？</p>
<pre><code class="language-prettyprint">package main

import "fmt"

func main() {
    var x int8 = 10
    fmt.Println(x + 20)
}
</code></pre>
<p>不會！結果會顯示 30，為什麼？正如先前談過，寫下 <code>20</code> 這個整數，它是未定型態，根據 <code>x + 20</code>，進行 <code>int8</code> 的運算，所以不會發生錯誤，不這樣的話，每次都得寫 <code>x + int8(20)</code>，實在就夠煩的了！</p>
<p>在 Go 中並沒有字元對應的型態，只有碼點的概念，<code>int32</code> 或其別名 <code>rune</code> 可用來儲存 Unicode 碼點，你可以將單一文字包在單引號之中，例如 <code>'林'</code>，這會以 <code>int32</code> 儲存為 26519，例如 <code>fmt.Println('林')</code> 會顯示 26519，若想顯示為文字，則要使用 <code>fmt.Println(string('林'))</code>。</p>
<p>浮點數的名稱為 <code>float32</code>、<code>float64</code>，分別為 IEEE-754 32 位元與 64 位元浮點數，如果直接寫下一個浮點數實字，預設型態是 <code>float64</code> 型態，可使用科學記號，例如 <code>1.e+0</code>、<code>6.67428e-11</code> 等，常數 <code>math.MaxFloat32</code>、<code>math.MaxFloat64</code> 分別代表著浮點數的最大儲存範圍。</p>
<p>Go 還有複數（Complex number），其中 <code>complex64</code>、<code>complex128</code>，可由一個實部數字，加上一個虛部數字與 <code>i</code> 來表示複數，例如 <code>1 + 2i</code>，寫下一個複數實字，預設型態為 <code>complex128</code>，虛數的部份，在 Go 1.13 後，之前談到的數字表示法都可以使用，有三個函式可以用來處理複數，即 <code>complex</code>、<code>real</code> 與 <code>imag</code>，可參考〈<a href="https://golang.org/ref/spec#Complex_numbers">Manipulating complex numbers</a>〉。</p>
<p>Go 還有個 <code>uintptr</code>，可以用來儲存指標值，這之後有機會再來談。</p>
<h1 id="字串型態"><a class="header" href="#字串型態">字串型態</a></h1>
<p>Go 的字串在實作上使用 <a href="http://openhome.cc/Gossip/Encoding/UTF8.html">UTF-8</a>，就目前必須先知道的是，當使用雙引號包裹一系列文字，會產生字串型態，預設型態為 <code>string</code>，例如，<code>"Justin"</code> 會建立一個字串。</p>
<p>如果對字串使用 <code>len</code> 函式，傳回的會是位元組數量，而不是 Unicode 碼點的數量；如果使用 <code>[]</code> 搭配索引，取得特定索引位置的值，那麼傳回的會是 <code>byte</code>（<code>uint8</code>）型態。</p>
<p>在 Go 中，可以對字串使用切片（slice）操作，傳回的型態會是 <code>string</code> 型態，例如，<code>"Justin"[0:2]</code> 會傳回字串 <code>"Ju"</code>，不過，這是取得索引 0、1 處的位元組，再建立 <code>string</code> 傳回，因此，對於 <code>"語言"</code> 這個字串，如果想用切片操作取得 <code>"語"</code> 這個子字串，必須使用 <code>"語言"[0:3]</code>，因為 Go 的字串在實作上使用 UTF-8，一個中文字基本上佔三個位元組。</p>
<p>Go 的字串還有許多值得說明的細節，這之後會再做詳細討論。</p>
<div class="ad336-280" style="text-align: center;">
</div>
<div class="recommend" style="text-align: center;">
<hr />
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><div id="main" role="main" style="height: auto !important;">
<div class="header">
<h1 id="變數宣告常數宣告"><a class="header" href="#變數宣告常數宣告">變數宣告、常數宣告</a></h1>
</div>
<p>變數（Variable）是儲存值的位置，變數宣告可以給予識別名稱（Identifier）、型態與初始值，在 Go 中寫下的 <code>10</code>、<code>3.14</code>、<code>true</code>、<code>"Justin"</code> 等稱之為常數（Constant），常數宣告可給予這些常數識別名稱。</p>
<h1 id="基本變數宣告"><a class="header" href="#基本變數宣告">基本變數宣告</a></h1>
<p>要在 Go 中進行變數宣告有多種形式，使用 <code>var</code> 是最基本的方式。例如，宣告一個 <code>x</code> 變數，型態為 <code>int</code>，初始值為 <code>10</code>：</p>
<pre><code class="language-prettyprint">var x int = 10
</code></pre>
<p>這麼一來，從 <code>x</code> 這個位置開始，儲存了 <code>int</code> 長度的值 10，在宣告變數時，型態是寫在名稱之後。你也可以同時建立多個變數並指定初值：</p>
<pre><code class="language-prettyprint">var x, y, z int = 10, 20, 30
</code></pre>
<p>這樣的話，<code>x</code>、<code>y</code>、<code>z</code> 的型態都是 <code>int</code>，值分別是 <code>10</code>、<code>20</code>、<code>30</code>。如果宣告多個變數時，想要指定不同的型態，可以使用批量宣告：</p>
<pre><code class="language-prettyprint">var (
    x int = 10
    y string = "Justin"
    z bool = true
)
</code></pre>
<div class="google-auto-placed" style="width: 100%; height: auto; clear: both; text-align: center;">
</div>
<p>如果宣告變數時指定了型態，但未指定初值，那麼編輯器會提供預設初值，例如：</p>
<pre><code class="language-prettyprint">var (
    a bool        
    b int32
    c float32
    d string
    e complex128
)
</code></pre>
<p>在上面的宣告中，<code>a</code>、<code>b</code>、<code>c</code>、<code>d</code>、<code>e</code> 的值分別會是 <code>false</code>、<code>0</code>、<code>0.0</code>、<code>""</code> 與 <code>0 + 0i</code>。在 Go 中，宣告了變數，程式中卻沒有取用的動作，那麼會發生 declared and not used 的編譯錯誤。</p>
<h1 id="自動推斷型態"><a class="header" href="#自動推斷型態">自動推斷型態</a></h1>
<p>在 Go 中宣告變數並指定值時，可以不用提供型態，由編譯器自動推斷型態，例如：</p>
<pre><code class="language-prettyprint">var x = 10
</code></pre>
<div class="google-auto-placed" style="width: 100%; height: auto; clear: both; text-align: center;">
</div>
<p>上頭的 <code>x</code> 型態會是 <code>int</code>，而底下的宣告：</p>
<pre><code class="language-prettyprint">var x, y, z = 10, 3.14, "Justin"
</code></pre>
<p><code>x</code>、<code>y</code>、<code>z</code> 的型態分別會是 <code>int</code>、<code>float64</code> 與 <code>string</code>，批量宣告時也可以自動推斷型態，例如：</p>
<pre><code class="language-prettyprint">var (
    x = 10        // int 型態
    y = 3.14      // float32 型態
    z = "Justin"  // string 型態
)
</code></pre>
<h1 id="短變數宣告"><a class="header" href="#短變數宣告">短變數宣告</a></h1>
<p>在函式中，想要定義變數值的場合，可以使用短變數宣告，例如：</p>
<pre><code class="language-prettyprint">x := 10
y := 3.14
z := "Justin"
</code></pre>
<div class="google-auto-placed" style="width: 100%; height: auto; clear: both; text-align: center;">
</div>
<p>如果 <code>x</code> 是首次定義，就等於是宣告變數並指定值。上例也可以寫成一行：</p>
<pre><code class="language-prettyprint">x, y, z := 10, 3.14, "Justin"
</code></pre>
<p>由於 Go 的函式外，每個語法都必須以關鍵字開始，因此短變數宣告不能在函式外使用。</p>
<p><code>var</code> 宣告的變數名稱不可重複，然而，短變數宣告時，若同一行內有新宣告了另一變數，就可以重複宣告已存在的變數，例如，以下是合法的，因為使用 <code>:=</code> 時有一個新的 <code>y</code> 變數：</p>
<pre><code class="language-prettyprint">var x = 10
x, y :=  20, 30
</code></pre>
<p>此時，並沒有建立一個新的 <code>x</code> 變數，只是將新值指定給 <code>x</code> 而已。</p>
<p>由於短變數宣告可以同時宣告變數並指定值，因此對於底下這類需求：</p>
<pre><code class="language-prettyprint">package main

import "fmt"

func main() {
    var x = true
    if x {
        fmt.Println(x)
    }
}
</code></pre>
<p>在上例，<code>x</code> 的範圍是整個 <code>main</code>，若改為底下，範圍就只會是 <code>if</code> 區塊：</p>
<pre><code class="language-prettyprint">package main

import "fmt"

func main() {
    if x := true; x {
        fmt.Println(x)
    }
}
</code></pre>
<p>類似地，<code>for</code> 之類的語法，也常運用短變數宣告。</p>
<p>（在數學上 <code>A := B</code> 的寫法，涵義是藉由 B 來定義 A，例如數學上若已經定義 <code>x</code> 以及 <code>f(x)</code>，<code>x := f(x)</code> 表示用舊的 <code>x</code> 定義新的 <code>x</code>，這反而像是程式語言中的 <code>x = f(x)</code> 指定的概念，當然，數學上的符號與程式語言中的符號是有出入的，Go 在這邊只是借用了 <code>:=</code> 來作為另一種變數宣告符號。）</p>
<h1 id="調換變數值"><a class="header" href="#調換變數值">調換變數值</a></h1>
<p>在 Go 中，要調換兩變數的值很簡單，例如底下的程式執行過後，<code>x</code> 會是 <code>20</code>，而 <code>y</code> 會是 <code>10</code>：</p>
<pre><code class="language-prettyprint">var x = 10
var y = 20
x, y = y, x
</code></pre>
<h1 id="基本常數宣告"><a class="header" href="#基本常數宣告">基本常數宣告</a></h1>
<p>如一開始談到的，在 Go 中寫下的 <code>10</code>、<code>3.14</code>、<code>true</code>、<code>"Justin"</code> 等稱之為常數（Constant），常數宣告可給予這些常數識別名稱，要給予名稱時使用的是 <code>const</code> 關鍵字，例如：</p>
<pre><code class="language-prettyprint">const x = 10
</code></pre>
<p>正如〈<a href="http://openhome.cc/Gossip/Go/PreDeclaredType.html">認識預定義型態</a>〉中談過的，10 會是一個整數常數，不過型態未定，如果要定義一個常數的型態，可以使用 <code>int32()</code>、<code>int64()</code> 之類的函式進行型態轉換，或者是在使用 <code>const</code> 宣告常數名稱時指定型態，例如：</p>
<pre><code class="language-prettyprint">const x int32 = 10
</code></pre>
<p>這邊的 <code>10</code> 就是 <code>int32</code> 型態了，注意，這邊的 <code>x</code> 並不是一個變數，而是一個識別名稱罷了，因此，會說 <code>x</code> 常數的型態是 <code>int32</code>，而不能說 <code>x</code> 變數的型態是 <code>int32</code>。</p>
<p>如果有多個常數要宣告，也可以批量宣告，例如：</p>
<pre><code class="language-prettyprint">const (
    x = 10
    y = 3.14
    z = "Justin"
)
</code></pre>
<p>再次地，<code>x</code>、<code>y</code>、<code>z</code> 分別是未定型態的整數、浮點數與字串常數（而不是 <code>int</code>、<code>float64</code>、<code>string</code> 這三個 Go 中定義的型態），如果你想要讓他們為已定義型態的整數、浮點數與字串常數，可以在宣告時指定型態：</p>
<pre><code class="language-prettyprint">const (
    x int = 10
    y float32 = 3.14
    z string = "Justin"
)
</code></pre>
<p>由於常數並非變數，因此，宣告了常數並不一定要用到，底下的程式不會發生錯誤：</p>
<pre><code class="language-prettyprint">package main

import "fmt"

func main() {
    const (
        x = 10
        y = 3.14
        z = "Justin"
    )

    fmt.Println(x)
    fmt.Println(y)
}
</code></pre>
<h1 id="常數運算式"><a class="header" href="#常數運算式">常數運算式</a></h1>
<p>由於常數可以是未定型態，因此一個有趣的地方就是，像 <code>2 + 3.0</code>、<code>15 / 4</code>、<code>15 / 4.0</code> 這樣的常數運算式，該怎麼在編譯時期決定它們的值？答案是根據運算式中的常數運算元是整數、<code>rune</code>（單引號括住的常數）、浮點數或複數來決定，如果運算式中包括了越後面的常數，就會用它來決定。</p>
<p>因此，<code>2 + 3.0</code> 會是未定型態的浮點數 <code>5.0</code>，<code>15 / 4</code> 會是未定型態的整數 <code>3</code>，然而，<code>15 / 4.0</code>，會是浮點數型態的 <code>3.75</code>，在規格書的〈<a href="https://golang.org/ref/spec#Constant_expressions">Constant expressions</a>〉中，列出了說明以及一些範例，例如：</p>
<pre><code class="language-prettyprint">const a = 2 + 3.0          // a == 5.0   (untyped floating-point constant)
const b = 15 / 4           // b == 3     (untyped integer constant)
const c = 15 / 4.0         // c == 3.75  (untyped floating-point constant)
const Θ float64 = 3/2      // Θ == 1.0   (type float64, 3/2 is integer division)
const Π float64 = 3/2.     // Π == 1.5   (type float64, 3/2. is float division)
const d = 1 &lt;&lt; 3.0         // d == 8     (untyped integer constant)
const e = 1.0 &lt;&lt; 3         // e == 8     (untyped integer constant)
const f = int32(1) &lt;&lt; 33   // illegal    (constant 8589934592 overflows int32)
const g = float64(2) &gt;&gt; 1  // illegal    (float64(2) is a typed floating-point constant)
const h = "foo" &gt; "bar"    // h == true  (untyped boolean constant)
const j = true             // j == true  (untyped boolean constant)
const k = 'w' + 1          // k == 'x'   (untyped rune constant)
const l = "hi"             // l == "hi"  (untyped string constant)
const m = string(k)        // m == "x"   (type string)
const Σ = 1 - 0.707i       //            (untyped complex constant)
const Δ = Σ + 2.0e-4       //            (untyped complex constant)
const Φ = iota*1i - 1/1i   //            (untyped complex constant)
</code></pre>
<p>現在，應該能明白，〈<a href="http://openhome.cc/Gossip/Go/PreDeclaredType.html">認識預定義型態</a>〉中 <code>math.MaxInt64</code> 若不加上 <code>int64</code>，何以會 overflow 的錯誤了。</p>
<p>附帶一提的是，在 Go 中，模組中定義的名稱若要能在模組外可見，必須是首字大寫，而對於像 <code>math.MaxInt64</code> 這類的公用常數，可以定義在一個 .go 檔案之中，例如 <code>math.MaxInt64</code>，就是定義在一個 <a href="https://golang.org/src/math/const.go">const.go</a> 之中。</p>
<h1 id="使用-iota-列舉"><a class="header" href="#使用-iota-列舉">使用 iota 列舉</a></h1>
<p>如果要需要列舉一些常數時，可以使用 <code>iota</code>，它每遇到一次 <code>const</code>，就會重置為 <code>0</code>，若它在批量常數宣告中使用時，第一次出現時的預設值是 <code>0</code>，每出現一次就遞增 <code>1</code>，例如：</p>
<pre><code class="language-prettyprint">const (
    x = iota   // 0
    y = iota   // 1
    z = iota   // 2
 )
</code></pre>
<p>因為 <code>const</code> 批量宣告時，若後面的值沒寫出，會使用前一個值設定，例如：</p>
<pre><code class="language-prettyprint">const (
    x = 1
    y      // 1
    z      // 1
 )
</code></pre>
<p>因此，如果是連續的列舉，只要寫一次 <code>iota</code> 就可以了，這表示後續的值，也都使用 <code>iota</code>，結果就是：</p>
<pre><code class="language-prettyprint">const (
    x = iota   // 0
    y          // 1
    z          // 2
 )
</code></pre>
<p>其實也可以這麼寫來列舉常數，只是比較麻煩：</p>
<pre><code class="language-prettyprint">const x, y, z = iota, iota, iota
</code></pre>
<div class="ad336-280" style="text-align: center;">
</div>
<div class="recommend" style="text-align: center;">
<hr />
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><div id="main" role="main" style="height: auto !important;">
<div class="header">
<h1 id="位元組構成的字串"><a class="header" href="#位元組構成的字串">位元組構成的字串</a></h1>
</div>
<p>在〈<a href="http://openhome.cc/Gossip/Go/PreDeclaredType.html">認識預定義型態</a>〉中略略談過字串，表面看來，用雙引號（<code>"</code>）或反引號（`）括起來的文字就是字串，預設型態為 <code>string</code>，實際在 Go 中，字串是由唯讀的 UTF-8 編碼位元組所組成。</p>
<h1 id="字串入門"><a class="header" href="#字串入門">字串入門</a></h1>
<p>先從簡單的開始，在 Go 原始碼中，如果你撰寫 <code>"Go語言"</code> 這麼一段文字，那麼會產生一個字串，預設型態為 <code>string</code>，字串是唯讀的，一旦建立，就無法改變字串內容。</p>
<p>使用 <code>string</code> 宣告變數若無指定初值，預設是空字串 <code>""</code>，可以使用 <code>+</code> 對兩個字串進行串接，由於字串是唯讀的，因此實際上串接的動作，會產生新的字串，如果想比較兩個字串的相等性，可以使用 <code>==</code>、<code>!=</code>、<code>&lt;</code>、<code>&lt;=</code>、<code>&gt;</code>、<code>&gt;=</code> 依字典順序比較。</p>
<pre><code class="language-prettyprint">package main

import "fmt"

func main() {
    text1 := "Go語言"
    text2 := "Cool"
    var text3 string
    fmt.Println(text1 + text2) // Go語言Cool
    fmt.Printf("%q\n", text3)  // ""
    fmt.Println(text1 &gt; text2) // true
}
</code></pre>
<p>上面的例子中，由於使用 <code>fmt.Println</code> 顯示空字串時看不到什麼，因此改用 <code>fmt.Printf</code>，並使用 <code>%q</code> 來脫離無法顯示的字元。</p>
<div class="google-auto-placed" style="width: 100%; height: auto; clear: both; text-align: center;">
</div>
<p>使用 <code>""</code> 時不可換行，如果你的字串想要換行，方法之一是分兩個字串，並用 <code>+</code> 串接。例如：</p>
<pre><code class="language-prettyprint">    text := "Go語言" +
            "Cool" 
</code></pre>
<p>另一個方式是以重音符 ` 定義字串，例如：</p>
<pre><code class="language-prettyprint">package main

import "fmt"

func main() {
    text := `Go語言
                 Cool`
    fmt.Printf("%q\n", text) // "Go語言\n                  Cool"
}
</code></pre>
<p>使用 ` 定義的字串，會完全保留換行與空白，因此，在上頭你可以看到被保留的換行與空白字元，如果使用 <code>fmt.Println(text)</code>，顯示時也會看到對應的換行與空白。使用 ` 定義的字串，也不會轉譯字元，例如：</p>
<pre><code class="language-prettyprint">package main

import "fmt"

func main() {
    text := `Go語言\nCool`
    fmt.Println(text)  // Go語言\nCool
}
</code></pre>
<div class="google-auto-placed" style="width: 100%; height: auto; clear: both; text-align: center;">
</div>
<p>在這個例子中可以看到，使用 ` 時，不會對 <code>\n</code> 做轉譯的動作，因此，你會直接看到顯示了「Go語言\nCool」。</p>
<p>在 Go 中可以使用的轉譯有：</p>
<ul>
<li><code>\a</code>：U+0007，警示或響鈴</li>
<li><code>\b</code>：U+0008，倒退（backspace）</li>
<li><code>\f</code>：U+000C，饋頁（form feed）</li>
<li><code>\n</code>：U+000A，換行（newline）</li>
<li><code>\r</code>：U+000D，歸位（carriage return）</li>
<li><code>\t</code>：U+0009，水平 tab</li>
<li><code>\v</code>：U+000b，垂直 tab</li>
<li><code>\\</code>：U+005c，反斜線（backslash）</li>
<li><code>\"</code>：U+0022，雙引號</li>
<li><code>\ooo</code>：位元組表示，o 為八進位數字</li>
<li><code>\xhh</code>：位元組表示，h 為十六進位數字</li>
<li><code>\uhhhh</code>：Unicode 點點表示，使用四個 16 進位數字</li>
<li><code>\Uhhhhhhhh</code>：Unicode 點點表示，使用八個 16 進位數字</li>
</ul>
<h1 id="唯讀位元組片段"><a class="header" href="#唯讀位元組片段">唯讀位元組片段</a></h1>
<p>那麼，想知道一個字串的長度該怎麼做呢？Go 中有個 <code>len</code> 函式，當它作用於字串時，結果可能會令一些從其他程式語言，像是 Java 過來的人感到訝異：</p>
<pre><code class="language-prettyprint">package main

import "fmt"

func main() {
    fmt.Println(len("Go語言")) // 8
}
</code></pre>
<div class="google-auto-placed" style="width: 100%; height: auto; clear: both; text-align: center;">
</div>
<p>顯示的結果是 8 而不是 4，給個提示，Go 的字串實作使用 UTF-8，是的！<code>len</code> 傳回的是位元組長度，因為 Go 的字串，本質上是 UTF-8 編碼後的位元組組成，如果你使用 <code>fmt.Printf("%x", "Go語言")</code>，會顯示 476fe8aa9ee8a880，47 是「G」的位元組以 16 進位數字表示的結果，6f 是 o，e8aa9e 是「語」的三個位元組分別以 16 進位數字表示的結果，e8a880 是「言」。</p>
<p>不單是如此，Go 中可以使用 <code>[]</code> 與索引來取得字串的位元組資料，是的，位元組！傳回的型態是 <code>byte</code>（<code>uint8</code>），<code>"Go語言"[0]</code> 取得的是 G 的位元組資料，<code>"Go語言"[1]</code> 取得的是 o 的位元組資料，<code>"Go語言"[2]</code> 呢？取得的是「語」的 UTF-8 實作中，第一個位元組資料，也就是 e8。可以用以下這個程式片段來印證：</p>
<pre><code class="language-prettyprint">package main

import "fmt"

func main() {
    text := "Go語言"
    for i := 0; i &lt; len(text); i++ {
        fmt.Printf("%x ", text[i])
    }
}
</code></pre>
<div class="google-auto-placed" style="width: 100%; height: auto; clear: both; text-align: center;">
</div>
<p>雖然還沒正確介紹 <code>for</code> 迴圈，不過程式應該很清楚，用迴圈遞增的 <code>i</code> 值來取得指定索引處的資料，結果是顯示「47 6f e8 aa 9e e8 a8 80 」。</p>
<p>這個位元組序列是怎麼決定的？當你寫下 <code>"Go語言"</code>，你的 .go 原始碼檔案是什麼編碼呢？是的！UTF-8，Go 就是從這當中取得 <code>"Go語言"</code> 位元組序列，每個位元組就是 UTF-8 的一個碼元（code unit）。</p>
<p>雖說字串是唯讀的位元組片段，不過，實際的位元組是隱藏在字串底層，如果你想取得，必須轉為 <code>[]byte</code>，例如：</p>
<pre><code class="language-prettyprint">package main

import "fmt"

func main() {
    text1 := "Go語言"
    bs := []byte(text1)
    bs[0] = 103
    text2 := string(bs)
    fmt.Println(text1) // Go語言
    fmt.Println(text2) // go語言
}
</code></pre>
<p>注意，你不是真的取得字串底層的位元組資料，只是取得複本，因此，在範例中可以看到，雖然對 <code>text2</code> 的位元組做了修改，<code>text1</code> 是不受影響的，記得，字串是唯讀的，一旦建立，沒有方式可以改變其內容。</p>
<h1 id="string-與索引"><a class="header" href="#string-與索引">string 與索引</a></h1>
<p>實際上，Go 的字串支援片段操作，slice 操作時的索引是針對位元組，然而，傳回的型態還是 <code>string</code>，例如，<code>"Go語言"[0:2]</code>，傳回 <code>"Go"</code>，因為指定要切割出索引 0 開始，索引 2 結束（但不包括 2）的部份，也就是 47 與 6f 這兩個位元組，但是以 <code>string</code> 傳回。</p>
<p>那麼，如果是 <code>"Go語言"[2:3]</code> 呢？嗯，傳回的字串是 <code>"\xe8"</code>！這是什麼？事實上，Go 中的字串可以是任意位元組片段，因此，你可以如下定義字串：</p>
<pre><code class="language-prettyprint">package main

import "fmt"

func main() {
    text := "\x47\x6f\xe8\xaa\x9e\xe8\xa8\x80"
    fmt.Println(text)  // Go語言
}
</code></pre>
<p>片段操作時，如果省略冒號之後的數字，則預設取得至字串尾端的子字串，例如 <code>"Go語言"[3:]</code> 會傳回 <code>"\xaa\x9e\xe8\xa8\x80"</code> 的字串，如果省略冒號之前的數字，預設從索引 0 開始，例如 <code>"Go語言"[:2]</code> 會取得 <code>"Go"</code> 的字串，也就是 <code>"\x47\x6f"</code> 的字串，如果是 <code>"Go語言"[:]</code>，那麼就是取得全部字串內容了。</p>
<p><a href="https://golang.org/pkg/strings/"><code>strings</code> 套件</a> 中有不少字串可用的方法，想做字串操作時，可以多加利用，不過要看清楚是針對什麼在操作。例如 <code>strings.Index</code>：</p>
<pre><code class="language-prettyprint">package main

import "fmt"
import "strings"

func main() {
    text := "Go語言"
    fmt.Printf("%d\n", strings.Index(text, "言"))  // 5
}
</code></pre>
<p>傳回的索引值是 5 而不是 3，這是因為 <code>"言"</code> 的第一個位元組，是在 <code>"Go語言"</code> UTF-8 編碼後的位元組組成中第 5 個索引位置。</p>
<p>問題來了，如果對於 <code>"Go語言"</code>，想逐一取得 <code>'G'</code>、<code>'o'</code>、<code>'語'</code>、<code>'言'</code> 該怎麼辦？當然不能用 <code>text[n]</code>，這只會取得第 n 個位元組，可以將字串型態轉換為 <code>[]rune</code> ：</p>
<pre><code class="language-prettyprint">package main

import "fmt"

func main() {
    text := "Go語言"
    cs := []rune(text)
    fmt.Printf("%c\n", cs[2]) // 語
    fmt.Println(len(cs))      // 4
}
</code></pre>
<p>字串型態轉換為 <code>[]rune</code> 時，會將 UTF-8 編碼的位元組，轉換為 Unicode 碼點，在這個例子中可以看到，<code>cs[2]</code> 確實地取得了第三個文字「語」，而 <code>len</code> 也確實取得數量 4。</p>
<p>如〈<a href="http://openhome.cc/Gossip/Go/PreDeclaredType.html">認識預定義型態</a>〉中談過的，在 Go 中並沒有字元對應的型態，只有碼點的概念，<code>rune</code> 為 <code>int32</code> 的別名，可用來儲存 Unicode 碼點（code point），如果使用 <code>fmt.Printf("%d\n", cs[2])</code>，會顯示 35486，這就是「語」的 Unicode 碼點，35486 的 16 進位表示是 8a9e，因此，如果你寫 <code>'\u8a9e'</code>，也會得到一個 <code>rune</code> 代表著「語」，<code>fmt.Printf("%c", '\u8a9e')</code> 也會顯示「語」，當然，直接寫 <code>'語'</code> 也是可以得到一個 <code>rune</code>。</p>
<p>想從 <code>rune</code> 得到一個 <code>string</code>，可以直接寫 <code>string('語')</code> 就可以了。如果想以 <code>rune</code> 為單位來走訪字串，而不是以位元組走訪，可以使用 <code>for range</code>，例如：</p>
<pre><code class="language-prettyprint">package main

import "fmt"

func main() {
    text := "Go語言"
    for index, runeValue := range text {
        fmt.Printf("%#U 位元起始位置 %d\n", runeValue, index)
    }
}
</code></pre>
<p>可以看到，<code>for range</code> 可以同時取得每個 <code>rune</code> 在字串中的位元起始位置，以及 <code>rune</code> 值，<code>%U</code> 可以用 16 進位顯示 <code>rune</code>，如果是 <code>%#U</code>，還會一併顯示碼點的列印形式。</p>
<p>這個程式的執行結果會顯示：</p>
<pre><code class="language-prettyprint">U+0047 'G' 位元起始位置 0
U+006F 'o' 位元起始位置 1
U+8A9E '語' 位元起始位置 2
U+8A00 '言' 位元起始位置 5
</code></pre>
<p>總而言之，Go 的字串是由 UTF-8 編碼的位元組構成，在〈<a href="https://blog.golang.org/strings">Strings, bytes, runes and characters in Go</a>〉談到了這麼設計的理由是，「字元」的定義太模稜兩可了，Go 為了避免模稜兩可，就將字串定義為 UTF-8 編碼的位元組構成，而 <code>rune</code> 用於儲存碼點。</p>
<p>PS. 這大概也是為何，我會整理出〈<a href="http://openhome.cc/Gossip/Encoding/">亂碼 1/2</a>〉的原因 … XD</p>
<div class="ad336-280" style="text-align: center;">
</div>
<div class="recommend" style="text-align: center;">
<hr />
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><div id="main" role="main" style="height: auto !important;">
<div class="header">
<h1 id="身為複合值的陣列"><a class="header" href="#身為複合值的陣列">身為複合值的陣列</a></h1>
</div>
<p>在 Go 中，陣列的長度固定，是個複合值，元素的型態及個數決定了陣列的型態，在記憶體中使用連續空間配置。</p>
<h1 id="建立與存取陣列"><a class="header" href="#建立與存取陣列">建立與存取陣列</a></h1>
<p>建立陣列的方式是 <code>[n]type</code>，其中 <code>n</code> 為陣列的元素數量，<code>type</code> 是元素的型態。例如：</p>
<pre><code class="language-prettyprint">package main

import "fmt"

func main() {
    var scores [10]int
    scores[0] = 90
    scores[1] = 89
    fmt.Println(scores)      // [90 89 0 0 0 0 0 0 0 0]
    fmt.Println(len(scores)) // 10
}
</code></pre>
<p>在上面的程式中，建立了具有 10 個元素的陣列，可以用來儲存 <code>int</code> 型態的值，可透過 <code>scores</code> 變數指定索引來存取元素，<code>scores</code> 變數的型態為 <code>[10]int</code>，記得，長度也是陣列的型態的一部份，若一個陣列為 <code>[10]int</code>，而另一個陣列為 <code>[5]int</code>，這兩個陣列會是不同的型態，像上頭這樣宣告陣列，預設每個元素都會初始為 0。</p>
<p>陣列使用索引存取，如同其他語言的慣例，索引從 0 開始，<code>len</code> 函式可以取得陣列的長度，如果想在建立陣列時指定初始，可以如下：</p>
<pre><code class="language-prettyprint">package main

import "fmt"

func main() {
    arr1 := [3]int{1, 2, 3}
    arr2 := [5]int{1, 2, 3}
    arr3 := [...]int{1, 2, 3, 4, 5}
    fmt.Println(arr1) // [1 2 3]
    fmt.Println(arr2) // [1 2 3 0 0]
    fmt.Println(arr3) // [1 2 3 4 5]
}
</code></pre>
<p>在上頭可以看到，如果宣告的元素數量不足 <code>[]</code> 中指定的數量，那麼會自動給予初值，也可以使用 <code>...</code>，或者只寫 <code>[]</code>，讓編譯器自動判斷數量，如果宣告的元素數量超過 <code>[]</code> 中指定的數量，那麼會有 out of bounds 的編譯錯誤。</p>
<h1 id="陣列指定與比較"><a class="header" href="#陣列指定與比較">陣列指定與比較</a></h1>
<p>在 Go 中，陣列指定會逐一複製值，例如：</p>
<pre><code class="language-prettyprint">package main

import "fmt"

func main() {
    arr1 := [...]int{1, 2, 3}
    arr2 := arr1
    fmt.Println(arr1) // [1 2 3]
    fmt.Println(arr2) // [1 2 3]
    arr1[0] = 10
    fmt.Println(arr1) // [10 2 3]
    fmt.Println(arr2) // [1 2 3]
}
</code></pre>
<p>在呼叫函式時若傳遞陣列給參數，或者是傳回陣列，也是做複製的動作。陣列可以使用 <code>==</code> 與 <code>!=</code> 進行比較，由於長度也是陣列型態的一部份，因此，只要長度與元素型態相同的陣列才可以做比較，如果將 <code>[3]int</code> 與 <code>[5]int</code> 做比較，會發生 mismatched types 編譯錯誤，同樣的，指定陣列給另一陣列時，也必須是相同型態的陣列。</p>
<h1 id="巢狀陣列"><a class="header" href="#巢狀陣列">巢狀陣列</a></h1>
<p>Go 的陣列是線性的，如果想模擬多維，可以使用巢狀陣列。例如，建立一個二維陣列：</p>
<pre><code class="language-prettyprint">package main

import "fmt"

func main() {
    var arr [2][3]int
    fmt.Println(arr)   // [[0 0 0] [0 0 0]]
}
</code></pre>
<p>顯然地，第一個 <code>[]</code> 中數字指定了陣列中會有兩個 <code>[3]int</code> 陣列，因此，若要同時宣告陣列中的元素，可以如下：</p>
<pre><code class="language-prettyprint">package main

import "fmt"

func change(arr [3]int) [3]int {
    arr[0] = 10
    return arr
}

func main() {
    arr1 := [2][3]int{[3]int{1, 2, 3}, [3]int{4, 5, 6}}
    fmt.Println(arr1) // [[1 2 3] [4 5 6]]

    arr2 := [...][3]int{[...]int{1, 2, 3}, [...]int{4, 5, 6}}
    fmt.Println(arr2) // [[1 2 3] [4 5 6]]

    arr3 := [2][3]int{{1, 2, 3}, {4, 5, 6}}
    fmt.Println(arr3) // [[1 2 3] [4 5 6]]

    arr4 := [...][3]int{{1, 2, 3}, {4, 5, 6}}
    fmt.Println(arr4) // [[1 2 3] [4 5 6]]
}
</code></pre>
<p>上頭一口氣示範了幾種巢狀陣列的宣告方式，基本上後兩種應該是比較容易撰寫的，由於陣列的長度是型態的一部份，必須在宣告時指定，因此，就二維陣列來說，一定都是方陣。</p>
<h1 id="走訪陣列"><a class="header" href="#走訪陣列">走訪陣列</a></h1>
<p>想要逐一走訪陣列的話，基本上可以使用 <code>for</code> 迴圈，例如：</p>
<pre><code class="language-prettyprint">package main

import "fmt"

func main() {
    arr := [...]int{1, 2, 3}
    for i := 0; i &lt; len(arr); i++ {
        fmt.Printf("%d\n", arr[i])
    }
}
</code></pre>
<p>另一個方式是使用 <code>for range</code>：</p>
<pre><code class="language-prettyprint">package main

import "fmt"

func main() {
    arr := [...]int{1, 2, 3}
    for index, element := range arr {
        fmt.Printf("%d: %d\n", index, element)
    }
}
</code></pre>
<p>在不需要索引的情況下，可以使用 <code>_</code> 忽略傳回的索引值，例如：</p>
<pre><code class="language-prettyprint">package main

import "fmt"

func main() {
    arr := [...]int{1, 2, 3}
    for _, element := range arr {
        fmt.Printf("%d\n", element)
    }
}
</code></pre>
<div class="ad336-280" style="text-align: center;">
</div>
<div class="recommend" style="text-align: center;">
<hr />
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><div id="main" role="main" style="height: auto !important;">
<div class="header">
<h1 id="底層為陣列的-slice"><a class="header" href="#底層為陣列的-slice">底層為陣列的 slice</a></h1>
</div>
<p>在〈<a href="http://openhome.cc/Gossip/Go/Array.html">身為複合值的陣列</a>〉中看過陣列，有的場合需要陣列，然而，若只想處理陣列中某片區域，或者以更高階的觀點看待一片資料（而不是從固定長度的陣列觀點），那麼可以使用 slice。</p>
<h1 id="建立一個-slice"><a class="header" href="#建立一個-slice">建立一個 slice</a></h1>
<p>如果需要一個 slice，可以使用 <code>make</code> 函式，舉個例子來說，可以如下建立一個長度與容量皆為 5 的 slice，並傳回 <code>slice</code> 的參考，型態為 <code>[]int</code>：</p>
<pre><code class="language-prettyprint">package main

import "fmt"

func main() {
    s1 := make([]int, 5)
    s2 := s1
    fmt.Println(s1) // [0 0 0 0 0]
    fmt.Println(s2) // [0 0 0 0 0]
    s1[0] = 1
    fmt.Println(s1) // [1 0 0 0 0]
    fmt.Println(s2) // [1 0 0 0 0]
    s2[1] = 2
    fmt.Println(s1) // [1 2 0 0 0]
    fmt.Println(s2) // [1 2 0 0 0]
}
</code></pre>
<div class="google-auto-placed" style="width: 100%; height: auto; clear: both; text-align: center;">
</div>
<p>如上所示，<code>s1</code>、<code>s2</code> 會是個參考（Reference），型態是 <code>[]int</code>，參考至同一個 slice 實例。</p>
<p>透過 <code>s1</code> 或 <code>s2</code> 操作時，操作的對象是變數參考之實例，就底層來說，<code>make([]int, 5)</code> 在記憶體某位置建立了 slice 實例，而 <code>s1</code> 儲存了該位置，如果改變了 <code>s1</code> 儲存的位址值，那透過 <code>s1</code> 操作時，就會是另一個 slice 實例了。</p>
<p>將變數的參考對象指定給另一個變數時，底層是將儲存的位址值指定給該變數，在上例中，<code>s2 := s1</code>，就是將 <code>s1</code> 儲存的位址值，指定給 <code>s2</code>，因此透過 <code>s2</code> 操作的對象，與 <code>s1</code> 操作的對象是相同的，透過其中一個名稱來改變 slice 的元素內容，透過另一個名稱取得 slice 的元素值，就會是改變後的值。</p>
<p>上例也可以寫為：</p>
<pre><code class="language-prettyprint">package main

import "fmt"

func main() {
    var s1 []int = make([]int, 5)
    var s2 []int    // s2 這時是 nil
    s2 = s1         // 將 s1 的參考對象指定給 s2
    fmt.Println(s1) // [0 0 0 0 0]
    fmt.Println(s2) // [0 0 0 0 0]
    s1[0] = 1
    fmt.Println(s1) // [1 0 0 0 0]
    fmt.Println(s2) // [1 0 0 0 0]
    s2[1] = 2
    fmt.Println(s1) // [1 2 0 0 0]
    fmt.Println(s2) // [1 2 0 0 0]
}
</code></pre>
<div class="google-auto-placed" style="width: 100%; height: auto; clear: both; text-align: center;">
</div>
<p>在 Go 中，參考的預設零值都是 <code>nil</code>。slice 無法進行 <code>==</code> 比較，slice 唯一可以用 <code>==</code> 比較的對象是 <code>nil</code>，儲存 slice 參考的變數也無法進行 <code>==</code> 比較，若真想知道兩個變數參考的是否同一 slice，可以如下透過<a href="Reflect.html">反射機制</a>來得知：</p>
<pre><code class="language-prettyprint">package main

import (
    "fmt"
    "reflect"
)

func main() {
    s1 := make([]int, 5)
    s2 := s1
    fmt.Println(reflect.ValueOf(s1).Pointer() == reflect.ValueOf(s2).Pointer())
}
</code></pre>
<div class="google-auto-placed" style="width: 100%; height: auto; clear: both; text-align: center;">
</div>
<p>若事先知道 slice 的值，也可以使用 slice 字面常量：</p>
<pre><code class="language-prettyprint">package main

import (
    "fmt"
    "reflect"
)

func main() {
    s1 := []int{1, 2, 3, 4, 5}
    a1 := [...]int{1, 2, 3, 4, 5}
    fmt.Println(reflect.TypeOf(s1)) // []int
    fmt.Println(reflect.TypeOf(a1)) // [5]int
}
</code></pre>
<p>注意到，建立 slice 時，方括號中是沒有 <code>...</code> 的，如果方括號中有 <code>...</code>，那會是個陣列，而不是個 slice，如上可看到的，<code>s1</code> 的型態會是 <code>[]int</code>，然而，<code>a1</code> 的型態會是 <code>[5]int</code>，<code>s1</code> 是個參考，可以指向某個 slice 實例，<code>s1</code> 本身儲存的位址值可以改變，而 <code>a1</code> 本身就是陣列，從 <code>a1</code> 的位置開始，有連續 5 個 <code>int</code> 空間可用來儲存 <code>int</code> 值，<code>a1</code> 本身的位置是固定的，無法改變。</p>
<p>使用 slice 字面常量時，還可以初始特定索引處的值。例如：</p>
<pre><code class="language-prettyprint">slice := []int{10, 20, 30, 10: 100, 20: 200}
// 顯示 [10 20 30 0 0 0 0 0 0 0 100 0 0 0 0 0 0 0 0 0 200]
fmt.Println(slice)
</code></pre>
<div class="google-auto-placed" style="width: 100%; height: auto; clear: both; text-align: center;">
</div>
<p>在上面的例子中，索引 0、1、2 被初始為 10、20、30，之後指定索引 10 為 100，索引 20 為 200，其餘未指定處初始為 <code>int</code> 零值 0。</p>
<h1 id="從陣列或-slice-建立-slice"><a class="header" href="#從陣列或-slice-建立-slice">從陣列或 slice 建立 slice</a></h1>
<p>如果有個現成的陣列，可以從陣列中建立 slice，例如，從陣列的索引 1 到 4（不包括）建立一個 slice 的話，可以如下：</p>
<pre><code class="language-prettyprint">package main

import (
    "fmt"
    "reflect"
)

func main() {
    arr := [...]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
    slice := arr[1:4]
    fmt.Println(reflect.TypeOf(arr))   // [10]int
    fmt.Println(reflect.TypeOf(slice)) // []int
    fmt.Println(len(slice))            // 3
    fmt.Println(cap(slice))            // 9

    fmt.Println(slice)   // [2 3 4]
    fmt.Println(arr)     // [1 2 3 4 5 6 7 8 9 10]

    slice[0] = 20
    fmt.Println(slice)   // [20 3 4]
    fmt.Println(arr)     // [1 20 3 4 5 6 7 8 9 10]
}
</code></pre>
<p>在這邊可以看到，slice 的長度可以使用 <code>len</code> 得知，而容量可以使用 <code>cap</code> 函式得知，如果從陣列中切出 slice，長度是 slice 可參考的元素長度，而容量預設為從 slice 索引 0 處起算的底層陣列元素長度，如圖所示：</p>
<div class="pure-g">
<div class="pure-u-1">
<img src="images/Slice-1.JPG" class="pure-img-responsive" alt="slice 與陣列" />
</div>
</div>
<p>是的！slice 底層實際上還是個陣列，若兩個 slice 底層是共用同一個陣列，從一個 slice 操作，另一個 slice 取得的值也就會反映變化，也因此在上面的例子中，你透過 <code>slice[0]</code> 設定值為 20，底層的陣列也會因而反映出變化，透過 slice 指定索引取得元素值時，不能超出 slice 的長度，不然會出現 index out of range 的錯誤。</p>
<p>注意，單是宣告 <code>var slice []int</code> 的話，<code>slice</code> 預設零值會是 <code>nil</code>，也就是相當於 <code>var slice []int = nil</code>，也就是 <code>slice</code> 參考至 <code>nil</code>，此時 <code>len(slice)</code> 與 <code>cap(slice)</code> 的結果都會是 0，<code>fmt.Println</code> 的顯示會是 []，<code>==</code> 用於 slice 時，唯一能用來比較的就是 <code>nil</code>。</p>
<p>方才使用 <code>make([]int, 5)</code> 函式建立 slice 時，只指定了長度為 5，而容量就預設與長度相同，實際上，可以分別指定容量與長度，例如：</p>
<pre><code class="language-prettyprint">package main

import "fmt"

func main() {
    slice := make([]int, 5, 10)
    fmt.Println(slice)       // [0 0 0 0 0]
    fmt.Println(len(slice))  // 5
    fmt.Println(cap(slice))  // 10
}
</code></pre>
<p>指定索引從陣列中產生 slice時，若省略冒號之後的數字，則建立的 slice，預設可取得至陣列尾端的元素，也就是長度將等於容量，例如，若 <code>arr := [...]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}</code>，那麼 <code>arr[3:]</code> 的話，取得的 slice 可以存取的元素為 {4, 5, 6, 7, 8, 9, 10}，長度與容量皆為 7；如果省略冒號之前的數字，預設從索引 0 開始，例如 <code>arr[:2]</code> 會取得 {1, 2}，長度為 2，容量為 10；如果是 <code>arr[:]</code>，那麼就是取得全部陣列內容了，長度與容量皆為 10。</p>
<p>Go 1.2 開始，可以在 <code>[]</code> 中指定三個數字，以冒號區隔，第三個數字指定的是 slice 以原陣列哪個索引作為邊界。例如：</p>
<pre><code class="language-prettyprint">package main

import "fmt"

func main() {
    arr := [...]int{1, 2, 3, 4, 5}
    slice1 := arr[0:2:4]
    fmt.Println(slice1)      // [1 2]
    fmt.Println(len(slice1)) // 2
    fmt.Println(cap(slice1)) // 4
}
</code></pre>
<p>第三個數字指定的索引不能超過陣列邊界，不然會發生 invalid slice index 的錯誤。</p>
<p>也可以從 slice 中產生 slice，產生的 slice 底層還是同一個陣列。例如：</p>
<pre><code class="language-prettyprint">package main

import "fmt"

func main() {
    arr := [...]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
    slice1 := arr[:5]
    slice2 := slice1[:3]

    fmt.Println(slice1) // [1 2 3 4 5]
    fmt.Println(slice2) // [1 2 3]

    slice2[0] = 10
    fmt.Println(slice1) // [10 2 3 4 5]
    fmt.Println(slice2) // [10 2 3]
    fmt.Println(arr)    // [10 2 3 4 5 6 7 8 9 10]
}
</code></pre>
<h1 id="slice-的-append"><a class="header" href="#slice-的-append">slice 的 append</a></h1>
<p>可以使用 <code>append</code> 對 slice 附加元素，這會傳回一個 slice 的參考：</p>
<pre><code class="language-prettyprint">package main

import "fmt"

func main() {
    arr := [...]int{1, 2, 3, 4, 5}
    slice1 := arr[:2]
    fmt.Println(slice1)      // [1 2]
    fmt.Println(len(slice1)) // 2
    fmt.Println(cap(slice1)) // 5

    slice2 := append(slice1, 6)
    fmt.Println(slice2)      // [1 2 6]
    fmt.Println(len(slice2)) // 3
    fmt.Println(cap(slice2)) // 5

    slice2[0] = 10
    fmt.Println(slice1) // [10 2]
    fmt.Println(slice2) // [10 2 6]
    fmt.Println(arr)    // [10 2 6 4 5]
}
</code></pre>
<p>只要附加的元素沒有超出 slice 的容量，傳回的 slice 參考就會是相同的，底層也是同一陣列，因此，改變了 <code>slice2[0]</code> 的值，<code>slice1</code>、<code>arr</code> 取得結果都有了變化。</p>
<p>如果 <code>append</code> 的時候，附加元素超出了 slice 的容量，那麼底層會建立一個新的陣列，容量為原 slice 容量的兩倍加 2，接著將舊陣列內容複製到新陣列，然後將指定的值附加上去，<code>append</code> 的結果也會傳回新的 slice 參考。例如：</p>
<pre><code class="language-prettyprint">package main

import "fmt"

func main() {
    arr := [...]int{1, 2, 3, 4, 5}
    slice1 := arr[:]
    fmt.Println(slice1)      // [1 2 3 4 5]
    fmt.Println(len(slice1)) // 5
    fmt.Println(cap(slice1)) // 5

    slice2 := append(slice1, 6)
    fmt.Println(slice2)      // [1 2 3 4 5 6]
    fmt.Println(len(slice2)) // 6
    fmt.Println(cap(slice2)) // 12

    slice2[0] = 10
    fmt.Println(slice1) // [1 2 3 4 5]
    fmt.Println(slice2) // [10 2 3 4 5 6]
    fmt.Println(arr)    // [1 2 3 4 5]
}
</code></pre>
<p>在上面的例子中，由於 <code>slice2</code> 底層的陣列，與 <code>slice1</code> 無關了，因此，透過 <code>slice2[0]</code> 修改了值，並不會影響到透過 <code>slice1</code> 或 <code>arr</code> 取得的值。</p>
<p>如果想用 <code>append</code> 來直接附加另一個 slice，可以使用 <code>...</code>，將另一個 slice 擴展為一列引數，例如：</p>
<pre><code class="language-prettyprint">package main

import "fmt"

func main() {
    slice1 := []int{1, 2, 3}
    slice2 := []int{4, 5, 6}
    fmt.Println(append(slice1, slice2...))  // [1 2 3 4 5 6]
}
</code></pre>
<h1 id="slice-的-copy"><a class="header" href="#slice-的-copy">slice 的 copy</a></h1>
<p>可以使用 <code>copy</code> 函式，將一個 slice 的內容，複製至另一個 slice：</p>
<pre><code class="language-prettyprint">package main

import "fmt"

func main() {
    src := []int{1, 2, 3, 4, 5}
    dest := make([]int, len(src), (cap(src)+1)*2)
    fmt.Println(copy(dest, src)) // 5
    fmt.Println(src)             // [1 2 3 4 5]
    fmt.Println(dest)            // [1 2 3 4 5]

    src[0] = 10
    fmt.Println(src)  // [10 2 3 4 5]
    fmt.Println(dest) // [1 2 3 4 5]
}
</code></pre>
<p>複製時，目的 slice 的容量必須足夠，否則會發生 cap out of range 的錯誤，<code>copy</code> 函式若執行成功，會傳回複製的元素個數。</p>
<p>先前提到，可以從 slice 中產生 slice，然而，由於從 slice 中產生 slice，底層仍會是同一個陣列，因此，要小心一些應用場合，對於一個很大的陣列，若不斷地切出新的 slice，底層參考的陣列還是那麼大，想避免這類問題，應自行使用 <code>make</code> 建立適當大小的 slice，然後從舊 slice 使用 <code>copy</code> 複製元素值，或者使用 <code>append</code>，將舊 slice 的內容附加至新 slice，以避免這類問題。</p>
<div class="ad336-280" style="text-align: center;">
</div>
<div class="recommend" style="text-align: center;">
<hr />
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><div id="main" role="main" style="height: auto !important;">
<div class="header">
<h1 id="成對鍵值的-map"><a class="header" href="#成對鍵值的-map">成對鍵值的 map</a></h1>
</div>
<p>許多語言中都會有的成對鍵值資料結構，在 Go 中是以內建型態 <code>map</code> 來實作，格式為 <code>map[keyType]valueType</code>。</p>
<h1 id="建立與初始-map"><a class="header" href="#建立與初始-map">建立與初始 map</a></h1>
<p>想要建立例一個 <code>map</code> 實例，但尚無任何鍵值對，可以使用 <code>make</code> 函式，例如：</p>
<pre><code class="language-prettyprint">package main

import "fmt"

func main() {
    passwords := make(map[string]int)
    fmt.Println(passwords)      // map[]
    fmt.Println(len(passwords)) // 0

    passwords["caterpillar"] = 123456
    passwords["monica"] = 54321
    fmt.Println(passwords)                // map[caterpillar:123456 monica:54321]
    fmt.Println(len(passwords))           // 2
    fmt.Println(passwords["caterpillar"]) // 123456
    fmt.Println(passwords["monica"])      // 54321
}
</code></pre>
<div class="google-auto-placed" style="width: 100%; height: auto; clear: both; text-align: center;">
</div>
<p>在上例中，<code>passwords</code> 是個參考，指向 <code>make(map[string]int)</code> 建立的 map 實例。</p>
<p>類似一些語言（例如 Python），要設定一個鍵值對應時，使用 <code>[]</code> 與 <code>=</code> 指定，要取得鍵對應的值時，使用 <code>[]</code> 指定鍵，這會傳回對應的值，想知道 <code>map</code> 中的鍵數，可以使用 <code>len</code> 函式。</p>
<p>要注意的是，可用來做為鍵的值，必須是 <a href="https://blog.golang.org/go-maps-in-action">comparable</a>，就目前來說，你要先知道的 comparable 型態有布林、數字、字串、指標（pointer）、channel、interface、struct，或者含有這這些型態的陣列，這些是都可以使用 <code>==</code> 來比較的值；而 slice、map 與函式，就不能用來做為鍵。</p>
<p>如果已知 map 中會有的鍵值對，則可以如下建立 map：</p>
<pre><code class="language-prettyprint">package main

import "fmt"

func main() {
    passwords := map[string]int{
        "caterpillar": 123456,
        "monica":      54321,
    }

    fmt.Println(passwords)                // map[monica:54321 caterpillar:123456]
    fmt.Println(len(passwords))           // 2
    fmt.Println(passwords["caterpillar"]) // 12345
    fmt.Println(passwords["monica"])      // 54321
}
</code></pre>
<p>如果 <code>passwords</code> 建立時，最後一個鍵值項目後不換行，那麼最後一個逗號就不需要，例如：</p>
<pre><code class="language-prettyprint">passwords := map[string]int {"caterpillar" : 123456, "monica" : 54321}
</code></pre>
<div class="google-auto-placed" style="width: 100%; height: auto; clear: both; text-align: center;">
</div>
<p>實際上，你也可以寫 <code>passwords := map[string]int {}</code>，來建立一個沒有任何鍵值對的 <code>map</code>，這相當於寫 <code>passwords := make(map[string]int)</code>，不過，若是 <code>var passwords map[string]int</code> 的話，只是建立一個參考名稱 <code>passwords</code>，預設零值是 <code>nil</code>，也就是相當於 <code>var passwords map[string]int = nil</code> 的意思。</p>
<p>也就是說，<code>var passwords map[string]int</code> 宣告了一個參考型態，兩個 <code>map</code> 型態的名稱，可以指向同一個 <code>map</code> 實例，透過其中一個名稱來改變 <code>map</code> 內容，從另一個名稱就可以獲得對應的修改：</p>
<pre><code class="language-prettyprint">package main

import "fmt"

func main() {
    passwds1 := map[string]int{"caterpillar": 123456}
    passwds2 := passwds1

    fmt.Println(passwds1) // map[caterpillar:123456]

    passwds2["monica"] = 54321
    fmt.Println(passwds1) // map[monica:54321 caterpillar:123456]
}
</code></pre>
<h1 id="鍵值存取刪除"><a class="header" href="#鍵值存取刪除">鍵值存取、刪除</a></h1>
<p>如方才所看到的，要設定一個鍵值對應時，使用 <code>[]</code> 與 <code>=</code> 指定，要取得鍵對應的值時，使用 <code>[]</code> 指定鍵，這會傳回對應的值，如果指定的鍵不存在，那麼會傳回值型態對應的零值，例如，若 <code>passwords := map[string]int {"caterpillar" : 123456}</code>，那麼 <code>passwords["monica"]</code> 會傳回 0。</p>
<div class="google-auto-placed" style="width: 100%; height: auto; clear: both; text-align: center;">
</div>
<p>不過，更精確地說，使用 <code>mapName[key]</code> 時，會傳回兩個值（Go 中允許同時傳回多值），第一個是鍵對應的值，若沒有該鍵就傳回值型態的零值，第二個是布林值，指出鍵是否存在。例如：</p>
<pre><code class="language-prettyprint">package main

import "fmt"

func main() {
    passwds := map[string]int{"caterpillar": 123456}

    v, exists := passwds["monica"]
    fmt.Printf("%d %t\n", v, exists) // 0 false

    passwds["monica"] = 54321
    v, exists = passwds["monica"]
    fmt.Printf("%d %t\n", v, exists) // 54321 true
}
</code></pre>
<p>因此，若只是單純想測試鍵是否存在，只要用底線 <code>_</code> 忽略傳回的值就可以了，例如：</p>
<pre><code class="language-prettyprint">package main

import "fmt"

func main() {
    passwds := map[string]int{"caterpillar": 123456}
    name := "caterpillar"
    _, exists := passwds[name]
    if exists {
        fmt.Printf("%s's password is %d\n", name, passwds[name])
    } else {
        fmt.Printf("No password for %s\n", name)
    }
}
</code></pre>
<div class="google-auto-placed" style="width: 100%; height: auto; clear: both; text-align: center;">
</div>
<p><code>exists</code> 的指定與 <code>if</code> 的判斷也可以寫在同一行：</p>
<pre><code class="language-prettyprint">if _, exists := passwds[name]; exists {
    fmt.Printf("%s's password is %d\n", name, passwds[name])
} else {
    fmt.Printf("No password for %s\n", name)
}
</code></pre>
<p>如果想刪除某個鍵值，可以使用 <code>delete</code> 函式，例如 <code>delete(passwds, "caterpillar")</code>。</p>
<h1 id="迭代鍵值"><a class="header" href="#迭代鍵值">迭代鍵值</a></h1>
<p>如果要迭代 <code>map</code> 的鍵值，可以使用 <code>for range</code>，例如：</p>
<pre><code class="language-prettyprint">package main

import "fmt"

func main() {
    passwords := map[string]int{
        "caterpillar": 123456,
        "monica":      54321,
    }

    for name, passwd := range passwords {
        fmt.Printf("%s : %d\n", name, passwd)
    }
}
</code></pre>
<p>如果只是想迭代 <code>map</code> 的鍵，可以如下：</p>
<pre><code class="language-prettyprint">package main

import "fmt"

func main() {
    passwords := map[string]int{
        "caterpillar": 123456,
        "monica":      54321,
    }

    for name := range passwords {
        fmt.Printf("%s\n", name)
    }
}
</code></pre>
<p>如果只想迭代 <code>map</code> 的值，可以如下：</p>
<pre><code class="language-prettyprint">package main

import "fmt"

func main() {
    passwords := map[string]int{
        "caterpillar": 123456,
        "monica":      54321,
    }

    for _, passwd := range passwords {
        fmt.Printf("%d\n", passwd)
    }
}
</code></pre>
<p>如果想取得 <code>map</code> 中的鍵清單或者是值清單，方式之一是使用 slice 進行收集，例如：</p>
<pre><code class="language-prettyprint">package main

import "fmt"

func keys(m map[string]int) []string {
    ks := make([]string, 0, len(m))
    for k := range m {
        ks = append(ks, k)
    }
    return ks
}

func values(m map[string]int) []int {
    vs := make([]int, 0, len(m))
    for _, v := range m {
        vs = append(vs, v)
    }
    return vs
}

func main() {
    passwords := map[string]int{
        "caterpillar": 123456,
        "monica":      54321,
    }

    fmt.Println(keys(passwords))   // [caterpillar monica]
    fmt.Println(values(passwords)) // [123456 54321]
}
</code></pre>
<p>Go 的 <code>map</code> 在迭代時沒有一定的順序，如果想要有排序結果，必須自行處理，例如，針對鍵排序來進行迭代：</p>
<pre><code class="language-prettyprint">package main

import "sort"
import "fmt"

func main() {
    passwords := map[string]int{
        "caterpillar": 123456,
        "monica":      54321,
        "hamimi":      13579,
    }

    keys := make([]string, 0, len(passwords))
    for key := range passwords {
        keys = append(keys, key)
    }
    sort.Strings(keys)

    for _, key := range keys {
        fmt.Printf("%s : %d\n", key, passwords[key])
    }
}
</code></pre>
<div class="ad336-280" style="text-align: center;">
</div>
<div class="recommend" style="text-align: center;">
<hr />
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><div id="main" role="main" style="height: auto !important;">
<div class="header">
<h1 id="運算子"><a class="header" href="#運算子">運算子</a></h1>
</div>
<p>Go 語言中的運算子，大致上與 C 語系的語言中提供的運算子差不多，其中 <code>&amp;</code>、<code>*</code> 也用來作為指標（Pointer）運算子。</p>
<h1 id="算術運算子"><a class="header" href="#算術運算子">算術運算子</a></h1>
<p>算術運算子作用於數值，產生與第一個運算元相同型態的結果。<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code> 四個運算子，可用於整數、浮點數與複數；<code>+</code> 也用於字串串接；<code>%</code> 餘除運算子，只用於整數，<code>&amp;</code>、<code>|</code>、<code>^</code>、<code>&amp;^</code> 位元運算子只用於整數，<code>&lt;&lt;</code>、<code>&gt;&gt;</code> 位移運算子只用於整數。</p>
<p><code>+</code>、<code>-</code>、<code>*</code>、<code>/</code> 使用上應該沒什麼問題，主要就是注意運算的順序是先乘除後加減，必要時使用括號讓順序清楚，例如：</p>
<pre><code class="language-prettyprint">package main

import "fmt"

func main() {
    fmt.Println(1 + 2*3)         // 7
    fmt.Println(2 + 2 + 8/4)     // 6
    fmt.Println((2 + 2 + 8) / 4) // 3
    fmt.Println(10 % 3)          // 1
}
</code></pre>
<p><code>%</code>運算子計算的結果是除法後的餘數，例如上頭 <code>10 % 3</code> 會得到餘數 1。</p>
<div class="google-auto-placed" style="width: 100%; height: auto; clear: both; text-align: center;">
</div>
<p>對於遞增與遞減 1 的操作，Go 可以使用 <code>++</code> 與 <code>--</code> 的操作，不過，<code>++</code> 與 <code>--</code> 只能置於變數後方，而且是個陳述，因此，對於 <code>i := 1</code>，你可以在一行陳述中寫 <code>i++</code> 或 <code>i--</code>，不過，不能寫 <code>fmt.Println(i++)</code>，這樣就能避免是要先傳回 <code>i</code> 值再遞增 <code>i</code>，還是先遞增 <code>i</code> 再傳回 1 的問題。</p>
<p>在二進位運算上有 AND、OR、XOR 等運算，底下是 Go 中的一些例子：</p>
<pre><code class="language-prettyprint">package main

import "fmt"

func main() {
    fmt.Println("AND運算：")
    fmt.Printf("0 AND 0 %5d\n", 0&amp;1)
    fmt.Printf("0 AND 1 %5d\n", 0&amp;1)
    fmt.Printf("1 AND 0 %5d\n", 1&amp;0)
    fmt.Printf("1 AND 1 %5d\n", 1&amp;1)

    fmt.Println("\nOR運算：")
    fmt.Printf("0 OR 0 %6d\n", 0|0)
    fmt.Printf("0 OR 1 %6d\n", 0|1)
    fmt.Printf("1 OR 0 %6d\n", 1|0)
    fmt.Printf("1 OR 1 %6d\n", 1|1)

    fmt.Println("\nXOR運算：")
    fmt.Printf("0 XOR 0 %5d\n", 0^0)
    fmt.Printf("0 XOR 1 %5d\n", 0^1)
    fmt.Printf("1 XOR 0 %5d\n", 1^0)
    fmt.Printf("1 XOR 1 %5d\n", 1^1)

    fmt.Println("\nAND NOT運算：")
    fmt.Printf("0 AND NOT 0 %5d\n", 0&amp;^0)
    fmt.Printf("0 AND NOT 1 %5d\n", 0&amp;^1)
    fmt.Printf("1 AND NOT 0 %5d\n", 1&amp;^0)
    fmt.Printf("1 AND NOT 1 %5d\n", 1&amp;^1)
}
</code></pre>
<div class="google-auto-placed" style="width: 100%; height: auto; clear: both; text-align: center;">
</div>
<p>執行結果如下：</p>
<pre><code class="language-prettyprint">AND運算：
0 AND 0     0
0 AND 1     0
1 AND 0     0
1 AND 1     1

OR運算：
0 OR 0      0
0 OR 1      1
1 OR 0      1
1 OR 1      1

XOR運算：
0 XOR 0     0
0 XOR 1     1
1 XOR 0     1
1 XOR 1     0

AND NOT運算：
0 AND NOT 0     0
0 AND NOT 1     0
1 AND NOT 0     1
1 AND NOT 1     0
</code></pre>
<div class="google-auto-placed" style="width: 100%; height: auto; clear: both; text-align: center;">
</div>
<p>位元運算是逐位元運算，例如 10010001 與 01000001 作 AND 運算，是一個一個位元對應運算，答案就是 00000001。補數運算是將所有位元 0 變 1，1 變 0。例如 00000001 經補數運算就會變為 11111110。Go 的補數運算子是 <code>^</code>，例如：</p>
<pre><code class="language-prettyprint">package main

import "fmt"

func main() {
    number := 0
    fmt.Println(^number)  // -1
}
</code></pre>
<p>上面的程式片段會顯示 -1，因為 number 在記憶體中全部位元都是 0，經補數運算全部位元就都變成 1，這個數在電腦中用整數表示則是 -1。</p>
<p><code>&lt;&lt;</code> 左移運算子會將所有位元往左移指定位數，左邊被擠出去的位元會被丟棄，而右邊補上 0；<code>&gt;&gt;</code> 右移運算則是相反，會將所有位元往右移指定位數，右邊被擠出去的位元會被丟棄，至於最左邊補上原來的位元，如果左邊原來是 0 就補0，1 就補 1。</p>
<pre><code class="language-prettyprint">package main

import "fmt"

func main() {
    number := 1
    fmt.Printf("2 的 0 次方: %d\n", number)        // 1
    fmt.Printf("2 的 1 次方: %d\n", number &lt;&lt; 1)   // 2
    fmt.Printf("2 的 2 次方: %d\n", number &lt;&lt; 2)   // 4
    fmt.Printf("2 的 3 次方: %d\n", number &lt;&lt; 3)   // 8
}
</code></pre>
<div class="google-auto-placed" style="width: 100%; height: auto; clear: both; text-align: center;">
</div>
<p>實際來左移看看就知道為何可以如此作次方運算了：</p>
<pre><code class="language-prettyprint">00000001 -&gt; 1 
00000010 -&gt; 2 
00000100 -&gt; 4 
00001000 -&gt; 8
</code></pre>
<p>對於一個算術運算 <code>x = x op y</code>，可以寫成 <code>x op= y</code>，<code>op</code> 是指算術運算子，例如 <code>x = x + y</code>，可以寫成 <code>x += y</code>，這也就是所謂的指定運算子。</p>
<h1 id="比較運算"><a class="header" href="#比較運算">比較運算</a></h1>
<p>數學上有大於、等於、小於的比較運算，Go 中也提供了這些運算子，它們有大於（<code>&gt;</code>）、不小於（<code>&gt;=</code>）、小於（<code>&lt;</code>）、不大於（<code>&lt;=</code>）、等於（<code>==</code>）以及不等於（<code>!=</code>），比較條件成立時用 <code>true</code> 表示，比較條件不成立用 <code>false</code> 表示。以下程式片段示範了幾個比較運算的使用：</p>
<pre><code class="language-prettyprint">package main

import "fmt"

func main() {
    fmt.Printf("10 &gt;  5 結果 %t\n", 10 &gt; 5)   // true
    fmt.Printf("10 &gt;= 5 結果 %t\n", 10 &gt;= 5)  // true
    fmt.Printf("10 &lt;  5 結果 %t\n", 10 &lt; 5)   // false
    fmt.Printf("10 &lt;= 5 結果 %t\n", 10 &lt;= 5)  // false
    fmt.Printf("10 == 5 結果 %t\n", 10 == 5)  // false
    fmt.Printf("10 != 5 結果 %t\n", 10 != 5)  // true
}
</code></pre>
<p><code>==</code> 與 <code>!=</code> 只能用在 comparable 的運算元上，這有一套嚴格規則，Go 語言中哪些值是可以比較的，可以參考規格書中〈<a href="https://golang.org/ref/spec#Comparison_operators">Comparison operators</a>〉的說明。</p>
<p>Go 中沒有 <code>?:</code> 三元條件運算子。</p>
<h1 id="邏輯運算"><a class="header" href="#邏輯運算">邏輯運算</a></h1>
<p>在邏輯上有所謂的「且」、「或」與「反相」，在 Go 中提供對應的邏輯運算子（Logical operator），分別為 <code>&amp;&amp;</code>、<code>||</code>及 <code>!</code>。看看以下的程式片段會輸出什麼結果？</p>
<pre><code class="language-prettyprint">package main

import "fmt"

func main() {
    number := 75
    fmt.Println(number &gt; 70 &amp;&amp; number &lt; 80)     // true
    fmt.Println(number &gt; 80 || number &lt; 75)     // false
    fmt.Println(!(number &gt; 80 || number &lt; 75))  // true
}
</code></pre>
<p><code>&amp;&amp;</code> 與 <code>||</code> 有捷徑運算（Short-Circuit Evaluation）。因為 <code>&amp;&amp;</code> 只要其中一個為假，就可以判定結果為假，所以只要左運算元評估為 <code>false</code>，就會直接傳回 <code>false</code>，不會再去運算右運算元。因為 <code>||</code> 只要其中一個為真，就可以判定結果為真，所以只要左運算元評估為 <code>true</code>，就會直接傳回 <code>true</code>，就不會再去運算右運算元。</p>
<p>來舉個運用捷徑運算的例子，在 Go 中兩個整數相除，若除數為 0 會發生 integer divide by zero 的錯誤，以下運用 <code>&amp;&amp;</code> 捷徑運算避免了這個問題：</p>
<pre><code class="language-prettyprint">if(number2 != 0 &amp;&amp; number1 / number2 &gt; 1) {
    fmt.Println(number1 / number2)
}
</code></pre>
<p>在這個程式片段中，變數 number1 與 number2 都是 <code>int</code> 型態，如果 <code>number2</code> 為 0 的話，<code>&amp;&amp;</code> 左邊運算元結果就是 <code>false</code>，直接判斷整個 <code>&amp;&amp;</code> 的結果應是 <code>false</code>，不用再去評估右運算元，從而避免了 <code>number1 / number2</code> 而 <code>number2</code> 等於 <code>0</code> 時的除零錯誤。</p>
<h1 id="指標"><a class="header" href="#指標">指標</a></h1>
<p>Go 語言中有指標（Pointer），你可以在宣告變數時於型態前加上 <code>*</code>，這表示建立一個指標，例如：</p>
<pre><code class="language-prettyprint">var i *int
</code></pre>
<p>這時 <code>i</code> 是個空指標，也就是值為 <code>nil</code>，上頭等同於 <code>var i *int = nil</code>，目前並沒有儲存任何位址，如果想讓它儲存另一個變數的記憶體位址，可以使用 <code>&amp;</code> 取得變數位址並指定給 <code>i</code>，例如：</p>
<pre><code class="language-prettyprint">package main

import "fmt"

func main() {
    var i *int
    j := 1

    i = &amp;j
    fmt.Println(i)  // 0x104382e0 之類的值
    fmt.Println(*i) // 1

    j = 10
    fmt.Println(*i) // 10

    *i = 20
    fmt.Println(j) // 20
}
</code></pre>
<p><code>j</code> 的位置儲存了 1，那麼具體來說，<code>j</code> 的位置到底是在哪？這就是 <code>&amp;</code> 取址運算的目的，<code>&amp;j</code> 具體取得了 <code>j</code> 的位置，然後指定給 <code>i</code>。</p>
<p>如上所示，如果想存取指標位址處的變數儲存的值，可以使用 <code>*</code>，因而，你改變 <code>j</code> 的值，<code>*i</code> 取得的就是改變後的值，透過 <code>*i</code> 改變值，從 <code>j</code> 取得的也會是改變後的值。</p>
<p>其應用的實例之一是使用 <code>fmt.Scanf</code> 取得標準輸入時，例如：</p>
<pre><code class="language-prettyprint">package main

import "fmt"

func main() {
    var input int
    fmt.Printf("輸入數字")
    fmt.Scanf("%d", &amp;input)
    fmt.Println(input)
}
</code></pre>
<p>這邊使用 <code>&amp;input</code> 取出 <code>input</code> 的記憶體位址值，並傳入 <code>fmt.Scanf</code> 函式，函式中會取得使用者的標準輸入，並儲存至 <code>input</code> 變數的記憶體位址，因而，再度取得 <code>input</code> 的值時，就會是使用者輸入的值。</p>
<p>Go 雖然有指標，不過不能如同 C/C++ 那樣對指標做運算，之後有機會用到指標時，會再做相關說明。</p>
<div class="ad336-280" style="text-align: center;">
</div>
<div class="recommend" style="text-align: center;">
<hr />
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><div id="main" role="main" style="height: auto !important;">
<div class="header">
<h1 id="ifelseswitch-條件式"><a class="header" href="#ifelseswitch-條件式">if..else、switch 條件式</a></h1>
</div>
<p>在分支判斷的控制上，Go 提供了 <code>if...else</code>、<code>switch</code> 語法，相較於其他提供類似語法的語言，在 Go 中 <code>if...else</code>、<code>switch</code> 語法的相似性更高。</p>
<h1 id="ifelse-語法"><a class="header" href="#ifelse-語法">if..else 語法</a></h1>
<p>直接來看個 <code>if..else</code> 的實例：</p>
<pre><code class="language-prettyprint">package main

import "fmt"

func main() {
    input := 10
    remain := input % 2
    if remain == 1 {
        fmt.Printf("%d 為奇數\n", input)
    } else {
        fmt.Printf("%d 為偶數\n", input)
    }
}
</code></pre>
<p>在 Go 中，<code>if</code> 之後直接寫判斷式可以不用使用 <code>()</code> 括號，而 <code>{}</code> 是必要的，這樣應該是比較能避免 <a href="http://support.apple.com/kb/HT6147">Apple 曾經發生某個函式中有兩個連續縮排而引發的問題</a>：</p>
<pre><code class="language-prettyprint">...       
if ((err = SSLHashSHA1.update(&amp;hashCtx, &amp;signedParams)) != 0)
        goto fail;
        goto fail;
if ((err = SSLHashSHA1.final(&amp;hashCtx, &amp;hashOut)) != 0)
        goto fail;
...
</code></pre>
<p>Go 的 <code>if</code> 可以使用 <code>:=</code> 宣告與指定變數值，與判斷式之間以分號區隔，因此方才的範例也可以寫成：</p>
<pre><code class="language-prettyprint">package main

import "fmt"

func main() {
    input := 10
    if remain := input % 2; remain == 1 {
        fmt.Printf("%d 為奇數\n", input)
    } else {
        fmt.Printf("%d 為偶數\n", input)
    }
}
</code></pre>
<p>這麼一來，<code>remain</code> 變數就只在 <code>if..else</code> 的區塊中有作用。如果要使用 <code>:=</code> 宣告與指定多個變數值，可以寫成 <code>if var1, var2 := 10, 20; cond</code> 的形式。<code>if...else</code> 可以組成 <code>if...else if...else</code> 形式，例如：</p>
<pre><code class="language-prettyprint">package main

import "fmt"

func main() {
    var level rune
    if score := 88; score &gt;= 90 {
        level = 'A'
    } else if score &gt;= 80 &amp;&amp; score &lt; 90 {
        level = 'B'
    } else if score &gt;= 70 &amp;&amp; score &lt; 80 {
        level = 'C'
    } else if score &gt;= 60 &amp;&amp; score &lt; 70 {
        level = 'D'
    } else {
        level = 'E'
    }
    fmt.Printf("得分等級：%c\n", level)
}
</code></pre>
<h1 id="switch-語法"><a class="header" href="#switch-語法">switch 語法</a></h1>
<p>實際上，對於上頭的範例，可以改用 <code>switch</code> 來撰寫，程式會更為簡潔：</p>
<pre><code class="language-prettyprint">package main

import "fmt"

func main() {
    var level rune
    score := 88

    switch score / 10 {
    case 10, 9:
        level = 'A'
    case 8:

        level = 'B'
    case 7:
        level = 'C'
    case 6:
        level = 'D'
    default:
        level = 'E'
    }
    fmt.Printf("得分等級：%c\n", level)
}
</code></pre>
<p>注意，與 C/C++ 或 Java 等語言不同的是，Go 的 <code>switch</code> 比對成功後，不會自動往下執行，因而不用撰寫 <code>break</code>，有多個條件想符合時，在同一 <code>case</code> 中使用逗號區隔。如果真的想在比對成功後，往下一個 <code>case</code> 中的陳述執行，可以使用 <code>fallthrough</code>，例如：</p>
<pre><code class="language-prettyprint">package main

import "fmt"

func main() {
    var level rune

    switch score := 100; score / 10 {
    case 10:
        fmt.Println("滿分喔！")
        fallthrough
    case 9:
        level = 'A'
    case 8:

        level = 'B'
    case 7:
        level = 'C'
    case 6:
        level = 'D'
    default:
        level = 'E'
    }
    fmt.Printf("得分等級：%c\n", level)
}
</code></pre>
<p>在上面的例子中，如果沒有 <code>fallthrough</code>，那麼只會顯示 “滿分喔！“，而不會執行 <code>case 9</code> 中的 <code>level = 'A'</code>，因此最後顯示得分等級時，不會有 A 的字眼。在上頭也可以看到，<code>switch</code> 中也可以使用 <code>:=</code> 宣告與初始變數。</p>
<p>實際上，Go 的 <code>switch</code> 中， <code>case</code> 不用是常數，只要 <code>switch</code> 的值型態與 <code>case</code> 比對的型態符合，也可以是個變數或運算式，甚至還可以接受布林運算式，例如：</p>
<pre><code class="language-prettyprint">package main

import "fmt"

func main() {
    var level rune
    score := 88
    switch {
    case score &gt;= 90:
        level = 'A'
    case score &gt;= 80 &amp;&amp; score &lt; 90:
        level = 'B'
    case score &gt;= 70 &amp;&amp; score &lt; 80:
        level = 'C'
    case score &gt;= 60 &amp;&amp; score &lt; 70:
        level = 'D'
    default:
        level = 'E'
    }
    fmt.Printf("得分等級：%c\n", level)
}
</code></pre>
<p>在上面的例子中，<code>switch</code> 沒有指定任何變數，此時等同於 <code>switch true</code>，這時的 <code>case</code> 可以接受布林運算式，可用來取代 <code>if...else if...else</code> 的風格。</p>
<div class="ad336-280" style="text-align: center;">
</div>
<div class="recommend" style="text-align: center;">
<hr />
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><div id="main" role="main" style="height: auto !important;">
<div class="header">
<h1 id="for-迴圈"><a class="header" href="#for-迴圈">for 迴圈</a></h1>
</div>
<p>在 Go 中唯一的迴圈語法是 <code>for</code>，然而，它也擔任了一些語言中 <code>while</code> 的功能，並可搭配 <code>range</code> 來使用。</p>
<h1 id="有分號的-for"><a class="header" href="#有分號的-for">有分號的 for</a></h1>
<p><code>for</code> 最基本的使用形式，與 C/C++、Java 等語言類似，具有初始式、條件式、後置式三個部份，中間使用分號加以區隔，不必使用 <code>()</code> 括號包住這三個式子，同樣地，<code>for</code> 迴圈本體一定要使用 <code>{}</code>。</p>
<p>初始式只執行一次，通常用來宣告或初始變數，若是宣告變數，可見範圍僅在 <code>for</code> 中。第一個分號後是每次執行迴圈本體前會執行一次，且必須是 <code>true</code> 或 <code>false</code> 的結果，<code>true</code> 就會執行迴圈本體，<code>false</code> 就會結束迴圈，第二個分號後，則是每次執行完迴圈本體後會執行一次。</p>
<p>實際來看個 <code>for</code> 迴圈範例，在文字模式下從 1 顯示到 10：</p>
<pre><code class="language-prettyprint">package main

import "fmt"

func main() {
    for i := 1; i &lt;= 10; i++ {
        fmt.Println(i)
    }
}
</code></pre>
<p>這個程式白話讀來，就是從 <code>i</code> 等於 1，只要 <code>i</code> 小於等於 10 就執行迴圈本體（顯示 <code>i</code>），然後遞增 <code>i</code>。在介紹 <code>for</code> 迴圈時，許多書籍或文件很喜歡用的範例就是顯示九九乘法表，這邊也用這個例子來示範巢狀迴圈：</p>
<pre><code class="language-prettyprint">package main

import "fmt"

func main() {
    for i, j := 0, 0; i &lt; 10; i, j = i+1, j+1 {
        fmt.Printf("%d * %d = %2d\n", i, j, i*j)
    }
}
</code></pre>
<p><code>for</code> 中的各陳述是以分號區隔，若當中想寫兩個陳述則使用逗號區隔，例如：</p>
<pre><code class="language-prettyprint">package main

import "fmt"

func main() {
    for i, j := 0, 0; i &lt; 10; i, j = i+1, j+1 {
        fmt.Printf("%d * %d = %2d\n", i, j, i*j)
    }
}
</code></pre>
<p>初始式、後置式都可以省略，不過，分號必須保留，例如：</p>
<pre><code class="language-prettyprint">package main

import "fmt"

func foo(i int) {
    for ; i &lt; 10; i++ {
        fmt.Println(i)
    }
}

func multiplication_table() {
    for i, j := 2, 1; j &lt; 10; {
        fmt.Printf("%d * %d = %2d ", i, j, i*j)
        if i == 9 {
            fmt.Println()
            j++
            i = (j+1)/j + 1
        } else {
            i++
        }
    }
}

func main() {
    foo(1)
    multiplication_table()
}
</code></pre>
<h1 id="無分號的-for"><a class="header" href="#無分號的-for">無分號的 for</a></h1>
<p>在沒有初始式、後置式，只有條件式的情況，也就是 <code>for ; cond;</code> 的時候，可以只寫 <code>for cond</code>，這就是 C/C++、Java 中 <code>while</code> 迴圈的作用了：</p>
<pre><code class="language-prettyprint">package main

import "fmt"

func main() {
    i := 1
    for i &lt; 10 {
        fmt.Println(i)
        i++
    }
}
</code></pre>
<p>如果想製造個無窮迴圈，在 C/C++、Java 等語言中常見寫成 <code>for(;;)</code>，在 Go 中是也可以寫 <code>for ;;</code>，因為條件式不寫預設就是 <code>true</code>，不過，可以只寫個 <code>for</code> 就可以了，底下是個很無聊的遊戲，看誰可以最久不撞到這個數字 5：</p>
<pre><code class="language-prettyprint">package main

import (
    "fmt"
    "math/rand"
    "time"
)

func random(min, max int) int {
    rand.Seed(time.Now().Unix())
    return rand.Intn(max-min) + min
}

func main() {
    for {
        number := random(1, 10)
        fmt.Println(number)
        if number == 5 {
            break
        }
        time.Sleep(time.Second)
    }
    fmt.Println("I hit 5....Orz")
}
</code></pre>
<p>在 <code>for</code> 迴圈中如果執行到 <code>break</code>，會離開迴圈本體。</p>
<h1 id="for-range"><a class="header" href="#for-range">for range</a></h1>
<p>Go 的 <code>for</code> 可以搭配 <code>range</code>，對 slice、陣列、<code>string</code>、<code>map</code> 和 channel（之後說明）進行迭代，<code>range</code> 視給定的形態不同，會有不同的傳回值。</p>
<p>對於 slice、陣列、<code>string</code>、<code>map</code>，在之前的〈<a href="http://openhome.cc/Gossip/Go/String.html">位元組構成的字串</a>〉、〈<a href="http://openhome.cc/Gossip/Go/Array.html">身為複合值的陣列</a>〉、〈<a href="http://openhome.cc/Gossip/Go/Slice.html">底層為陣列的 slice</a>〉與〈<a href="http://openhome.cc/Gossip/Go/Map.html">成對鍵值的 map</a>〉中，都有相關範例示範，這邊不再贅述。</p>
<div class="ad336-280" style="text-align: center;">
</div>
<div class="recommend" style="text-align: center;">
<hr />
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><div id="main" role="main" style="height: auto !important;">
<div class="header">
<h1 id="breakcontinuegoto"><a class="header" href="#breakcontinuegoto">break、continue、goto</a></h1>
</div>
<p><code>break</code> 可以離開目前 <code>switch</code>、<code>for</code> 以及 <code>select</code>（之後介紹）；<code>continue</code> 只用於 <code>for</code> 迴圈，略過之後陳述句，並回到迴圈開頭進行下一次迴圈，而不是離開迴圈。<code>goto</code> 可以在函式中，讓流程直接跳至指定標籤；實際上，<code>break</code>、<code>continue</code> 在迴圈中，也可以搭配標籤來使用。</p>
<h1 id="break"><a class="header" href="#break">break</a></h1>
<p>在〈<a href="http://openhome.cc/Gossip/Go/IfSElsewitch.html">if … else、switch 條件式</a>〉中說明過，<code>switch</code> 的 <code>case</code> 中不必特別使用 <code>break</code>，因為 <code>switch</code> 中預設不會 <code>fallthrough</code>，但 <code>case</code> 中若必要，還是可以使用 <code>break</code>，中斷 <code>break</code> 之後與下個 <code>case</code> 前的流程。</p>
<p><code>break</code> 使用於 <code>for</code> 迴圈時，會結束迴圈，例如：</p>
<pre><code class="language-prettyprint">package main

import "fmt"

func main() {
    for i := 1; i &lt; 10; i++ {
        if i == 5 {
            break
        }
        fmt.Printf("i = %d\n", i)
    }
}
</code></pre>
<p>這段程式會顯示 i = 1 到 i = 4，因為在 i 等於 5 時就會執行 <code>break</code> 而離開 <code>for</code> 迴圈。</p>
<p><code>break</code> 可以配合標籤使用，例如本來 <code>break</code> 只會離開一層 <code>for</code> 迴圈，若設定標籤，並於 <code>break</code> 時指定標籤，就可以直接離開多層 <code>for</code> 迴圈：</p>
<pre><code class="language-prettyprint">package main

import "fmt"

func main() {

BACK:
    for j := 1; j &lt; 10; j++ {
        for i := 1; i &lt; 10; i++ {
            if i == 5 {
                break BACK
            }
            fmt.Printf("i = %d, j = %d\n", i, j)
        }
        fmt.Println("test")
    }
}
</code></pre>
<p>你可以執行看看上面的範例，之後將 <code>BACK:</code> 與 <code>BACK</code> 拿掉看看，前者 <code>break BACK</code> 時會離開兩層 <code>for</code> 迴圈，後者只會離開內層 <code>for</code> 迴圈。</p>
<h1 id="continue"><a class="header" href="#continue">continue</a></h1>
<p><code>continue</code> 只用於 <code>for</code> 迴圈，略過之後陳述句，並回到迴圈開頭進行下一次迴圈，例如將先前第一個範例程式的 <code>break</code> 改成 <code>continue</code>：</p>
<pre><code class="language-prettyprint">package main

import "fmt"

func main() {
    for i := 1; i &lt; 10; i++ {
        if i == 5 {
            continue
        }
        fmt.Printf("i = %d\n", i)
    }
}
</code></pre>
<p>這段程式會顯示 i = 1 到 4，以及 6 到 9，當 <code>i</code> 等於 5 時，會執行 <code>continue</code> 直接略過之後陳述句，也就是該次的 <code>fmt.Printf()</code> 該行並沒有被執行，直接從 <code>for</code> 開頭執行下一次迴圈，所以 i = 5 沒有被顯示。</p>
<p><code>continue</code> 也有搭配標籤的用法：</p>
<pre><code class="language-prettyprint">package main

import "fmt"

func main() {
BACK:
    for j := 1; j &lt; 10; j++ {
        for i := 1; i &lt; 10; i++ {
            if i == 5 {
                continue BACK
            }
            fmt.Printf("i = %d, j = %d\n", i, j)
        }
        fmt.Println("test")
    }
}
</code></pre>
<h1 id="goto"><a class="header" href="#goto">goto</a></h1>
<p>在 C/C++ 中，<code>goto</code> 是一個很方便，但是常不建議使用的語法，因為濫用它的話，經常會破壞程式的架構、使得程式的邏輯混亂，然而，在 Go 中，亦有提供有 <code>goto</code> 語法。</p>
<p>相對於 <code>break</code> 與 <code>continue</code> 跳躍時，只能前往 <code>for</code> 迴圈開頭處設定的標籤，<code>goto</code> 可以在函式中，從某區塊內跳躍至區塊外任何位置，一個簡單的例子如下：</p>
<pre><code class="language-prettyprint">package main

import "fmt"

func main() {
    var input int

RETRY:
    fmt.Printf("輸入數字")
    fmt.Scanf("%d", &amp;input)

    if input == 0 {
        fmt.Println("除數不得為 0")
        goto RETRY
    }
    fmt.Printf("100 / %d = %f\n", input, 100/float32(input))
}
</code></pre>
<p>如果你輸入 0，程式會顯示錯誤訊息後跳至 <code>RETRY:</code>，再執行一次提示與輸入。</p>
<p>注意，<code>goto</code> 可以在函式中，從某區塊內跳躍至區塊外任何位置，但不能從某區塊跳入另一區塊內，例如，以下是錯誤的，會發生 goto TEST jumps into block 的錯誤：</p>
<pre><code class="language-prettyprint">package main

import "fmt"

func main() {
    var input int

RETRY:
    fmt.Printf("輸入數字")
    fmt.Scanf("%d", &amp;input)

    if input == 0 {
    TEST:
        fmt.Println("除數不得為 0")
        goto RETRY
    }
    fmt.Printf("100 / %d = %f\n", input, 100/float32(input))
    goto TEST
}
</code></pre>
<div class="ad336-280" style="text-align: center;">
</div>
<div class="recommend" style="text-align: center;">
<hr />
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><div id="main" role="main" style="height: auto !important;">
<div class="header">
<h1 id="函式入門"><a class="header" href="#函式入門">函式入門</a></h1>
</div>
<p>在 Go 中要定義函式，是使用 <code>func</code> 來定義，其基本格式如下：</p>
<pre><code class="language-prettyprint">func funcName(param1 type1, param2 type2) (return1 type1, return2 type2) {
    // 一些程式碼...
    return value1, value2
}
</code></pre>
<h1 id="定義函式"><a class="header" href="#定義函式">定義函式</a></h1>
<p>可以看到，Go 定義函式時，參數的型態宣告同樣地是放在名稱之後，如果多個參數有同樣的型態，那麼只要最右邊同型態的名稱右方加上型態就可以了，比較特別的地方在於，可以有兩個以上的傳回值，且傳回值可以設定名稱。</p>
<div class="google-auto-placed" style="width: 100%; height: auto; clear: both; text-align: center;">
</div>
<p>來看個簡單的函式定義，以下是個求最大公因數的函式定義：</p>
<pre><code class="language-prettyprint">package main

import "fmt"

func Gcd(m, n int) int {
    if n == 0 {
        return m
    } else {
        return Gcd(n, m%n)
    }
}

func main() {
    fmt.Printf("Gcd of 10 and 4: %d\n", Gcd(10, 4)) // 2
}
</code></pre>
<p>當只有一個傳回值且沒有宣告名稱時，傳回值的宣告可以不用使用 <code>()</code>，傳回值的名稱可以在函式中使用，傳回值名稱設定的值，會自動於函式 <code>return</code> 時傳回，例如：</p>
<pre><code class="language-prettyprint">package main

import "fmt"

func Gcd(m, n int) (gcd int) {
    if n == 0 {
        gcd = m
    } else {
        gcd = Gcd(n, m%n)
    }
    return
}

func main() {
    fmt.Printf("Gcd of 10 and 4: %d\n", Gcd(10, 4)) // 2
}
</code></pre>
<div class="google-auto-placed" style="width: 100%; height: auto; clear: both; text-align: center;">
</div>
<p>官方的建議是要宣告傳回值名稱，令程式可讀性更高（當然程式會變得囉嗦一些），對那些公開給套件外使用的函式（也就是首字大寫的函式），最好是宣告傳回值名稱。</p>
<h1 id="多個傳回值"><a class="header" href="#多個傳回值">多個傳回值</a></h1>
<p>Go 中允許多個傳回值，例如，定義一個函式，可搜尋 slice 的元素中是否指定的子字串，若有就傳回元素索引位置與字串，若無就傳回 -1 與空字串：</p>
<pre><code class="language-prettyprint">package main

import "fmt"
import "strings"

func FirstMatch(elems []string, substr string) (int, string) {
    for index, elem := range elems {
        if strings.Contains(elem, substr) {
            return index, elem
        }
    }
    return -1, ""
}

func main() {
    names := []string{"Justin Lin", "Monica Huang", "Irene Lin"}
    if index, name := FirstMatch(names, "Huang"); index == -1 {
        fmt.Println("找不到任何東西")
    } else {
        fmt.Printf("在索引 %d 找到 \"%s\"\n", index, name)
    }
}
</code></pre>
<p>傳回多值時，指定給變數時必須依順序，若不需要某個傳回值，可以使用 <code>_</code> 略過：</p>
<pre><code class="language-prettyprint">_, name := FirstMatch(names, "Huang")
</code></pre>
<p>另一種多值傳回的場合之一是錯誤處理，例如：</p>
<pre><code class="language-prettyprint">package main

import "fmt"
import "errors"

func Div(x, y int) (int, error) {
    if y == 0 {
        return 0, errors.New("division by zero")
    }
    return x / y, nil
}

func main() {
    if result, err := Div(10, 5); err == nil {
        fmt.Printf("10 / 5 = %d\n", result)
    } else {
        fmt.Println(err)
    }
}
</code></pre>
<p>若函式簽署上有傳回 <code>error</code>，應透過檢查其是否為 <code>nil</code> 來確認執行時是否有錯誤發生，這是 Go 的錯誤處理風格之一，例如，<code>os.Open</code> 的函式簽署是：</p>
<pre><code class="language-prettyprint">func Open(name string) (file *File, err error)
</code></pre>
<p>透過 <code>os.Open</code> 開啟檔案時的一個基本範例就是：</p>
<pre><code class="language-prettyprint">file, err := os.Open("file.go")
if err != nil {
    log.Fatal(err)
}
</code></pre>
<h1 id="可變參數"><a class="header" href="#可變參數">可變參數</a></h1>
<p>在呼叫方法時，若方法的引數個數事先無法決定該如何處理？在 Go 中支援不定長度引數（Variable-length Argument），可以輕鬆的解決這個問題。直接來看示範：</p>
<pre><code class="language-prettyprint">package main

import "fmt"

func Sum(numbers ...int) int {
    var sum int
    for _, number := range numbers {
        sum += number
    }
    return sum
}

func main() {
    fmt.Println(Sum(1, 2))          // 3
    fmt.Println(Sum(1, 2, 3))       // 6
    fmt.Println(Sum(1, 2, 3, 4))    // 10
    fmt.Println(Sum(1, 2, 3, 4, 5)) // 15
}
</code></pre>
<p>可以看到，要使用不定長度引數，宣告參數時要於型態關鍵字前加上 <code>...</code>，此參數本質上是個 slice，因此可以使用 <code>for range</code> 來走訪元素，可接受可變長度的參數只能有一個，而必須是最後一個參數。</p>
<p>雖然可接受可變長度引數的參數，本質上是個 slice，然而，若已經有個 slice，並不能直接傳遞給它，而必須使用 <code>...</code> 展開，否則會發生錯誤：</p>
<pre><code class="language-prettyprint">package main

import "fmt"

func Sum(numbers ...int) int {
    var sum int
    for _, number := range numbers {
        sum += number
    }
    return sum
}

func main() {
    numbers := []int{1, 2, 3, 4, 5}
    fmt.Println(Sum(numbers...)) // 15
}
</code></pre>
<h1 id="函式與指標"><a class="header" href="#函式與指標">函式與指標</a></h1>
<p>Go 語言有指標，因此，在變數傳遞就多了一種選擇，直接來看個例子，以下的執行結果會顯示 1：</p>
<pre><code class="language-prettyprint">package main

import "fmt"

func add1To(n int) {
    n = n + 1
}

func main() {
    number := 1
    add1To(number)
    fmt.Println(number) // 1
}
</code></pre>
<p>這應該沒有問題，因為傳遞的是<strong>變數值</strong>給 <code>n</code>，函式中 <code>n</code> 的值加上 1 之後，再指定回給 <code>n</code>，這對 <code>main</code> 中的 <code>number</code> 變數毫無影響，因此函式結束後，顯示 <code>number</code> 的值，仍舊是 1。</p>
<p>那麼來看下面這個例子：</p>
<pre><code class="language-prettyprint">package main

import "fmt"

func add1To(n *int) {
    *n = *n + 1
}

func main() {
    number := 1
    add1To(&amp;number)
    fmt.Println(number) // 2
}
</code></pre>
<p>這次使用了 <code>&amp;number</code> 取得 <code>number</code> 的位址值再傳遞給 <code>n</code>，也就是傳遞了<strong>變數位址值</strong>給 <code>n</code>，函式中使用 <code>*n</code> 取得位址處的值，加上 1 後再將值存回原位址處，因此，透過 <code>main</code> 函式中的 <code>number</code> 取得的值，也會是加 1 後的值。</p>
<div class="ad336-280" style="text-align: center;">
</div>
<div class="recommend" style="text-align: center;">
<hr />
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><div id="main" role="main" style="height: auto !important;">
<div class="header">
<h1 id="一級函式"><a class="header" href="#一級函式">一級函式</a></h1>
</div>
<p>作為一門現代語言，Go 的特色之一是函式為一級函式（First-class function），可以作為值來進行傳遞。</p>
<h1 id="函式作為值"><a class="header" href="#函式作為值">函式作為值</a></h1>
<p>例如你定義一個取最大值的函式 <code>max</code>，你可以將此函式作為值傳遞給 <code>maximum</code>：</p>
<pre><code class="language-prettyprint">package main

import "fmt"

func max(a, b int) int {
    if a &gt; b {
        return a
    }
    return b
}

func main() {
    maximum := max
    fmt.Println(max(10, 5))     // 10
    fmt.Println(maximum(10, 5)) // 10
}
</code></pre>
<div class="google-auto-placed" style="width: 100%; height: auto; clear: both; text-align: center;">
</div>
<p>可以看到，被 <code>max</code> 參考的函式，也被 <code>maximum</code> 參考著，因而，現在透過 <code>max</code> 或者 <code>maximum</code>，都可以呼叫函式。</p>
<p>因為 Go 型態推斷能力的關係，上頭的 <code>maximum</code> 並不用宣告型態，而可以直接參考 <code>max</code> 函式的型態，那麼，<code>max</code> 或者是 <code>maximum</code> 的型態是什麼呢？</p>
<pre><code class="language-prettyprint">package main

import "fmt"
import "reflect"

func max(a, b int) int {
    if a &gt; b {
        return a
    }
    return b
}

func main() {
    maximum := max
    fmt.Println(reflect.TypeOf(max))     // func(int, int) int
    fmt.Println(reflect.TypeOf(maximum)) // func(int, int) int
}
</code></pre>
<div class="google-auto-placed" style="width: 100%; height: auto; clear: both; text-align: center;">
</div>
<p>可以看到，函式的型態包括了 <code>func</code>、參數型態與傳回值型態，但不用宣告函式、參數與傳回值的名稱。</p>
<h1 id="宣告函式變數"><a class="header" href="#宣告函式變數">宣告函式變數</a></h1>
<p>你可以僅宣告一個變數可用來參考特定型態的函式，例如：</p>
<pre><code class="language-prettyprint">package main

import "fmt"

func max(a, b int) int {
    if a &gt; b {
        return a
    }
    return b
}

func main() {
    var maximum func(int, int) int
    fmt.Println(maximum) // nil

    maximum = max
    fmt.Println(maximum(10, 5)) // 10
}
</code></pre>
<p>若想先宣告一個 <code>maximum</code> 變數，可以在之後參考 <code>max</code> 函式，可以使用型態 <code>func(int, int) int</code> 來宣告，通常，宣告函式變數時，若想免於冗長的函式型態宣告，可以使用 <code>type</code> 來定義一個新的型態名稱：</p>
<pre><code class="language-prettyprint">package main

import "fmt"

type BiFunc func(int, int) int // 定義了新型態

func max(a, b int) int {
    if a &gt; b {
        return a
    }
    return b
}

func main() {
    var maximum BiFunc
    fmt.Println(maximum) // nil

    maximum = max
    fmt.Println(maximum(10, 5)) // 10
}
</code></pre>
<div class="google-auto-placed" style="width: 100%; height: auto; clear: both; text-align: center;">
</div>
<p>在上例中，<code>BiFunc</code> 是個新的定義型態（defined type），底層型態（underlying type）為 <code>func(int, int) int</code>，Go 會認定兩者屬於不同型態，因為新的型態會擁有新的名稱，在 Go 1.9 前，這是避免冗長函式型態宣告的唯一方式。</p>
<p>不過，就這邊來說，實際上只是想要 <code>func(int, int) int</code> 能有個簡短一點的名稱，從 Go 1.9 開始，可以為型態取別名，別名就只是同一型態的另一個名稱，：</p>
<pre><code class="language-prettyprint">package main

import "fmt"

type BiFunc = func(int, int) int // 型態別名宣告

func max(a, b int) int {
    if a &gt; b {
        return a
    }
    return b
}

func main() {
    var maximum BiFunc
    fmt.Println(maximum) // nil

    maximum = max
    fmt.Println(maximum(10, 5)) // 10
}
</code></pre>
<p>在這邊，<code>BiFunc</code> 只是 <code>func(int, int) int</code> 的另一個名稱，而不是新的型態。</p>
<p>函式變數既然是個變數，也就可以對它取指標，例如：</p>
<pre><code class="language-prettyprint">package main

import "fmt"

type BiFunc = func(int, int) int

func max(a, b int) int {
    if a &gt; b {
        return a
    }
    return b
}

func main() {
    var maximum BiFunc
    fmt.Println(&amp;maximum) // 0x1040a130
    // fmt.Println(&amp;max)
}
</code></pre>
<p>如上，你可以對 <code>maximum</code> 取指標，得到變數位址，不過，你不能對宣告的 <code>max</code> 取指標，去除程式中最後一個註解的話，會發生 cannot take the address of max 的錯誤。</p>
<h1 id="回呼應用"><a class="header" href="#回呼應用">回呼應用</a></h1>
<p>因為函式可以當作值傳遞，因此，對於函式中流程幾乎相同，只有少數操作不同的情況，就可以將操作不同的部份以回呼（Callback）函式取代。例如，可以設計一個 <code>filter</code> 函式，用來過濾出符合特定條件的值：</p>
<pre><code class="language-prettyprint">package main

import "fmt"

type Predicate = func(int) bool

func filter(origin []int, predicate Predicate) []int {
    filtered := []int{}
    for _, elem := range origin {
        if predicate(elem) {
            filtered = append(filtered, elem)
        }
    }
    return filtered
}

func greaterThan7(n int) bool {
    return n &gt; 7
}

func lessThan5(n int) bool {
    return n &lt; 5
}

func main() {
    data := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
    fmt.Println(filter(data, greaterThan7))
    fmt.Println(filter(data, lessThan5))    
}
</code></pre>
<p>在這個例子中，<code>filter</code> 函式重用了 <code>for range</code> 與 <code>if</code> 等流程，只要傳入過濾用的函式，就可以讓 <code>filter</code> 具有各種的過濾用途。</p>
<p>除了作為值傳遞之外，Go 的函式還可以是匿名函式，且具有閉包（Closure）的特性，這將在下一篇文件加以說明。</p>
<div class="ad336-280" style="text-align: center;">
</div>
<div class="recommend" style="text-align: center;">
<hr />
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><div id="main" role="main" style="height: auto !important;">
<div class="header">
<h1 id="匿名函式與閉包"><a class="header" href="#匿名函式與閉包">匿名函式與閉包</a></h1>
</div>
<p>除了作為值傳遞之外，Go 的函式還可以是匿名函式，且具有閉包（Closure）的特性，由於 Go 具有指標，在理解閉包時反而容易一些了。</p>
<h1 id="匿名函式"><a class="header" href="#匿名函式">匿名函式</a></h1>
<p>在〈<a href="http://openhome.cc/Gossip/Go/FirstClassFunction.html">一級函式</a>〉中，我們看過函式可作為值傳遞的一個應用是，可將函式傳入另一函式作為回呼（Callback），除了傳遞具名的函式之外，有時會想要臨時建立一個函式進行傳遞，例如：</p>
<pre><code class="language-prettyprint">package main

import "fmt"

type Predicate = func(int) bool

func filter(origin []int, predicate Predicate) []int {
    filtered := []int{}
    for _, elem := range origin {
        if predicate(elem) {
            filtered = append(filtered, elem)
        }
    }
    return filtered
}

func main() {
    data := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
    fmt.Println(filter(data, func(elem int) bool {
        return elem &gt; 5
    }))
    fmt.Println(filter(data, func(elem int) bool {
        return elem &lt;= 6
    }))
}
</code></pre>
<div class="google-auto-placed" style="width: 100%; height: auto; clear: both; text-align: center;">
</div>
<p>這個函式與〈<a href="http://openhome.cc/Gossip/Go/FirstClassFunction.html">一級函式</a>〉中最後一個範例的作用相同，不過這次傳遞了匿名函式給 <code>filter</code>，可以看到，匿名函式可使用 <code>func</code> 建立，同樣必須指定參數與傳回值型態。</p>
<p>在 Go 中，不允許在函式中又宣告函式，例如，以下是不允許的：</p>
<pre><code class="language-prettyprint">func funcA() {
    func funcB() {
        ...
    }
    ...
}
</code></pre>
<div class="google-auto-placed" style="width: 100%; height: auto; clear: both; text-align: center;">
</div>
<p>這會出現 “nested func not allowed” 的錯誤，然而，你可以建立匿名函式，然後將之指定給某個變數：</p>
<pre><code class="language-prettyprint">func funcA() {
    funcB := func() {
       ...
    }
    ...
}
</code></pre>
<p>你也可以在函式中建立匿名函式，並將之傳回：</p>
<pre><code class="language-prettyprint">package main

import "fmt"

type Func1 = func(int) int

func funcA() Func1 {
    x := 10
    return func(n int) int {
        return x + n
    }
}

func main() {
    fmt.Println(funcA()(2)) // 12
}
</code></pre>
<p>在上面的範例中，執行 <code>funcA</code> 會傳回一個函式，這個傳回的函式會將接受的引數指定給參數 <code>n</code>，並與 <code>x</code> 的值進行相加，因此最後顯示結果為 12。</p>
<h1 id="閉包"><a class="header" href="#閉包">閉包</a></h1>
<div class="google-auto-placed" style="width: 100%; height: auto; clear: both; text-align: center;">
</div>
<p>可以在函式中建立匿名函式，引發了一個有趣的事實，先來看個例子：</p>
<pre><code class="language-prettyprint">package main

import "fmt"

type Consumer = func(int)

func forEach(elems []int, consumer Consumer) {
    for _, elem := range elems {
        consumer(elem)
    }
}

func main() {
    numbers := []int{1, 2, 3, 4, 5}
    sum := 0
    forEach(numbers, func(elem int) {
        sum += elem
    })
    fmt.Println(sum) // 15
}
</code></pre>
<p>乍看之下，似乎有點像是：</p>
<pre><code class="language-prettyprint">package main

import "fmt"

type Consumer = func(int)

func forEach(elems []int, consumer Consumer) {
    for _, elem := range elems {
        consumer(elem)
    }
}

func main() {
    numbers := []int{1, 2, 3, 4, 5}
    sum := 0
    for _, elem := range numbers {
        sum += elem
    }
    fmt.Println(sum) // 15
}
</code></pre>
<p>然而意義完全不同。在使用 <code>forEach</code> 函式的範例中，<code>sum</code> 變數被匿名函式包覆並傳入 <code>forEach</code> 之中，在 <code>forEach</code> 執行迴圈的過程中，每次呼叫傳入的函式（被 <code>consumer</code> 參考），就會改變 <code>sum</code> 的值，因此，最後得到的是加總後的值 15。</p>
<p>實際上，使用 <code>forEach</code> 函式的範例中，建立了一個閉包，閉包本質上就是一個匿名函式，<code>sum</code> 變數被閉包包覆，讓 <code>sum</code> 變數可以存活於閉包的範疇中，其實，更之前從 <code>funcA</code> 傳回函式的範例中，也建立了閉包，<code>funcA</code> 的 <code>x</code> 區域變數被閉包包覆，因此，你執行傳回的函式時，即使 <code>funcA</code> 已執行完畢，<code>x</code> 變數依然是存活著在傳回的閉包範疇中，所以，你指定的引數總是會與 <code>x</code> 的值進行相加。</p>
<p>重點在於，閉包將<strong>變數本身</strong>關閉在自己的範疇中，而不是變數的值，可以用以下這個範例來做個示範：</p>
<pre><code class="language-prettyprint">package main

import "fmt"

type Getter = func() int
type Setter = func(int)

func x_getter_setter(x int) (Getter, Setter) {
    getter := func() int {
        return x
    }
    setter := func(n int) {
        x = n
    }
    return getter, setter
}

func main() {
    getX, setX := x_getter_setter(10)

    fmt.Println(getX()) // 10
    setX(20)
    fmt.Println(getX()) // 20
}
</code></pre>
<p>對 <code>x_getter_setter</code> 來說，<code>x</code> 參數也是變數，<code>x_getter_setter</code> 傳回了兩個匿名函式，這兩個匿名函式都形成了閉包，將 <code>x</code> 變數關閉在自己的範疇中，因此，你使用了 <code>setX(20)</code> 改變了 <code>x</code> 的值，使用 <code>getX()</code> 時取得的值，就會是修改後的值。</p>
<h1 id="閉包與指標"><a class="header" href="#閉包與指標">閉包與指標</a></h1>
<p>如果你寫過 JavaScript，對於方才的範例，應該不會陌生，也因為 JavaScript 的普及，現在開發者多半對閉包不會覺得神秘難解了，而對於「閉包將變數本身關閉在自己的範疇中，而不是變數的值」，也比較瞭解其應用所在。</p>
<p>由於 Go 語言有指標，我們可以將指標的值顯示出來，這代表著變數的位址值，來看看被閉包關閉的變數，到底是怎麼一回事好了：</p>
<pre><code class="language-prettyprint">package main

import "fmt"

type Getter = func() int
type Setter = func(int)

func x_getter_setter(x int) (Getter, Setter) {
    fmt.Printf("the parameter :\tx (%p) = %d\n", &amp;x, x)

    getter := func() int {
        fmt.Printf("getter invoked:\tx (%p) = %d\n", &amp;x, x)
        return x
    }
    setter := func(n int) {
        x = n
        fmt.Printf("setter invoked:\tx (%p) = %d\n", &amp;x, x)
    }
    return getter, setter
}

func main() {
    getX, setX := x_getter_setter(10)

    fmt.Println(getX())
    setX(20)
    fmt.Println(getX())
}
</code></pre>
<p>這個範例與前一個範例類似，只不過呼叫函式時，都會顯示 <code>x</code> 變數的位址值與儲存值，一個執行結果是：</p>
<pre><code class="language-prettyprint">the parameter : x (0x104382e0) = 10
getter invoked: x (0x104382e0) = 10
10
setter invoked: x (0x104382e0) = 20
getter invoked: x (0x104382e0) = 20
20
</code></pre>
<p>看到了嗎？顯示的變數的位址值都是相同的，閉包將<strong>變數本身</strong>關閉在自己的範疇中，而不是變數的值，就是這麼一回事。</p>
<div class="ad336-280" style="text-align: center;">
</div>
<div class="recommend" style="text-align: center;">
<hr />
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><div id="main" role="main" style="height: auto !important;">
<div class="header">
<h1 id="deferpanicrecover"><a class="header" href="#deferpanicrecover">defer、panic、recover</a></h1>
</div>
<p>就許多現代語言而言，例外處理機制是基本特性之一，然而，例外處理是好是壞，一直以來存在著各種不同的意見，在 Go 語言中，沒有例外處理機制，取而代之的，是運用 <code>defer</code>、<code>panic</code>、<code>recover</code> 來滿足類似的處理需求。</p>
<h1 id="defer-延遲執行"><a class="header" href="#defer-延遲執行">defer 延遲執行</a></h1>
<p>在 Go 語言中，可以使用 <code>defer</code> 指定某個函式延遲執行，那麼延遲到哪個時機？簡單來說，在函式 <code>return</code> 之前，例如：</p>
<pre><code class="language-prettyprint">package main

import "fmt"

func deferredFunc() {
    fmt.Println("deferredFunc")    
}

func main() {
    defer deferredFunc()
    fmt.Println("Hello, 世界")    
}
</code></pre>
<div class="google-auto-placed" style="width: 100%; height: auto; clear: both; text-align: center;">
</div>
<p>這個範例執行時，<code>deferredFunc()</code> 前加上了 <code>defer</code>，因此，會在 <code>main()</code> 函式 <code>return</code> 前執行，結果就是先顯示了 <code>"Hello, 世界"</code>，才顯示 <code>"deferredFunc"</code>。</p>
<p>如果有多個函式被 <code>defer</code>，那麼在函式 <code>return</code> 前，會依 <code>defer</code> 的相反順序執行，也就是 LIFO，例如：</p>
<pre><code class="language-prettyprint">package main

import "fmt"

func deferredFunc1() {
    fmt.Println("deferredFunc1")
}

func deferredFunc2() {
    fmt.Println("deferredFunc2")
}

func main() {
    defer deferredFunc1()
    defer deferredFunc2()
    fmt.Println("Hello, 世界")
}
</code></pre>
<div class="google-auto-placed" style="width: 100%; height: auto; clear: both; text-align: center;">
</div>
<p>由於先 <code>defer</code> 了 <code>deferredFunc1()</code>，才 <code>defer</code> 了 <code>deferredFunc2()</code>，因此執行結果會是 <code>"Hello, 世界"</code>、<code>"deferredFunc2"</code>、<code>"deferredFunc1"</code> 的顯示順序。</p>
<p>上頭是為了清楚表示出 <code>defer</code> 與函式的關係，實際上，你也可以寫成這樣就好：</p>
<pre><code class="language-prettyprint">package main

import "fmt"

func main() {
    defer fmt.Println("deffered 1")    
    defer fmt.Println("deffered 2")
    fmt.Println("Hello, 世界")    
}
</code></pre>
<div class="google-auto-placed" style="width: 100%; height: auto; clear: both; text-align: center;">
</div>
<p>執行結果會是 <code>"Hello, 世界"</code>、<code>"deferred 2"</code>、<code>"deferred 1"</code> 的顯示順序。</p>
<div class="google-auto-placed" style="width: 100%; height: auto; clear: both; text-align: center;">
</div>
<p>有趣的一點是，被 <code>defer</code> 的函式若有接受某變數作為引數，那麼會是被 <code>defer</code> 當時的變數值，例如：</p>
<pre><code class="language-prettyprint">package main

import "fmt"

func main() {
    i := 10
    defer fmt.Println(i)    
    i++
    fmt.Println(i) 
}
</code></pre>
<p>在上面的例子中，會顯示 11 與 10，這是因為第一個 <code>fmt.Println(i)</code> 被 <code>defer</code> 時，保有 <code>i</code> 當時的值 10。</p>
<h1 id="使用-defer-清除資源"><a class="header" href="#使用-defer-清除資源">使用 defer 清除資源</a></h1>
<p>那麼要用在何處？記得 <code>defer</code> 的特性是在函式 <code>return</code> 前執行，而且一定會被執行，因此，對於以下的這個程式：</p>
<pre><code class="language-prettyprint">package main

import (
    "fmt"
    "os"
)

func main() {
    f, err := os.Open("/tmp/dat")
    if err != nil {
        fmt.Println(err)
    } else {
        b1 := make([]byte, 5)
        n1, err := f.Read(b1)
        if err != nil {
            fmt.Println(err)
        } else {
            fmt.Printf("%d bytes: %s\n", n1, string(b1))
            // 處理讀取的內容....
            f.Close()
        }
    }
}
</code></pre>
<p>這是一個讀取檔案的例子，<code>os.Open</code> 與 <code>f.Read</code> 的風格是傳回兩個值，第二個值代表著有無錯誤發生，因此程式中進行了錯誤的檢查，在沒有錯誤的情況下才進行檔案的讀取與內容處理，而最後透過 <code>f.Close()</code> 關閉檔案。</p>
<p>基本上，這個範例的問題在於，<code>f.Close()</code> 不一定會被執行，因為 Go 語言中還有其他展現錯誤的方式，例如使用 <code>panic</code> 函式。假設在「處理讀取的內容」過程中因為呼叫了 <code>panic</code> 來表示有錯誤發生，那麼會立即中斷函式的執行（在這個例子就是直接離開 <code>main</code> 函式），這時 <code>f.Close()</code> 就不會被執行。</p>
<p>你可以使用 <code>defer</code> 來執行函式的關閉：</p>
<pre><code class="language-prettyprint">package main

import (
    "fmt"
    "os"
)

func main() {
    f, err := os.Open("/tmp/dat")
    if err != nil {
        fmt.Println(err)
        return;
    }

    defer func() { // 延遲執行，而且函式 return 前一定會執行
        if f != nil {
            f.Close()
        }
    }()

    b1 := make([]byte, 5)
    n1, err := f.Read(b1)
    if err != nil {
        fmt.Printf("%d bytes: %s\n", n1, string(b1))
        // 處理讀取的內容....
    }
}
</code></pre>
<p>這麼一來，若 <code>Read</code> 發生錯誤，最後一定會執行被 <code>defer</code> 的函式，從而保證了 <code>f.Close()</code> 一定會關閉檔案。</p>
<p>（就某些意義來說，<code>defer</code> 的角色類似於例外處理機制中 <code>finally</code> 的機制，將資源清除的函式，藉由 <code>defer</code> 來處理，一方面大概也是為了在程式碼閱讀上，強調出資源清除的重要性吧！）</p>
<h1 id="panic-恐慌中斷"><a class="header" href="#panic-恐慌中斷">panic 恐慌中斷</a></h1>
<p>方才稍微提過，如果在函式中執行 <code>panic</code>，那麼函式的流程就會中斷，若 A 函式呼叫了 B 函式，而 B 函式中呼叫了 <code>panic</code>，那麼 B 函式會從呼叫了 <code>panic</code> 的地方中斷，而 A 函式也會從呼叫了 B 函式的地方中斷，若有更深層的呼叫鏈，<code>panic</code> 的效應也會一路往回傳播。</p>
<p>（如果你有例外處理的經驗，這就相當於被拋出的例外都沒有處理的情況。）</p>
<p>可以將方才的範例改寫為以下：</p>
<pre><code class="language-prettyprint">package main

import (
    "fmt"
    "os"
)

func check(err error) {
    if err != nil {
        panic(err)
    }
}

func main() {
    f, err := os.Open("/tmp/dat")
    check(err)

    defer func() {
        if f != nil {
            f.Close()
        }
    }()

    b1 := make([]byte, 5)
    n1, err := f.Read(b1)
    check(err)

    fmt.Printf("%d bytes: %s\n", n1, string(b1))
}
</code></pre>
<p>如果在開啟檔案時，就發生了錯誤，假設這是在一個很深的呼叫層次中發生，若你直接想撰寫程式，將 <code>os.Open</code> 的 <code>error</code> 逐層傳回，那會是一件很麻煩的事，此時直接發出 <code>panic</code>，就可以達到想要的目的。</p>
<h1 id="recover-恢復流程"><a class="header" href="#recover-恢復流程">recover 恢復流程</a></h1>
<p>如果發生了 <code>panic</code>，而你必須做一些處理，可以使用 <code>recover</code>，這個函式必須在被 <code>defer</code> 的函式中執行才有效果，若在被 <code>defer</code> 的函式外執行，<code>recover</code> 一定是傳回 <code>nil</code>。</p>
<p>如果有設置 <code>defer</code> 函式，在發生了 <code>panic</code> 的情況下，被 <code>defer</code> 的函式一定會被執行，若當中執行了 <code>recover</code>，那麼 <code>panic</code> 就會被捕捉並作為 <code>recover</code> 的傳回值，那麼 <code>panic</code> 就不會一路往回傳播，除非你又呼叫了 <code>panic</code>。</p>
<p>因此，雖然 Go 語言中沒有例外處理機制，也可使用 <code>defer</code>、<code>panic</code> 與 <code>recover</code> 來進行類似的錯誤處理。例如，將上頭的範例，再修改為：</p>
<pre><code class="language-prettyprint">package main

import (
    "fmt"
    "os"
)

func check(err error) {
    if err != nil {
        panic(err)
    }
}

func main() {
    f, err := os.Open("/tmp/dat")
    check(err)

    defer func() {
        if err := recover(); err != nil {
            fmt.Println(err) // 這已經是頂層的 UI 介面了，想以自己的方式呈現錯誤
        }

        if f != nil {
            if err := f.Close(); err != nil {
                panic(err) // 示範再拋出 panic
            }
        }
    }()

    b1 := make([]byte, 5)
    n1, err := f.Read(b1)
    check(err)

    fmt.Printf("%d bytes: %s\n", n1, string(b1))
}
</code></pre>
<p>在這個例子中，假設已經是最頂層的 UI 介面了，因此使用 <code>recover</code> 嘗試捕捉 <code>panic</code>，並以自己的方式呈現錯誤，附帶一題的是，關閉檔案也有可能發生錯誤，程式中也檢查了 <code>f.Close()</code>，視需求而定，你可以像這邊重新拋出 <code>panic</code>，或者也可以單純地設計一個 UI 介面來呈現錯誤。</p>
<p>什麼時候該用 <code>error</code>？什麼時候該用 <code>panic</code>？在 Go 的慣例中，鼓勵你使用 <code>error</code>，明確地進行錯誤檢查，然而，就如方才所言，巢狀且深層的呼叫時，使用 <code>panic</code> 會比較便於傳播錯誤，就 Go 的慣例來說，是以套件為界限，於套件之中，必要時可以使用 <code>panic</code>，而套件公開的函式，建議以 <code>error</code> 來回報錯誤，若套件公開的函式可能會收到 <code>panic</code>，建議使用 <code>recover</code> 捕捉，並轉換為 <code>error</code>。</p>
<div class="ad336-280" style="text-align: center;">
</div>
<div class="recommend" style="text-align: center;">
<hr />
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><div id="main" role="main" style="height: auto !important;">
<div class="header">
<h1 id="結構入門"><a class="header" href="#結構入門">結構入門</a></h1>
</div>
<p>有些資料會有相關性，例如，一個 XY 平面上的點可以使用 (x, y) 座標來表示；名稱、郵件位址、電話可能代表著一張名片上的資訊。將相關聯的資料組織在一起，對於資料本身的可用性或者是程式碼的可讀性，都會有所幫助。</p>
<h1 id="struct-組織資料"><a class="header" href="#struct-組織資料">struct 組織資料</a></h1>
<p>Go 語言中有 <code>struct</code>，可以用來將相關的資料組織在一起，如果你學過 C 語言，這對你應該不陌生。舉個例子來說，相對於個別地存取 <code>x</code>、<code>y</code> 變數：</p>
<pre><code class="language-prettyprint">package main

import "fmt"

func main() {
    x := 10
    y := 20
    fmt.Printf("{%d %d}\n", x, y) // {10 20}

    x := 20
    y := 30
    fmt.Printf("{%d %d}\n", x, y) // {20 30}
}
</code></pre>
<div class="google-auto-placed" style="width: 100%; height: auto; clear: both; text-align: center;">
</div>
<p>若 <code>x</code> 與 <code>y</code> 變數，相當於 XY 平面上的 (x, y) 座標，那麼將之組織在一起同時存取會比較好：</p>
<pre><code class="language-prettyprint">package main

import "fmt"

func main() {
    point := struct{ x, y int }{10, 20}
    fmt.Printf("{%d %d}\n", point.x, point.y) // {10 20}

    point.x = 20
    point.y = 30

    fmt.Printf("{%d %d}\n", point.x, point.y) // {20 30}
}
</code></pre>
<p>實際上，<code>fmt.Println</code> 可以直接處理 <code>struct</code>，因此，上面的例子，可以直接使用 <code>fmt.Println(point)</code> 來得到相同的顯示結果。</p>
<div class="google-auto-placed" style="width: 100%; height: auto; clear: both; text-align: center;">
</div>
<p>在上面的例子中，<code>struct</code> 定義了一個結構，當中包括了 <code>x</code> 與 <code>y</code> 兩個值域（field），接著馬上用它來建立了一個實例，依順序指定了 <code>x</code> 與 <code>y</code> 的值是 <code>10</code> 與 <code>20</code>，可以看到，想要存取結構的值域，可以運過點運算子（<code>.</code>）。</p>
<h1 id="基於結構定義新型態"><a class="header" href="#基於結構定義新型態">基於結構定義新型態</a></h1>
<p>上面的例子中，建立了一個匿名型態的結構，你可以使用 <code>type</code> 基於 <code>struct</code> 來定義新型態，例如：</p>
<pre><code class="language-prettyprint">package main

import "fmt"

type Point struct {
    X, Y int
}

func main() {
    point1 := Point{10, 20}
    fmt.Println(point1) // {10 20}

    point2 := Point{Y: 20, X: 30}
    fmt.Println(point2) // {30 20}
} 
</code></pre>
<p>在上面基於結構定義了新型態 <code>Point</code>，留意到名稱開頭的大小寫，若是大寫的話，就可以在其他套件中存取，這點對於結構的值域也是成立，大寫名稱的值域，才可以在其他套件中存取。在範例中也可以看到，建立並指定結構的值域時，可以直接指定值域名稱，而不一定要按照定義時的順序。</p>
<div class="google-auto-placed" style="width: 100%; height: auto; clear: both; text-align: center;">
</div>
<p>如果一開始不知道結構的值域數值為何，可以使用 <code>var</code> 宣告即可，那麼值域會依型態而有適當的預設值。例如：</p>
<pre><code class="language-prettyprint">package main

import "fmt"

type Point struct {
    X, Y int
}

func main() {  
    var point Point
    fmt.Println(point)      // {0 0}           
}
</code></pre>
<p><code>point</code> 並不是參考，<code>point</code> 的位置開始，有一片可以儲存結構的空間，可以使用 <code>&amp;</code> 來取得 <code>point</code> 的位址值，<code>point</code> 的位址值無法改變。</p>
<h1 id="結構與指標"><a class="header" href="#結構與指標">結構與指標</a></h1>
<p>如果你建立了一個結構的實例，並將之指定給另一個結構變數，那麼會進行值域的複製。例如：</p>
<pre><code class="language-prettyprint">package main

import "fmt"

type Point struct {
    X, Y int
}

func main() {  
    point1 := Point{X: 10, Y: 20}
    point2 := point1

    point1.X = 20

    fmt.Println(point1)  // {20, 20}
    fmt.Println(point2)  // {10 20}
}
</code></pre>
<div class="google-auto-placed" style="width: 100%; height: auto; clear: both; text-align: center;">
</div>
<p>這對於函式的參數傳遞也是一樣的：</p>
<pre><code class="language-prettyprint">package main

import "fmt"

type Point struct {
    X, Y int
}

func changeX(point Point) {
    point.X = 20
    fmt.Println(point)
}

func main() {
    point := Point{X: 10, Y: 20}

    changeX(point)     // {20 20}
    fmt.Println(point) // {10 20}
}
</code></pre>
<p><code>point</code> 的位置開始儲存了結構，可以對 <code>point</code> 使用 <code>&amp;</code> 取值，將位址值指定給指標，因此若指定或傳遞結構時，不是想要複製值域，可以使用指標。例如：</p>
<pre><code class="language-prettyprint">package main

import "fmt"

type Point struct {
    X, Y int
}

func main() {
    point1 := Point{X: 10, Y: 20}
    point2 := &amp;point1

    point1.X = 20

    fmt.Println(point1) // {20, 20}
    fmt.Println(point2) // &amp;{20 20}
}
</code></pre>
<p>注意到 <code>point2 := &amp;point1</code> 多了個 <code>&amp;</code>，這取得了 <code>point1</code> 實例的指標值，並傳遞給 <code>point2</code>，<code>point2</code> 的型態是 <code>*Point</code>，也就是相當於 <code>var point2 *Point = &amp;point1</code>，因此，當你透過 <code>point1.X</code> 改變了值，透過 <code>point2</code> 就能取得對應的改變。</p>
<p>類似地，也可以在傳遞參數給函式時使用指標：</p>
<pre><code class="language-prettyprint">package main

import "fmt"

type Point struct {
    X, Y int
}

func changeX(point *Point) {
    point.X = 20
    fmt.Printf("&amp;{%d %d}\n", point.X, point.Y)
}

func main() {
    point := Point{X: 10, Y: 20}

    changeX(&amp;point)    // &amp;{20 20}
    fmt.Println(point) // {20 20}
}
</code></pre>
<p>可以看到在 Go 語言中，即使是指標，也可以直接透過點運算子來存取值域，這是 Go 提供的語法糖，<code>point.X</code> 在編譯過後，會被轉換為 <code>(*point).X</code>。</p>
<p>你也可以透過 <code>new</code> 來建立結構實例，這會傳回結構實例的位址：</p>
<pre><code class="language-prettyprint">package main

import "fmt"

type Point struct {
    X, Y int
}

func default_point() *Point {
    point := new(Point)
    point.X = 10
    point.Y = 10
    return point
}

func main() {
    point := default_point()
    fmt.Println(point) // &amp;{10 10}
}
</code></pre>
<p>在這邊，<code>point</code> 是個指標，也就是 <code>*Point</code> 型態，儲存了結構實例的位址。</p>
<p>結構的值域也可以是指標型態，也可以是結構自身型態之指標，因此可實現鏈狀參考，例如：</p>
<pre><code class="language-prettyprint">package main

import "fmt"

type Point struct {
    X, Y int
}

type Node struct {
    point *Point
    next  *Node
}

func main() {
    node := new(Node)

    node.point = &amp;Point{10, 20}
    node.next = new(Node)

    node.next.point = &amp;Point{10, 30}

    fmt.Println(node.point)      // &amp;{10 20}
    fmt.Println(node.next.point) // &amp;{10 30}
}
</code></pre>
<p><code>$T{}</code> 的寫法與 <code>new(T)</code> 是等效的，使用 <code>&amp;Point{10, 20}</code> 這類的寫法，可以同時指定結構的值域。</p>
<div class="ad336-280" style="text-align: center;">
</div>
<div class="recommend" style="text-align: center;">
<hr />
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><div id="main" role="main" style="height: auto !important;">
<div class="header">
<h1 id="結構與方法"><a class="header" href="#結構與方法">結構與方法</a></h1>
</div>
<p>在〈<a href="Struct.html">結構入門</a>〉中看過，有些資料會有相關性，相關聯的資料組織在一起，對於資料本身的可用性或者是程式碼的可讀性，都會有所幫助，實際上，有些資料與可處理它的函式也會有相關性，將相關聯的資料與函式組織在一起，對資料與函式本身的可用性或者是程式碼的可讀性，也有著極大的幫助。</p>
<h1 id="建立方法"><a class="header" href="#建立方法">建立方法</a></h1>
<p>假設可能原本有如下的程式內容，負責銀行帳戶的建立、存款與提款：</p>
<pre><code class="language-prettyprint">package main

import (
    "errors"
    "fmt"
)

type Account struct {
    id      string
    name    string
    balance float64
}

func Deposit(account *Account, amount float64) {
    if amount &lt;= 0 {
        panic("必須存入正數")
    }
    account.balance += amount
}

func Withdraw(account *Account, amount float64) error {
    if amount &gt; account.balance {
        return errors.New("餘額不足")
    }
    account.balance -= amount
    return nil
}

func String(account *Account) string {
    return fmt.Sprintf("Account{%s %s %.2f}",
        account.id, account.name, account.balance)
}

func main() {
    account := &amp;Account{"1234-5678", "Justin Lin", 1000}
    Deposit(account, 500)
    Withdraw(account, 200)
    fmt.Println(String(account)) // Account{1234-5678 Justin Lin 1300.00}
}
</code></pre>
<div class="google-auto-placed" style="width: 100%; height: auto; clear: both; text-align: center;">
</div>
<p>實際上，<code>Desposit</code>、<code>Withdraw</code>、<code>String</code> 的函式操作，都是與傳入的 <code>Account</code> 實例有關，何不將它們組織在一起呢？這樣比較容易使用些，在 Go 語言中，你可以重新修改函式如下：</p>
<pre><code class="language-prettyprint">package main

import (
    "errors"
    "fmt"
)

type Account struct {
    id      string
    name    string
    balance float64
}

func (ac *Account) Deposit(amount float64) {
    if amount &lt;= 0 {
        panic("必須存入正數")
    }
    ac.balance += amount
}

func (ac *Account) Withdraw(amount float64) error {
    if amount &gt; ac.balance {
        return errors.New("餘額不足")
    }
    ac.balance -= amount
    return nil
}

func (ac *Account) String() string {
    return fmt.Sprintf("Account{%s %s %.2f}",
        ac.id, ac.name, ac.balance)
}

func main() {
    account := &amp;Account{"1234-5678", "Justin Lin", 1000}
    account.Deposit(500)
    account.Withdraw(200)
    fmt.Println(account.String()) // Account{1234-5678 Justin Lin 1300.00}
}
</code></pre>
<p>簡單來說，只是將函式的第一個參數，移至方法名稱之前成為函式呼叫的接收者（Receiver），這麼一來，就可以使用 <code>account.Deposit(500)</code>、<code>account.Withdraw(200)</code>、<code>account.String()</code> 這樣的方式來呼叫函式，就像是物件導向程式語言中的方法（Method）。</p>
<div class="google-auto-placed" style="width: 100%; height: auto; clear: both; text-align: center;">
</div>
<p>注意到，在這邊使用的是 <code>(ac *Account)</code>，也就是指標，如果你是如下使用 <code>(ac Account)</code>：</p>
<pre><code class="language-prettyprint">func (ac Account) Deposit(amount float64) {
    if amount &lt;= 0 {
        panic("必須存入正數")
    }
    ac.balance += amount
}
</code></pre>
<p>那麼執行像是 <code>account.Deposit(500)</code>，就像是以 <code>Deposit(*account, 500)</code> 呼叫以下函式：</p>
<pre><code class="language-prettyprint">func Deposit(account Account, amount float64) {
    if amount &lt;= 0 {
        panic("必須存入正數")
    }
    account.balance += amount
}
</code></pre>
<div class="google-auto-placed" style="width: 100%; height: auto; clear: both; text-align: center;">
</div>
<p>也就是，相當於將 <code>Account</code> 實例以傳值方式複製給 <code>Deposit</code> 函式的參數。</p>
<div class="google-auto-placed" style="width: 100%; height: auto; clear: both; text-align: center;">
</div>
<p>某些程度上，可以將接收者想成是其他語言中的 <code>this</code> 或 <code>self</code>，<a href="https://github.com/golang/go/wiki/CodeReviewComments#receiver-names">Go 建議為接收者適當命名</a>，而不是用 <code>this</code>、<code>self</code> 之類的名稱。接收者並沒有文件上記載的作用，命名時不用其他參數具有一定的描述性，只要能表達程式意圖就可以了，Go 建議是個一或兩個字母的名稱（某些程度上，也可以用來與其他參數區別）。</p>
<h1 id="名稱相同的方法"><a class="header" href="#名稱相同的方法">名稱相同的方法</a></h1>
<p>之前談過，Go 語言中不允許方法重載（Overload），因此，對於以下的程式，是會發生 <code>String</code> 重複宣告的編譯錯誤：</p>
<pre><code class="language-prettyprint">package main

import "fmt"

type Account struct {
    id      string
    name    string
    balance float64
}

func String(account *Account) string {
    return fmt.Sprintf("Account{%s %s %.2f}",
        account.id, account.name, account.balance)
}

type Point struct {
    x, y int
}

func String(point *Point) string { // String redeclared in this block 的編譯錯誤
    return fmt.Sprintf("Point{%d %d}", point.x, point.y)
}

func main() {
    account := &amp;Account{"1234-5678", "Justin Lin", 1000}
    point := &amp;Point{10, 20}
    fmt.Println(account.String())
    fmt.Println(point.String())
}
</code></pre>
<p>然而，若是將函式定義為方法，就不會有這個問題，Go 可以從方法的接收者辨別，該使用哪個 <code>String</code> 方法：</p>
<pre><code class="language-prettyprint">package main

import "fmt"

type Account struct {
    id      string
    name    string
    balance float64
}

func (ac *Account) String() string {
    return fmt.Sprintf("Account{%s %s %.2f}",
        ac.id, ac.name, ac.balance)
}

type Point struct {
    x, y int
}

func (p *Point) String() string {
    return fmt.Sprintf("Point{%d %d}", p.x, p.y)
}

func main() {
    account := &amp;Account{"1234-5678", "Justin Lin", 1000}
    point := &amp;Point{10, 20}
    fmt.Println(account.String()) // Account{1234-5678 Justin Lin 1000.00}
    fmt.Println(point.String())   // Point{10 20}
}
</code></pre>
<h1 id="方法作為值"><a class="header" href="#方法作為值">方法作為值</a></h1>
<p>在 Go 語言中，函式也可以作為值傳遞，那麼就產生了一個問題，方法呢？既然方法本質上也是個函式，那麼是否也可以作為值傳遞，答案是可以的，不過，以上面的程式為例，你不能直接以 <code>String := String</code> 這樣的方式傳遞，而必須使用方法運算式（Method expression）。例如：</p>
<pre><code class="language-prettyprint">package main

import (
    "errors"
    "fmt"
)

type Account struct {
    id      string
    name    string
    balance float64
}

func (ac *Account) Deposit(amount float64) {
    if amount &lt;= 0 {
        panic("必須存入正數")
    }
    ac.balance += amount
}

func (ac *Account) Withdraw(amount float64) error {
    if amount &gt; ac.balance {
        return errors.New("餘額不足")
    }
    ac.balance -= amount
    return nil
}

func (ac *Account) String() string {
    return fmt.Sprintf("Account{%s %s %.2f}",
        ac.id, ac.name, ac.balance)
}

func main() {
    deposit := (*Account).Deposit
    withdraw := (*Account).Withdraw
    String := (*Account).String

    account1 := &amp;Account{"1234-5678", "Justin Lin", 1000}
    deposit(account1, 500)
    withdraw(account1, 200)
    fmt.Println(String(account1)) // Account{1234-5678 Justin Lin 1300.00}

    account2 := &amp;Account{"5678-1234", "Monica Huang", 500}
    deposit(account2, 250)
    withdraw(account2, 150)
    fmt.Println(String(account2)) // Account{5678-1234 Monica Huang 600.00}
}
</code></pre>
<p>可以看到，這樣取得的函式，就像是本文一開始的範例那樣，你可以傳入任何的 <code>Account</code> 實例。另一個取得方法的方式是方法值（Method value），這會保有取得方法當時的接收者：</p>
<pre><code class="language-prettyprint">package main

import (
    "errors"
    "fmt"
)

type Account struct {
    id      string
    name    string
    balance float64
}

func (ac *Account) Deposit(amount float64) {
    if amount &lt;= 0 {
        panic("必須存入正數")
    }
    ac.balance += amount
}

func (ac *Account) Withdraw(amount float64) error {
    if amount &gt; ac.balance {
        return errors.New("餘額不足")
    }
    ac.balance -= amount
    return nil
}

func (ac *Account) String() string {
    return fmt.Sprintf("Account{%s %s %.2f}",
        ac.id, ac.name, ac.balance)
}

func main() {
    account1 := &amp;Account{"1234-5678", "Justin Lin", 1000}
    acct1Deposit := account1.Deposit
    acct1Withdraw := account1.Withdraw
    acct1String := account1.String

    acct1Deposit(500)
    acct1Withdraw(200)
    fmt.Println(acct1String()) // Account{1234-5678 Justin Lin 1300.00}

    account2 := &amp;Account{"5678-1234", "Monica Huang", 500}
    acct2Deposit := account2.Deposit
    acct2Withdraw := account2.Withdraw
    acct2String := account2.String

    acct2Deposit(250)
    acct2Withdraw(150)
    fmt.Println(acct2String()) // Account{5678-1234 Monica Huang 600.00}
}
</code></pre>
<h1 id="值都能有方法"><a class="header" href="#值都能有方法">值都能有方法</a></h1>
<p>實際上，不只是結構的實例可以定義方法，在 Go 語言中，只要是值，就可以定義方法，條件是必須是定義的型態（defined type），具體而言，就是使用 <code>type</code> 定義的新型態。</p>
<p>例如，以下的範例為 <code>[]int</code> 定義了一個新的型態名稱，並定義了一個 <code>ForEach</code> 方法：</p>
<pre><code class="language-prettyprint">package main

import "fmt"

type IntList []int
type Funcint func(int)

func (lt IntList) ForEach(f Funcint) {
    for _, ele := range lt {
        f(ele)
    }
}

func main() {
    var lt IntList = []int{10, 20, 30, 40, 50}
    lt.ForEach(func(ele int) {
        fmt.Println(ele)
    })
}
</code></pre>
<p>這個範例會顯示 10 到 50 作為結果，必須留意的是，<code>type</code> 定義了新型態 <code>Funcint</code>，因為 <code>ForEach</code> 是針對 <code>Funcint</code> 定義，而不是針對 <code>[]int</code>，因此底下是行不通的：</p>
<pre><code class="language-prettyprint">lt2 := []int {10, 20, 30, 40, 50}

// lt2.ForEach undefined (type []int has no field or method ForEach)
lt2.ForEach(func(ele int) {
    fmt.Println(ele)
})
</code></pre>
<p>編譯器認為 <code>[]int</code> 並沒有定義 <code>ForEach</code>，因此發生錯誤，想要通過編譯的話，可以進行型態轉換：</p>
<pre><code class="language-prettyprint">lt2 := IntList([]int {10, 20, 30, 40, 50})
lt2.ForEach(func(ele int) {
    fmt.Println(ele)
})
</code></pre>
<p>你甚至可以基於 <code>int</code> 等基本型態定義方法，同樣地，必須定義一個新的型態名稱：</p>
<pre><code class="language-prettyprint">package main

import (
    "fmt"
)

type Int int
type FuncInt func(Int)

func (n Int) Times(f FuncInt) {
    if n &lt; 0 {
        panic("必須是正數")
    }

    var i Int
    for i = 0; i &lt; n; i++ {
        f(i)
    }
}

func main() {
    var x Int = 10
    x.Times(func(n Int) {
        fmt.Println(n)
    })
}
</code></pre>
<p>像這樣基於某個基本型態定義新型態，並為其定義更多高階特性，在 Go 的領域是常見的做法。這個範例會顯示 0 到 9，看起來就像是指定函式，要求執行 x 次吧！…XD</p>
<h1 id="nil-接收者"><a class="header" href="#nil-接收者">nil 接收者</a></h1>
<p>在 Go 中，接收者可以是 <code>nil</code>，這讓你有機會在方法中處理接收者為 <code>nil</code> 的情況，例如：</p>
<pre><code class="language-prettyprint">package main

import "fmt"

type Account struct {
    id      string
    name    string
    balance float64
}

func (ac *Account) String() string {
    if ac == nil {
        return "&lt;nil&gt;"
    }
    return fmt.Sprintf("Account{%s %s %.2f}",
        ac.id, ac.name, ac.balance)
}

func findById(id string) *Account {
    accts := []*Account{&amp;Account{"123", "Justin Lin", 10000}, &amp;Account{"456", "Monica", 10000}}
    for i := 0; i &lt; len(accts); i++ {
        if accts[i].id == id {
            return accts[i]
        }
    }
    return nil
}

func main() {
    fmt.Println(findById("123").String())
    fmt.Println(findById("789").String())
}
</code></pre>
<p>如果是其他語言，例如 Java 的話，在 <code>findById("789").String()</code> 的地方會 <code>NullPointerException</code>，不過在 Go 中，可以針對接收者是否為 <code>nil</code>，來決定如何處理，例如這邊就實作了 nil safety 的概念。</p>
<h1 id="模擬建構式初始式"><a class="header" href="#模擬建構式初始式">模擬建構式、初始式</a></h1>
<p>Go 沒有物件導向語言中建構式或初始式之類的概念，然而可以自行模擬，例如在 <a href="https://golang.org/pkg/container/list/">container/list</a> 的<a href="https://golang.org/src/container/list/list.go">原始碼</a>可以看到 <code>New</code> 作為一個工廠函式，用來建立新的 <code>List</code>，初始的流程寫在 <code>Init</code> 方法之中：</p>
<pre><code class="language-prettyprint">...
// Init initializes or clears list l.
func (l *List) Init() *List {
    l.root.next = &amp;l.root
    l.root.prev = &amp;l.root
    l.len = 0
    return l
}

// New returns an initialized list.
func New() *List { return new(List).Init() }
</code></pre>
<div class="ad336-280" style="text-align: center;">
</div>
<div class="recommend" style="text-align: center;">
<hr />
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><div id="main" role="main" style="height: auto !important;">
<div class="header">
<h1 id="結構組合"><a class="header" href="#結構組合">結構組合</a></h1>
</div>
<p>結構本身用來組織相關資料，可以將處理結構的相關函式定義為方法，類似物件導向程式語言中，使用類別定義值域與方法，那麼繼承呢？Go 語言並非以物件導向為主要典範的語言，沒有繼承的概念，不過可以使用組合代替繼承。</p>
<h1 id="在組告之前"><a class="header" href="#在組告之前">在組告之前</a></h1>
<p>在〈<a href="http://openhome.cc/Gossip/Go/Method.html">結構與方法</a>〉中使用 <code>struct</code> 定義了 <code>Account</code>，如果今天你想定義一個支票帳戶，方式之一是…</p>
<pre><code class="language-prettyprint">type CheckingAccount struct {
    id string
    name string
    balance float64
    overdraftlimit float64
}
</code></pre>
<div class="google-auto-placed" style="width: 100%; height: auto; clear: both; text-align: center;">
</div>
<p>這是個很尋常的作法，也許你想將 <code>id</code>、<code>name</code> 與 <code>balance</code> 組織在一起：</p>
<pre><code class="language-prettyprint">package main

import "fmt"

type CheckingAccount struct {
    account struct {
        id      string
        name    string
        balance float64
    }
    overdraftlimit float64
}

func main() {
    checking := CheckingAccount{}
    checking.account = struct {
        id      string
        name    string
        balance float64
    }{"1234-5678", "Justin Lin", 1000}
    checking.overdraftlimit = 30000

    fmt.Println(checking)                // {{1234-5678 Justin Lin 1000} 30000}
    fmt.Println(checking.account)        // {1234-5678 Justin Lin 1000}
    fmt.Println(checking.account.name)   // Justin Lin
    fmt.Println(checking.overdraftlimit) // 30000
}
</code></pre>
<p>這是一種方式，不過使用起來麻煩，或許你可以這麼做：</p>
<pre><code class="language-prettyprint">package main

import "fmt"

type Account struct {
    id      string
    name    string
    balance float64
}

type CheckingAccount struct {
    account        Account
    overdraftlimit float64
}

func main() {
    checking := CheckingAccount{Account{"1234-5678", "Justin Lin", 1000}, 30000}

    fmt.Println(checking)                // {{1234-5678 Justin Lin 1000} 30000}
    fmt.Println(checking.account)        // {1234-5678 Justin Lin 1000}
    fmt.Println(checking.account.name)   // Justin Lin
    fmt.Println(checking.overdraftlimit) // 300000
}
</code></pre>
<div class="google-auto-placed" style="width: 100%; height: auto; clear: both; text-align: center;">
</div>
<p>看來還不錯，不過，如果想要 <code>fmt.Println(checking.name)</code> 就能取得名稱的話，這種寫法行不通！</p>
<h1 id="結構值域的查找"><a class="header" href="#結構值域的查找">結構值域的查找</a></h1>
<p>在定義結構時，可以將另一已定義的結構直接內嵌：</p>
<pre><code class="language-prettyprint">package main

import "fmt"

type Account struct {
    id      string
    name    string
    balance float64
}

type CheckingAccount struct {
    Account
    overdraftlimit float64
}

func main() {
    account := CheckingAccount{Account{"1234-5678", "Justin Lin", 1000}, 30000}

    fmt.Println(account)                // {{1234-5678 Justin Lin 1000} 30000}
    fmt.Println(account.id)             // 1234-5678
    fmt.Println(account.name)           // Justin
    fmt.Println(account.balance)        // 1000
    fmt.Println(account.overdraftlimit) // 30000
}
</code></pre>
<p>這稱為型態內嵌（type embedding），<code>Account</code> 被稱為 <code>CheckingAccount</code> 的內部型態，反之，<code>CheckingAccount</code> 是 <code>Account</code> 的外部型態，雖然是透過 <code>account.id</code>、<code>account.name</code>、<code>account.balance</code> 來存取，不過內部型態提昇，令內部型態定義的值域為可見。</p>
<div class="google-auto-placed" style="width: 100%; height: auto; clear: both; text-align: center;">
</div>
<p>那麼，如果想要明確地透過 <code>Account</code> 的結構來存取呢？也是可以的：</p>
<pre><code class="language-prettyprint">package main

import "fmt"

type Account struct {
    id      string
    name    string
    balance float64
}

type CheckingAccount struct {
    Account
    overdraftlimit float64
}

func main() {
    account := CheckingAccount{Account{"1234-5678", "Justin Lin", 1000}, 30000}

    fmt.Println(account)                 // {{1234-5678 Justin Lin 1000} 30000}
    fmt.Println(account.Account.id)      // 1234-5678
    fmt.Println(account.Account.name)    // Justin
    fmt.Println(account.Account.balance) // 1000
    fmt.Println(account.overdraftlimit)  // 30000
}
</code></pre>
<p>雖然內部型態會提昇，然而，若外部型態中定義了同名值域，就會直接取得外部型態的值域，因此，如果 <code>CheckingAccount</code> 定義了相同的值域 <code>balance</code>，如果透過 <code>account.balance</code>，結果會是找到 <code>CheckingAccount</code> 定義的 <code>balance</code>，如果想明確找到 <code>Account</code> 的 <code>balance</code>，可以指定 <code>Account</code> 作為前置：</p>
<pre><code class="language-prettyprint">package main

import "fmt"

type Account struct {
    id      string
    name    string
    balance float64
}

type CheckingAccount struct {
    Account
    balance        float64
    overdraftlimit float64
}

func main() {
    account := CheckingAccount{Account{"1234-5678", "Justin Lin", 1000}, 2000, 30000}

    fmt.Println(account.balance)         // 2000
    fmt.Println(account.Account.balance) // 1000
}
</code></pre>
<p>無論是結構值域或是方法，若來自兩個結構的值域或方法產生了同名衝突，Go 會有 ambiguous selector 的錯誤提示，此時你必須明確指定結構名稱，指定使用來自哪個結構的值域或方法。</p>
<h1 id="方法的查找"><a class="header" href="#方法的查找">方法的查找</a></h1>
<div class="google-auto-placed" style="width: 100%; height: auto; clear: both; text-align: center;">
</div>
<p>如果內部型態原本定義了方法，這些方法也是查找時的對象：</p>
<pre><code class="language-prettyprint">package main

import (
    "errors"
    "fmt"
)

type Account struct {
    id      string
    name    string
    balance float64
}

func (ac *Account) Deposit(amount float64) {
    if amount &lt;= 0 {
        panic("必須存入正數")
    }
    ac.balance += amount
}

func (ac *Account) Withdraw(amount float64) error {
    if amount &gt; ac.balance {
        return errors.New("餘額不足")
    }
    ac.balance -= amount
    return nil
}

type CheckingAccount struct {
    Account
    overdraftlimit float64
}

func main() {
    account := CheckingAccount{Account{"1234-5678", "Justin Lin", 1000}, 30000}
    account.Deposit(2000)
    account.Withdraw(500)
    fmt.Println(account) // {{1234-5678 Justin Lin 2500} 30000}
}
</code></pre>
<p>類似地，若外部型態中定義了同名的方法，那麼就會使用該方法，這類似重新定義（Override）的概念：</p>
<pre><code class="language-prettyprint">package main

import (
    "errors"
    "fmt"
)

type Account struct {
    id      string
    name    string
    balance float64
}

func (ac *Account) Deposit(amount float64) {
    if amount &lt;= 0 {
        panic("必須存入正數")
    }
    ac.balance += amount
}

func (ac *Account) Withdraw(amount float64) error {
    if amount &gt; ac.balance {
        return errors.New("餘額不足")
    }
    ac.balance -= amount
    return nil
}

type CheckingAccount struct {
    Account
    overdraftlimit float64
}

func (ac *CheckingAccount) Withdraw(amount float64) error {
    if amount &gt; ac.balance+ac.overdraftlimit {
        return errors.New("超出信用額度")
    }
    ac.balance -= amount
    return nil
}

func main() {
    account := CheckingAccount{Account{"1234-5678", "Justin Lin", 1000}, 30000}
    account.Deposit(2000)
    if err := account.Withdraw(50000); err != nil {
        fmt.Println(err)
    } else {
        fmt.Println(account)
    }
}
</code></pre>
<p>在上面的範例中，會顯示「超出信用額度」的訊息，拿掉 <code>func (account *CheckingAccount) Withdraw(amount float64)</code> 該函式的定義，則會顯示「餘額不足」的訊息。</p>
<p>如果想指定使用 <code>Account</code> 的 <code>Withdraw</code> 函式，也還是可以的：</p>
<pre><code class="language-prettyprint">func main() {
    account := CheckingAccount{Account{"1234-5678", "Justin Lin", 1000}, 30000}
    account.Deposit(2000)
    if err := account.Account.Withdraw(50000); err != nil {
        fmt.Println(err)
    } else {
        fmt.Println(account)
    }
}
</code></pre>
<p>雖然可以實現方法重新定義的概念，不過，單純只是如上定義的話，並不支援多型的概念，因為一開始這麼指定就會出錯了：</p>
<pre><code class="language-prettyprint">// cannot use CheckingAccount literal (type CheckingAccount) as type Account in assignment
var account Account = CheckingAccount{Account{"1234-5678", "Justin Lin", 1000}, 30000}
</code></pre>
<p>若想實作出多型的概念，必須使用 <code>interface</code>，這在之後的文件會加以說明。</p>
<div class="ad336-280" style="text-align: center;">
</div>
<div class="recommend" style="text-align: center;">
<hr />
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><div id="main" role="main" style="height: auto !important;">
<div class="header">
<h1 id="介面入門"><a class="header" href="#介面入門">介面入門</a></h1>
</div>
<p>在〈<a href="StructComposition.html">結構組合</a>〉的最後討論到了多型，倘若現在需要有個函式，可以接受 <code>Account</code> 與 <code>CheckingAccount</code> 實例，或者是有個陣列或 slice，可以收集 <code>Account</code> 與 <code>CheckingAccount</code>實例，那該怎麼辦呢？</p>
<h1 id="介面定義行為"><a class="header" href="#介面定義行為">介面定義行為</a></h1>
<p>在 Go 語言中，可以使用 <code>interface</code> 定義行為，舉例來說，若現在想要定義儲蓄的行為，可以如下：</p>
<pre><code class="language-prettyprint">type Savings interface {
    Deposit(amount float64)
    Withdraw(amount float64) error
}
</code></pre>
<div class="google-auto-placed" style="width: 100%; height: auto; clear: both; text-align: center;">
</div>
<p>注意，不必使用 <code>func</code> 關鍵字，也不用宣告接受者型態，只需要定義行為的名稱、參數與傳回值。接著該怎麼實現這個介面呢？實際上，就〈<a href="StructComposition.html">結構組合</a>〉，已經實現了這個介面，也就是說，結構上不用任何關鍵字，只要有函式實現這兩個行為就可以了。</p>
<p>因此，現在可以寫個函式，同時接受 <code>Account</code> 與 <code>CheckingAccount</code> 實例，在提款後顯示餘額：</p>
<pre><code class="language-prettyprint">package main

import (
    "errors"
    "fmt"
)

type Savings interface {
    Deposit(amount float64)
    Withdraw(amount float64) error
}

type Account struct {
    id      string
    name    string
    balance float64
}

func (ac *Account) Deposit(amount float64) {
    if amount &lt;= 0 {
        panic("必須存入正數")
    }
    ac.balance += amount
}

func (ac *Account) Withdraw(amount float64) error {
    if amount &gt; ac.balance {
        return errors.New("餘額不足")
    }
    ac.balance -= amount
    return nil
}

type CheckingAccount struct {
    Account
    overdraftlimit float64
}

func (ac *CheckingAccount) Withdraw(amount float64) error {
    if amount &gt; ac.balance+ac.overdraftlimit {
        return errors.New("超出信用額度")
    }
    ac.balance -= amount
    return nil
}

func Withdraw(savings Savings) {
    if err := savings.Withdraw(500); err != nil {
        fmt.Println(err)
    } else {
        fmt.Println(savings)
    }
}

func main() {
    account1 := Account{"1234-5678", "Justin Lin", 1000}
    account2 := CheckingAccount{Account{"1234-5678", "Justin Lin", 1000}, 30000}
    Withdraw(&amp;account1) // 顯示 &amp;{1234-5678 Justin Lin 500}
    Withdraw(&amp;account2) // 顯示 &amp;{{1234-5678 Justin Lin 500} 30000}
}
</code></pre>
<div class="google-auto-placed" style="width: 100%; height: auto; clear: both; text-align: center;">
</div>
<p>雖然沒有定義接收者為 <code>*CheckingAccount</code> 的 <code>Deposit</code> 方法，然而，作為內部型態的 <code>Account</code> 有定義 <code>Deposit</code>（並且沒有使用到 <code>CheckingAccount</code> 定義的值域），這個實現被提昇至外部型態，也就滿足了 <code>Savings</code> 要求的行為規範。</p>
<p>注意！由於在實作 <code>Withdraw</code> 與 <code>Deposit</code> 方法時，都是用指標 <code>(ac *Account)</code> 或 <code>(ac *CheckingAccount)</code> 宣告了接受者型態，因此傳遞實例給 <code>func Withdraw(savings Savings)</code> 時，也就必須傳遞指標。</p>
<p>如果在實作<code>Withdraw</code> 與 <code>Deposit</code> 方法時，是使用 <code>(ac Account)</code> 或 <code>(ac CheckingAccount)</code> 宣告了接受者型態，那麼傳遞實例給接受 <code>Savings</code> 的函式時，就可以不用取指標，例如：</p>
<pre><code class="language-prettyprint">package main

import (
    "errors"
    "fmt"
)

type Savings interface {
    Deposit(amount float64)
    Withdraw(amount float64) error
}

type Account struct {
    id      string
    name    string
    balance float64
}

func (ac Account) Deposit(amount float64) {
    if amount &lt;= 0 {
        panic("必須存入正數")
    }
    ac.balance += amount
}

func (ac Account) Withdraw(amount float64) error {
    if amount &gt; ac.balance {
        return errors.New("餘額不足")
    }
    ac.balance -= amount
    return nil
}

type CheckingAccount struct {
    Account
    overdraftlimit float64
}

func (ac CheckingAccount) Withdraw(amount float64) error {
    if amount &gt; ac.balance+ac.overdraftlimit {
        return errors.New("超出信用額度")
    }
    ac.balance -= amount
    return nil
}

func Withdraw(savings Savings) {
    if err := savings.Withdraw(500); err != nil {
        fmt.Println(err)
    } else {
        fmt.Println(savings)
    }
}

func main() {
    account1 := Account{"1234-5678", "Justin Lin", 1000}
    account2 := CheckingAccount{Account{"1234-5678", "Justin Lin", 1000}, 30000}
    Withdraw(account1) // 顯示 {1234-5678 Justin Lin 1000}
    Withdraw(account2) // 顯示 {{1234-5678 Justin Lin 1000} 30000}
}
</code></pre>
<div class="google-auto-placed" style="width: 100%; height: auto; clear: both; text-align: center;">
</div>
<p>當然，就這個例子來說，結果並不是正確的，就算改成 <code>Withdraw(&amp;account1)</code> 與 <code>&amp;Withdraw(account2)</code>，也不會是正確的結果，因為就 <code>Withdraw</code> 與 <code>Deposit</code> 的接收者來說，會是複製結構的值域，而不是修改原結構實例的值域，這純綷只是示範。</p>
<h1 id="介面實例的型態與值"><a class="header" href="#介面實例的型態與值">介面實例的型態與值</a></h1>
<p>如果你定義了一個變數：</p>
<pre><code class="language-prettyprint">var savings Savings
</code></pre>
<p>那麼 <code>savings</code> 變數儲存了什麼？技術上來說，<code>savings</code> 變數儲存兩個資訊：型態與值。就方才的<code>savings</code> 被指定為 <code>nil</code> 來說，代表著 <code>savings</code> 在底層儲存的型態為 <code>nil</code>，而值沒有指定，這樣的介面實例稱為 nil interface，因為沒有型態資訊，也就不能透過 nil interface 呼叫方法。</p>
<div class="google-auto-placed" style="width: 100%; height: auto; clear: both; text-align: center;">
</div>
<p>如果接收者是定義為 <code>(ac *Account)</code>，而且有底下的程式，那麼 <code>savings</code> 底層儲存的型態會 <code>*Account</code>，而值是 <code>Account</code> 結構實例的位址值：</p>
<pre><code class="language-prettyprint">var savings Savings = &amp;Account{"1234-5678", "Justin Lin", 1000}
</code></pre>
<p>當接收者是指標時，透過介面比對是否為 <code>nil</code> 時要留意，例如以下會是 <code>true</code>，這是因為 <code>savings</code> 在底層儲存的型態為 <code>nil</code>，而值沒有指定，介面宣告的變數只有在這個情況下，跟 <code>nil</code> 直接相等比較才會是 <code>true</code>：</p>
<pre><code class="language-prettyprint">var savings Savings = nil
fmt.Println(savings == nil)
</code></pre>
<p>然而以下會是 <code>false</code>，這是因為 <code>savings</code> 在底層儲存的型態為 <code>*Account</code>，而值是 <code>nil</code>（<br />
這時透過 <code>savings</code> 是可以呼叫方法的，接收者會是 <code>nil</code>，就看你要不要在方法中處理 <code>nil</code> 了）：</p>
<pre><code class="language-prettyprint">var acct *Account = nil
var savings Savings = acct
fmt.Println(savings == nil)
</code></pre>
<p>這是個 FAQ 了，在〈<a href="https://golang.org/doc/faq#nil_error">Why is my nil error value not equal to nil?</a>〉就提到了個例子：</p>
<pre><code class="language-prettyprint">func returnsError() error {
    var p *MyError = nil
    if bad() {
        p = ErrBad
    }
    return p
}
</code></pre>
<p>如果對 <code>returnsError</code> 傳回值進行 <code>nil</code> 比較，結果會是 <code>false</code>：</p>
<pre><code class="language-prettyprint">fmt.Println(returnsError() == nil) // false
</code></pre>
<p>因此如果傳回型態是個介面，值會是 <code>nil</code>，請記得直接傳 <code>nil</code>：</p>
<pre><code class="language-prettyprint">func returnsError() error {
    if bad() {
        return ErrBad
    }
    return nil // 直接傳 nil
}
</code></pre>
<p>如果接收者是定義為 <code>(ac Account)</code>，而你有底下的程式：</p>
<pre><code class="language-prettyprint">var savings Savings = Account{"1234-5678", "Justin Lin", 1000}
</code></pre>
<p>這時 <code>savings</code> 在底層會儲存型態 <code>Account</code>，而值為結構實例，這時透過 <code>Savings</code> 來進行實例的指定時，底層也會是結構實例的指定，因此會發生複製：</p>
<pre><code class="language-prettyprint">var savings1 Savings = Account{"1234-5678", "Justin Lin", 1000}
var savings2 Savings = savings1

savings2.name = "Monica Huang"
fmt.Println(savings.name) // Justin Lin
</code></pre>
<h1 id="異質陣列或-slice"><a class="header" href="#異質陣列或-slice">異質陣列或 slice</a></h1>
<p>Go 語言會檢查類型的實例，是否實現了介面中規範的行為，若是的話，就可以使用介面型態來接受不同型態實例的指定，因此，若要建立一個異質陣列或 slice，也是可以的：</p>
<pre><code class="language-prettyprint">package main

import (
    "errors"
    "fmt"
)

type Savings interface {
    Deposit(amount float64)
    Withdraw(amount float64) error
}

type Account struct {
    id      string
    name    string
    balance float64
}

func (ac *Account) Deposit(amount float64) {
    if amount &lt;= 0 {
        panic("必須存入正數")
    }
    ac.balance += amount
}

func (ac *Account) Withdraw(amount float64) error {
    if amount &gt; ac.balance {
        return errors.New("餘額不足")
    }
    ac.balance -= amount
    return nil
}

type CheckingAccount struct {
    Account
    overdraftlimit float64
}

func (ac *CheckingAccount) Withdraw(amount float64) error {
    if amount &gt; ac.balance+ac.overdraftlimit {
        return errors.New("超出信用額度")
    }
    ac.balance -= amount
    return nil
}

func main() {
    savingsArray := [...]Savings{
        &amp;Account{"1234-5678", "Justin Lin", 1000},
        &amp;CheckingAccount{Account{"1234-5678", "Justin Lin", 1000}, 30000},
    }

    for _, savings := range savingsArray {
        fmt.Println(savings)
    }

    savingsSlice := []Savings{
        &amp;Account{"1234-5678", "Justin Lin", 1000},
        &amp;CheckingAccount{Account{"1234-5678", "Justin Lin", 1000}, 30000},
    }

    for _, savings := range savingsSlice {
        fmt.Println(savings)
    }
}
</code></pre>
<p>在這邊雖然是以 <code>Account</code> 及 <code>CheckingAccount</code> 為例，不過，只要實現了 <code>Savings</code> 的行為，就算是一隻鴨子，也是可以的：</p>
<pre><code class="language-prettyprint">package main

import "fmt"

type Savings interface {
    Deposit(amount float64)
    Withdraw(amount float64) error
}

type Duck struct{}

func (d *Duck) Deposit(amount float64) {
    fmt.Println("我是一隻鴨子，我沒帳戶")
}

func (d *Duck) Withdraw(amount float64) error {
    fmt.Println("我是一隻鴨子，我沒錢")
    return nil
}

func main() {
    duckArray := [...]Savings{
        &amp;Duck{},
        &amp;Duck{},
    }

    for _, duck := range duckArray {
        duck.Deposit(1000)
    }

    duckSlice := []Savings{
        &amp;Duck{},
        &amp;Duck{},
    }

    for _, duck := range duckSlice {
        duck.Withdraw(500)
    }
}
</code></pre>
<h1 id="空介面"><a class="header" href="#空介面">空介面</a></h1>
<p>那麼，如果想要建立一個實例容器，可以收集各種類型的實例，要怎麼做呢？答案就是透過空介面，也就是沒有定義任何行為的 <code>interface {}</code>。</p>
<pre><code class="language-prettyprint">package main

import "fmt"

type Duck struct{}

func main() {
    instances := [](interface{}){
        &amp;Duck{},
        [...]int{1, 2, 3, 4, 5},
        map[string]int{"caterpillar": 123456, "monica": 54321},
    }

    for _, instance := range instances {
        fmt.Println(instance)
    }
}
</code></pre>
<p>如果你查看 <code>fmt.Println</code> 的文件說明，可以發現，它的參數類型就是 <code>interface {}</code>：</p>
<pre><code class="language-prettyprint">func Print(a ...interface{}) (n int, err error)
func Printf(format string, a ...interface{}) (n int, err error)
func Println(a ...interface{}) (n int, err error)
</code></pre>
<p>順便一提的是，就目前來說，在使用 <code>fmt.Println</code> 顯示結構時，都是使用預設的字串格式，如果想自訂字串格式，必須實現 <code>Stringer</code> 這個介面，這定義在 <code>fmt</code> 的 print.go 之中：</p>
<pre><code class="language-prettyprint">type Stringer interface {
        String() string
}
</code></pre>
<p>在需要字串的場合中，會呼叫 <code>String()</code> 方法。例如，若你想要帳號顯示時，可以出現 Account 或 CheckingAccount 字樣的話，可以如下實作：</p>
<pre><code class="language-prettyprint">package main

import "fmt"

type Account struct {
    id      string
    name    string
    balance float64
}

func (ac *Account) String() string {
    return fmt.Sprintf("Account(id = %s, name = %s, balance = %.2f)",
        ac.id, ac.name, ac.balance)
}

type CheckingAccount struct {
    Account
    overdraftlimit float64
}

func (ac *CheckingAccount) String() string {
    return fmt.Sprintf("CheckingAccount(id = %s, name = %s, balance = %.2f, overdraftlimit = %.2f)",
        ac.id, ac.name, ac.balance, ac.overdraftlimit)
}

func main() {
    account1 := Account{"1234-5678", "Justin Lin", 1000}
    account2 := CheckingAccount{Account{"1234-5678", "Justin Lin", 1000}, 30000}

    // 顯示 Account(id = 1234-5678, name = Justin Lin, balance = 1000.00)
    fmt.Println(&amp;account1)

    // 顯示 CheckingAccount(id = 1234-5678, name = Justin Lin, balance = 1000.00, overdraftlimit = 30000.00)
    fmt.Println(&amp;account2)
}
</code></pre>
<h1 id="實作某介面的型態有哪些"><a class="header" href="#實作某介面的型態有哪些">實作某介面的型態有哪些？</a></h1>
<p>來自 Java 之類語言的開發者，在認識 Go 的 <code>interface</code> 後可能會有些疑問，像是「如何知道某個介面的實現型態有哪些？」、「這個型態實現了哪些介面？」…並且會想在文件上尋找這類資訊，因為 Java 的文件中，會記錄某介面的實現類別有哪些。</p>
<p>這是因為 Java 中，介面型態與行為是結合在一起的。</p>
<p>在 Go 中不需要記錄這些，當開發者看到某 API 上定義可以接收某介面型態的值時，應該看看該介面定義了哪些行為，接著看看要傳入的值是否有實作這些行為，這樣就可以了，因為 Go 的介面重點是「行為」，不管 API 上定義的介面型態是什麼，只要行為符合都可以傳入。</p>
<p>也就是說 Go 中，介面型態與行為是分開的，應該重視的只有行為本身，本質上與動態定型語言中只重行為而非型態相同，因此「如何知道某個介面的實現型態有哪些？」、「這個型態實現了哪些介面？」這類問題也就不重要了！</p>
<div class="ad336-280" style="text-align: center;">
</div>
<div class="recommend" style="text-align: center;">
<hr />
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><div id="main" role="main" style="height: auto !important;">
<div class="header">
<h1 id="型態斷言"><a class="header" href="#型態斷言">型態斷言</a></h1>
</div>
<p>宣告介面時使用的名稱，只是一個方便取用及閱讀的標示，最重要的是介面中定義的行為，以及實際的接收者型態。因此，若你打算從一個介面轉換至另一個介面，只要行為符合就可以了。例如以下是可行的：</p>
<pre><code class="language-prettyprint">package main

import "fmt"

type ATester interface {
    test()
}

type BTester interface {
    test()
}

type Subject struct {
    name string
}

func (s *Subject) test() {
    fmt.Println(s)
}

func main() {
    var testerA ATester = &amp;Subject{"Test"}
    var testerB BTester = testerA
    testerA.test()
    testerB.test()
}
</code></pre>
<p>在第二個指定時，編譯器會檢查 <code>testerA</code> 的型態定義，也就是介面中，是否定義了 <code>test()</code> 行為，若是則可通過編譯，若否就編譯錯誤。例如以下的情況：</p>
<pre><code class="language-prettyprint">package main

import "fmt"

type ATester interface {
    testA()
}

type BTester interface {
    testB()
}

type Subject struct {
    name string
}

func (s *Subject) testA() {
    fmt.Println(s)
}

func (s *Subject) testB() {
    fmt.Println(s)
}

func main() {
    var testerA ATester = &amp;Subject{"Test"}
    var testerB BTester = testerA // 錯誤：ATester does not implement BTester
    testerA.testA()
    testerB.testB()
}
</code></pre>
<div class="google-auto-placed" style="width: 100%; height: auto; clear: both; text-align: center;">
</div>
<p>就算 <code>testerA</code> 儲存的結構實例，確實有實作<code>testB()</code> 這個方法，然而從編譯器的角度來看，<code>testerA</code> 的行為只有 <code>testA()</code>，而看不到它有 <code>testB()</code> 的行為，因此上面這個範例會編譯錯誤。</p>
<h1 id="comma-ok-型態斷言"><a class="header" href="#comma-ok-型態斷言">Comma-ok 型態斷言</a></h1>
<p>如果真的要通過編譯，可以使用<a href="https://golang.org/ref/spec#Type_assertions">型態斷言（Type assertion）</a>：</p>
<pre><code class="language-prettyprint">...同前…略

func main() {
    var testerA ATester = &amp;Subject{"Test"}
    var testerB BTester = testerA.(BTester) 
    testerA.testA()
    testerB.testB()
}
</code></pre>
<div class="google-auto-placed" style="width: 100%; height: auto; clear: both; text-align: center;">
</div>
<p><code>x.(T)</code> 這個語法，<code>x</code> 的型態是某介面，而 <code>T</code> 是預期的型態，或者是值實作的另一個介面名稱，在〈<a href="Interface.html">介面入門</a>〉中談過，介面底層儲存了型態與值的資訊，<code>x.(T)</code> 是在告知編譯器，在執行時期再來斷言型態，也就是執行時期再來判斷 <code>x</code> 底層儲存的值，型態是否為 <code>T</code>，若是就傳回底層儲存的值。</p>
<p>型態斷言與型態轉換不同，型態轉換是將值的型態轉換為另一型態，編譯器會檢查兩個型態的資料結構是否相同，若否會發生編譯錯誤。</p>
<p>斷言是執行時期進行的，在底下的範例中，執行時期會斷言 <code>value</code> 底層儲存的值，其型態為 <code>Duck</code>：</p>
<pre><code class="language-prettyprint">package main

import "fmt"

type Duck struct {
    name string
}

func main() {
    values := [...](interface{}){
        Duck{"Justin"},
        Duck{"Monica"},
    }

    for _, value := range values {
        duck := value.(Duck)
        fmt.Println(duck.name)
    }
}
</code></pre>
<div class="google-auto-placed" style="width: 100%; height: auto; clear: both; text-align: center;">
</div>
<p>如果 <code>value</code> 底層儲存的值，其型態為實際上不是 <code>Duck</code> 型態，那麼操作 <code>duck</code> 時會發生執行時期錯誤，為了避免這類錯誤發生，可以進行 Comma-ok 型態斷言，例如：</p>
<pre><code class="language-prettyprint">package main

import "fmt"

type Duck struct {
    name string
}

func main() {
    values := [...](interface{}){
        Duck{"Justin"},
        Duck{"Monica"},
        [...]int{1, 2, 3, 4, 5},
        map[string]int{"caterpillar": 123456, "monica": 54321},
    }

    for _, value := range values {
        if duck, ok := value.(Duck); ok {
            fmt.Println(duck.name)
        }
    }
} 
</code></pre>
<p>第一個 <code>duck</code> 變數是 <code>Duck</code> 型態，若 <code>value</code> 底層儲存的值確實是 <code>Duck</code> 型態，<code>ok</code> 變數會是 <code>true</code>，否則 <code>ok</code> 會是 <code>false</code>，因此，在上面的例子中，只會針對 <code>Duck</code> 顯示其 <code>name</code> 的值。</p>
<p>在〈<a href="Interface.html">介面入門</a>〉中談過，底下的範例會是 <code>false</code>：</p>
<pre><code class="language-prettyprint">var acct *Account = nil
var savings Savings = acct
fmt.Println(savings == nil) // false
</code></pre>
<div class="google-auto-placed" style="width: 100%; height: auto; clear: both; text-align: center;">
</div>
<p>實際上 <code>savings</code> 底層儲存的值確實是 <code>nil</code>，透過型態斷言的話可以取出。例如：</p>
<pre><code class="language-prettyprint">var acct *Account = nil
var savings Savings = acct
fmt.Println(savings.(*Account) == nil) // true
</code></pre>
<h1 id="型態-switch-測試"><a class="header" href="#型態-switch-測試">型態 switch 測試</a></h1>
<p>依照上面的說明，如果想測試多個型態，可以用多個 <code>if...else if</code>，例如：</p>
<pre><code class="language-prettyprint">package main

import "fmt"

type Duck struct {
    name string
}

func main() {
    values := [...](interface{}){
        Duck{"Justin"},
        Duck{"Monica"},
        [...]int{1, 2, 3, 4, 5},
        map[string]int{"caterpillar": 123456, "monica": 54321},
        10,
    }

    for _, value := range values {
        if duck, ok := value.(Duck); ok {
            fmt.Println(duck.name)
        } else if arr, ok := value.([5]int); ok {
            fmt.Println(arr)
        } else if passwds, ok := value.(map[string]int); ok {
            fmt.Println(passwds)
        } else if i, ok := value.(int); ok {
            fmt.Println(i)
        } else {
            fmt.Println("非預期之型態")
        }
    }
}
</code></pre>
<p>不過，針對這個情況，使用型態 <code>switch</code> 測試會更為適合：</p>
<pre><code class="language-prettyprint">package main

import "fmt"

type Duck struct {
    name string
}

func main() {
    values := [...](interface{}){
        Duck{"Justin"},
        Duck{"Monica"},
        [...]int{1, 2, 3, 4, 5},
        map[string]int{"caterpillar": 123456, "monica": 54321},
        10,
    }

    for _, value := range values {
        switch v := value.(type) {
        case Duck:
            fmt.Println(v.name)
        case [5]int:
            fmt.Println(v[0])
        case map[string]int:
            fmt.Println(v["caterpillar"])
        case int:
            fmt.Println(v)
        default:
            fmt.Println("非預期之型態")
        }
    }
}
</code></pre>
<p><code>value.(type)</code> 這樣的語法，只能用在 <code>switch</code> 之中。</p>
<p>來看個實際的應用，在 Go 的 <code>fmt</code> 中，有個 print.go 的原始碼，其中有一段是針對傳入的引數，是實作了 <code>Error</code> 介面或 <code>Stringer</code> 介面，若實作了 <code>Error</code> 介面，則呼叫其 <code>Error()</code> 方法，若實作了 <code>Stringer</code> 介面，就呼叫其 <code>String()</code> 方法：</p>
<pre><code class="language-prettyprint">720             switch v := p.arg.(type) {
721             case error:
722                 handled = true
723                 defer p.catchPanic(p.arg, verb)
724                 p.printArg(v.Error(), verb, depth)
725                 return
726 
727             case Stringer:
728                 handled = true
729                 defer p.catchPanic(p.arg, verb)
730                 p.printArg(v.String(), verb, depth)
731                 return
732             }
</code></pre>
<div class="ad336-280" style="text-align: center;">
</div>
<div class="recommend" style="text-align: center;">
<hr />
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><div id="main" role="main" style="height: auto !important;">
<div class="header">
<h1 id="介面組合"><a class="header" href="#介面組合">介面組合</a></h1>
</div>
<p>有時，可能會想要基於某個已定義的介面，並新增自己的行為，在 Go 中，這類似於結構中方法的查找，只要在定義介面時，內嵌想要的介面名稱就可以了。例如：</p>
<pre><code class="language-prettyprint">package main

import "fmt"

type ParentTester interface {
    ptest()
}

type ChildTester interface {
    ParentTester
    ctest()
}

type Subject struct {
    name string
}

func (s *Subject) ptest() {
    fmt.Printf("ptest %s\n", s)
}

func (s *Subject) ctest() {
    fmt.Printf("ctest %s\n", s)
}

func main() {
    var tester ChildTester = &amp;Subject{"Test"}
    tester.ptest()
    tester.ctest()
}
</code></pre>
<p>在上面，<code>Subject</code> 必須實作 <code>ParentTester</code> 與 <code>ChildTest</code> 中定義的全部行為，其實例才可以被指定 <code>ChildTest</code>。你也可以介面中包含多個介面：</p>
<pre><code class="language-prettyprint">package main

import "fmt"

type SuperTester interface {
    stest()
}

type ParentTester interface {
    ptest()
}

type ChildTester interface {
    SuperTester
    ParentTester
    ctest()
}

type Subject struct {
    name string
}

func (s *Subject) stest() {
    fmt.Printf("stest %s\n", s)
}

func (s *Subject) ptest() {
    fmt.Printf("ptest %s\n", s)
}

func (s *Subject) ctest() {
    fmt.Printf("ctest %s\n", s)
}

func main() {
    var tester ChildTester = &amp;Subject{"Test"}
    tester.stest()
    tester.ptest()
    tester.ctest()
}
</code></pre>
<p>如果多個介面間的行為重複定義了，就會出現 duplicate method 的錯誤。（這是個有爭議性的特性，因為許多人認為，實際上雖然在介面語法上確實重複定義了行為，然而就 Duck typing 的精神來看，結構上只要有實作行為就可以了，事實上在其他語言中，像是 Java 中，類似的情況並不會發生編譯錯誤，有關此議題，可參考 <a href="https://github.com/golang/go/issues/6977">golang/go 的 此 issue</a>）。</p>
<p>雖然說這像是介面有了繼承方面的語法，然而更精確地說，應該是行為的內嵌，因此，只要是有實現相關行為，就算沒有被包含在某個介面中，也可以做介面轉換：</p>
<pre><code class="language-prettyprint">package main

import "fmt"

type SuperTester interface {
    stest()
}

type ParentTester interface {
    ptest()
}

type ChildTester interface {
    SuperTester
    ParentTester
    ctest()
}

type Tester interface {
    stest()
    ptest()
    ctest()
}

type Subject struct {
    name string
}

func (s *Subject) stest() {
    fmt.Printf("stest %s\n", s)
}

func (s *Subject) ptest() {
    fmt.Printf("ptest %s\n", s)
}

func (s *Subject) ctest() {
    fmt.Printf("ctest %s\n", s)
}

func main() {
    var ctester ChildTester = &amp;Subject{"Test"}
    var tester Tester = ctester
    tester.stest()
    tester.ptest()
    tester.ctest()
}
</code></pre>
<p>有些文件會說，在介面有組合關係時，子介面的實例可以指定給父介面，反之就不行，這種說法不能說是錯，畢竟就上例來說，<code>ChildTester</code> 介面的實例，被指定給 <code>ParentTester</code> 介面時，從編譯器的角度來看，<code>ChildTester</code> 介面確實是有 <code>ParentTester</code> 介面的行為；反過來的話，<code>ParentTester</code> 介面被指定給 <code>ChildTester</code> 介面時，編譯器是看不到 <code>ParentTester</code> 介面上，會有 <code>ChildTester</code> 介面行為的，當然會發生錯誤。</p>
<p>更精確來說，Go 本身並非基於類別，沒有提供繼承語法，也就沒有父介面、子介面的概念，以上僅僅只是以行為的內嵌實現了繼承的概念，因而是就看不看得到相關的行為，來判斷是否可通過編譯。</p>
<div class="ad336-280" style="text-align: center;">
</div>
<div class="recommend" style="text-align: center;">
<hr />
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><div id="main" role="main" style="height: auto !important;">
<div class="header">
<h1 id="從標準輸入輸出認識-io"><a class="header" href="#從標準輸入輸出認識-io">從標準輸入、輸出認識 io</a></h1>
</div>
<p>若要輸出訊息至主控台，可以透過 <code>fmt</code> 的 <code>Print</code>、<code>Println</code>、<code>Printf</code> 等函式，如果要從主控台讀取使用者輸入，可以透過 <code>fmt</code> 的 <code>Scanf</code>、<code>Scanln</code> 等函式。例如：</p>
<pre><code class="language-prettyprint">package main

import "fmt"

func main() {
    fmt.Print("輸入名稱 年齡：")
    var name string
    var age int
    fmt.Scanf("%s %d", &amp;name, &amp;age)
    fmt.Printf("嗨！%s！今年 %d 歲了啊？", name, age)
}
</code></pre>
<p><code>%s</code>、<code>%d</code> 是格式符號，在 Go 中稱為 verb，Go 可用的 verb 可以在 <a href="https://golang.org/pkg/fmt/"><code>fmt</code></a> 套件的文件中找到。</p>
<p><code>Scanf</code> 就類似 C 語言中的 <code>scanf</code>，可以格式化地取得輸入，底下是個範例：</p>
<pre><code class="language-prettyprint">輸入名稱 年齡：Justin 45
嗨！Justin！今年 45 歲了啊？
</code></pre>
<p>在按下 Enter 鍵後，實際上還有個 CR（carriage return）字元還未掃描，如果只是要取得空白分隔的輸入，並以換行作為結束，可以使用 <code>Scanln</code>：</p>
<pre><code class="language-prettyprint">package main

import "fmt"

func main() {
    fmt.Print("輸入空白分隔的文字")
    var text1, text2 string
    fmt.Scanln(&amp;text1, &amp;text2)
    fmt.Println(text1)
    fmt.Println(text2)
}
</code></pre>
<p>如果是 <code>Scan</code> 的話，也是掃描以空白區隔的輸入，按下 Enter 鍵的 CR 字元，也會被視為空白。</p>
<p><code>Println</code>、<code>Printf</code> 會使用標準輸出（Standout），如果想使用標準錯誤（Standard err）呢？可以透過 <code>Fprint</code>、<code>Fprintln</code>、<code>Fprintf</code> 等函式，第一個引數指定 <code>os.Stderr</code>。例如：</p>
<pre><code class="language-prettyprint">package main

import (
    "fmt"
    "os"
)

func main() {
    fmt.Fprintln(os.Stderr, "輸出至標準錯誤")
}
</code></pre>
<p><code>os</code> 套件的 <code>Stderr</code> 代表標準錯誤，而 <code>Stdin</code>、<code>Stdout</code> 代表標準輸入與輸出，它們的型態是 <code>*os.File</code>，若願意的話，也可以直接操作它們，例如 <code>File</code> 定義了 <code>Read</code> 與 <code>Write</code> 方法，可以指定一個型態為 <code>byte[]</code> 的 slice，<code>Read</code> 會讀入同樣長度的資料至 slice，後者可以將同等長度的資料輸出。例如：</p>
<pre><code class="language-prettyprint">package main

import "os"

func main() {
    buf := make([]byte, 5);
    os.Stdout.Write([]byte("輸入五個數字："))
    os.Stdin.Read(buf)
    os.Stdout.Write(buf)
}   
</code></pre>
<p>實際上，<a href="https://golang.org/pkg/os/#File"><code>os.File</code></a> 可用的方法不只有 <code>Read</code>、<code>Write</code>，先留意這兩個方法的目的在於，這兩個方法分別符合 <code>io.Reader</code>、<code>io.Writer</code> 定義的行為：</p>
<pre><code class="language-prettyprint">type Reader interface {
    Read(p []byte) (n int, err error)
}

type Writer interface {
    Write(p []byte) (n int, err error)
}
</code></pre>
<p>如果察看 <code>fmt</code> 的 <code>Fprint</code>、<code>Fprintln</code>、<code>Fprintf</code> 等函式，可以發現它們第一個參數宣告的型態並不是 <code>*os.File</code>，而是 <code>io.Writer</code>：</p>
<pre><code class="language-prettyprint">func Fprint(w io.Writer, a ...interface{}) (n int, err error)
func Fprintln(w io.Writer, a ...interface{}) (n int, err error)
func Fprintf(w io.Writer, format string, a ...interface{}) (n int, err error)
</code></pre>
<p>類似地，Fscan 字樣開頭的幾個函式，第一個參數接受的是 <code>io.Reader</code>：</p>
<pre><code class="language-prettyprint">func Fscan(r io.Reader, a ...interface{}) (n int, err error)
func Fscanf(r io.Reader, format string, a ...interface{}) (n int, err error)
func Fscanln(r io.Reader, a ...interface{}) (n int, err error)
</code></pre>
<p>這表示，<code>fmt</code> 套件中這些函式，並不只能用於標準輸入、輸出或錯誤，例如，<code>strings.NewReader</code> 函式，可以指定字串，傳回 <code>*Reader</code>，這表示 <code>fmt</code> 的 <code>Fscanf</code> 等函式，可以從字串讀取輸入。例如：</p>
<pre><code class="language-prettyprint">package main

import (
    "fmt"
    "io"
    "strings"
)

func main() {
    data := `Justin 45
             Monica 42
             Irene 12`
    r := strings.NewReader(data)
    var name string
    var age int
    for {
        if _, err := fmt.Fscanln(r, &amp;name, &amp;age); err == io.EOF {
            break
        }
        fmt.Printf("%s: %d\n", name, age)
    }
}  
</code></pre>
<p><code>Fscanln</code> 會傳回掃描的筆數，如果筆數少於指定的掃描數量，<code>err</code> 會指出原因，在檔案讀取結束（End of file）時，<code>err</code> 會是 <code>io.EOF</code>，在上例中，資料來源是個格式確定的字串，因此僅簡單地判斷 <code>err</code> 是否為 <code>io.EOF</code> 來結束掃描。</p>
<p><code>os.File</code> 不過是具有 <code>io.Reader</code>、<code>io.Writer</code> 的行為罷了，<code>os.File</code> 代表檔案，也就是說 <code>Fprint</code>、<code>Fprintln</code>、<code>Fprintf</code>、<code>Fscan</code>、<code>Fscanln</code>、<code>Fscanf</code> 等函式，也可以用在檔案讀寫，其實標準輸入、輸出、錯誤等，也是被視為檔案的，這在 <code>os</code> 的 <a href="https://golang.org/src/os/file.go">file.go</a> 可以看到：</p>
<pre><code class="language-prettyprint">var (
    Stdin  = NewFile(uintptr(syscall.Stdin), "/dev/stdin")
    Stdout = NewFile(uintptr(syscall.Stdout), "/dev/stdout")
    Stderr = NewFile(uintptr(syscall.Stderr), "/dev/stderr")
)
</code></pre>
<p>因此 IO 之類的操作，在 Go 中非常靈活，一切都看 API 上可接受行為而定，不受型態之限制，這之後再從實際的例子中來談。</p>
<div class="ad336-280" style="text-align: center;">
</div>
<div class="recommend" style="text-align: center;">
<hr />
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><div id="main" role="main" style="height: auto !important;">
<div class="header">
<h1 id="ioreaderiowriter"><a class="header" href="#ioreaderiowriter">io.Reader、io.Writer</a></h1>
</div>
<p>在〈<a href="StdOutInErr.html">從標準輸入、輸出認識 io</a>〉中談到了 <code>io.Reader</code>、<code>io.Writer</code>，在 Go 中，這兩個介面抽象化了輸入、輸出，認識這兩個介面分別定義的 <code>Read</code>、<code>Write</code> 行為，是掌握 Go 中輸入、輸出的基礎。</p>
<p><code>io.Reader</code> 定義的 <code>Read</code> 行為，可以在 <a href="https://golang.org/pkg/io/#Reader"><code>type Reader</code></a> 查看：</p>
<pre><code class="language-prettyprint">type Reader interface {
    Read(p []byte) (n int, err error)
}
</code></pre>
<p>對於呼叫者來說，<code>Read</code> 會將資料讀入 <code>p</code>，並傳回讀入的位元組數 <code>n</code>，<code>n</code> 會是 0 到不大於 <code>len(p)</code> 的整數，如果 <code>n</code> 不是 0 但不足 <code>len(p)</code>，應該先處理已讀取的位元組，這時 <code>err</code> 可能不是 <code>nil</code>（例如檔案結尾，可能會傳回 <code>io.EOF</code>），無論如何，在這之後 <code>Read</code>，<code>n</code> 會是 0 而 <code>err</code> 會是 <code>io.EOF</code>。</p>
<p>例如，若要讀取一個文字檔案，其中以 UTF-8 儲存中文，可以如下：</p>
<pre><code class="language-prettyprint">package main

import (
    "fmt"
    "io"
    "os"
)

func printUTF8TC(r io.Reader) (err error) {
    var (
        buf = make([]byte, 3)
        n int
    )

    for err == nil {
        n, err = r.Read(buf)
        fmt.Print(string(buf[:n]))
    }
    if err == io.EOF {
        err = nil
    }
    return
}

func main() {
    fmt.Print("檔案來源：")
    var filename string
    fmt.Scanf("%s", &amp;filename)

    f, err := os.Open(filename)
    if err != nil {
        panic(err)
    }
    defer f.Close()

    printUTF8TC(f)
}
</code></pre>
<p><code>io.Writer</code> 定義的 <code>Write</code> 行為，可以在 <a href="https://golang.org/pkg/io/#Writer"><code>type Writer</code></a> 查看：</p>
<pre><code class="language-prettyprint">type Writer interface {
    Write(p []byte) (n int, err error)
}
</code></pre>
<p><code>Write</code> 會將 <code>p</code> 輸出並傳回實際輸出的位元組，<code>n</code> 會是 0 到不大於 <code>len(p)</code> 的整數，如果 <code>n &lt; len(p)</code>，那麼 <code>err</code> 不會是 <code>nil</code>。</p>
<p>來寫個 <code>Copy</code> 函式好了，可以將 <code>io.Reader</code> 的資料直接寫到 <code>io.Writer</code>：</p>
<pre><code class="language-prettyprint">package main

import (
    "fmt"
    "io"
    "os"
)

func write(w io.Writer, buf []byte, n int) (err error) {
    nw, ew := w.Write(buf[:n])
    if ew != nil {
        return ew
    }
    if n != nw {
        return io.ErrShortWrite
    }
    return nil
}

func Copy(w io.Writer, r io.Reader) (err error) {
    buf := make([]byte, 32 * 1024)
    for {
        nr, er := r.Read(buf)
        if nr &gt; 0 {
            err = write(w, buf, nr)
            if err != nil {
                return
            }
        }
        if er != nil {
            if er != io.EOF {
                err = er
            }
            return
        }
    }
}

func main() {
    fmt.Print("檔案來源：")
    var filename string
    fmt.Scanf("%s", &amp;filename)

    f, err := os.Open(filename)
    if err != nil {
        panic(err)
    }
    defer f.Close()

    Copy(os.Stdout, f)
}
</code></pre>
<p>在這個例子中，可以將指定的檔案讀入並顯示在主控台中，這是因為 <code>os.Stdout</code> 具有 <code>io.Writer</code> 的行為。實際上，<code>io.Copy</code> 就提供了這個功能：</p>
<pre><code class="language-prettyprint">package main

import (
    "fmt"
    "io"
    "os"
)

func main() {
    fmt.Print("檔案來源：")
    var filename string
    fmt.Scanf("%s", &amp;filename)

    f, err := os.Open(filename)
    if err != nil {
        panic(err)
    }
    defer f.Close()

    io.Copy(os.Stdout, f)
}
</code></pre>
<div class="ad336-280" style="text-align: center;">
</div>
<div class="recommend" style="text-align: center;">
<hr />
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><div id="main" role="main" style="height: auto !important;">
<div class="header">
<h1 id="bufio-套件"><a class="header" href="#bufio-套件">bufio 套件</a></h1>
</div>
<p><code>io.Reader</code>、<code>io.Writer</code> 定義了基於位元組的讀寫行為，然而許多情況下，你會想要基於字串、行來進行讀寫，這可以透過 <code>bufio</code> 套件的 <code>bufio.Reader</code>、<code>bufio.Writer</code> 等達到。</p>
<p><code>bufio.Reader</code> 可以透過 <code>NewReader</code>、<code>NewReaderSize</code> 指定 <code>io.Reader</code> 來建立實例，前者指定預設緩衝區大小 4096 位元組呼叫後者，<code>bufio.Reader</code> 在讀取來源時會從底層的 <code>io.Reader</code> 將資料讀入，在建立 <code>bufio.Reader</code> 實例之後，可以使用的方法有：</p>
<pre><code class="language-prettyprint">func (b *Reader) Buffered() int
func (b *Reader) Discard(n int) (discarded int, err error)
func (b *Reader) Peek(n int) ([]byte, error)
func (b *Reader) Read(p []byte) (n int, err error)
func (b *Reader) ReadByte() (byte, error)
func (b *Reader) ReadBytes(delim byte) ([]byte, error)
func (b *Reader) ReadLine() (line []byte, isPrefix bool, err error)
func (b *Reader) ReadRune() (r rune, size int, err error)
func (b *Reader) ReadSlice(delim byte) (line []byte, err error)
func (b *Reader) ReadString(delim byte) (string, error)
func (b *Reader) Reset(r io.Reader)
func (b *Reader) Size() int
func (b *Reader) UnreadByte() error
func (b *Reader) UnreadRune() error
func (b *Reader) WriteTo(w io.Writer) (n int64, err error)
</code></pre>
<div class="google-auto-placed" style="width: 100%; height: auto; clear: both; text-align: center;">
</div>
<p>因此對於逐行讀取一個 UTF-8 文字檔案來說，可以簡單地撰寫如下：</p>
<pre><code class="language-prettyprint">package main

import (
    "bufio"
    "os"
    "fmt"
    "io"
)

func printFile(f *os.File) (err error){
    var (
        r = bufio.NewReader(f)
        line string
    )
    for err == nil {
        line, err = r.ReadString('\n')
        fmt.Println(line)
    }
    if err == io.EOF {
        err = nil
    }
    return
}

func main() {
    var filename string
    fmt.Print("檔案名稱：")
    fmt.Scanf("%s", &amp;filename);

    f, err := os.Open(filename)
    if err != nil {
        panic(err)
    }
    defer f.Close()

    printFile(f)
}
</code></pre>
<p>如果實際上是要讀取之後寫到另一個輸出，使用 <code>WriteTo</code> 方法更為方便：</p>
<pre><code class="language-prettyprint">package main

import (
    "bufio"
    "os"
    "fmt"
)

func main() {
    var filename string
    fmt.Print("檔案名稱：")
    fmt.Scanf("%s", &amp;filename);

    f, err := os.Open(filename)
    if err != nil {
        panic(err)
    }
    defer f.Close()

    bufio.NewReader(f).WriteTo(os.Stdout)
}
</code></pre>
<p>Go 在 <code>io.WriteTo</code> 介面定義了 <code>WriteTo</code> 行為：</p>
<pre><code class="language-prettyprint">type WriterTo interface {
    WriteTo(w Writer) (n int64, err error)
}
</code></pre>
<p>實際上 <code>bufio.Reader</code> 實作了 <code>io</code> 中一些介面，<code>io.WriteTo</code> 只是其中之一；類似地，如果要建立 <code>bufio.Writer</code> 實例，可以透過 <code>NewWriter</code>、<code>NewWriterSize</code> 函式，建立之後可用的方法如下：</p>
<pre><code class="language-prettyprint">func (b *Writer) Available() int
func (b *Writer) Buffered() int
func (b *Writer) Flush() error
func (b *Writer) ReadFrom(r io.Reader) (n int64, err error)
func (b *Writer) Reset(w io.Writer)
func (b *Writer) Size() int
func (b *Writer) Write(p []byte) (nn int, err error)
func (b *Writer) WriteByte(c byte) error
func (b *Writer) WriteRune(r rune) (size int, err error)
func (b *Writer) WriteString(s string) (int, error)
</code></pre>
<p><code>bufio.Writer</code> 實作了 <code>io</code> 中一些介面，像是 <code>io.ReadFrom</code>，因此，也可以如下在標準輸出中，顯示讀入的的檔案內容：</p>
<pre><code class="language-prettyprint">package main

import (
    "bufio"
    "os"
    "fmt"
)

func main() {
    var filename string
    fmt.Print("檔案名稱：")
    fmt.Scanf("%s", &amp;filename);

    f, err := os.Open(filename)
    if err != nil {
        panic(err)
    }
    defer f.Close()

    w := bufio.NewWriter(os.Stdout)
    w.ReadFrom(f)
    w.Flush()
}
</code></pre>
<p><code>NewWriter</code> 預設的緩衝區為 4096 位元組，由於這邊使用標準輸出，在緩衝區未滿前，資料不會寫出，可以使用 <code>Flush</code> 來出清緩衝區中的資料。</p>
<p>事實上，對於需要逐行讀取的需求，使用 <code>bufio.Scanner</code> 會比較方便，可以使用 <code>NewScanner</code> 來建立實例，建立之後有以下的方法可以使用：</p>
<pre><code class="language-prettyprint">func (s *Scanner) Buffer(buf []byte, max int)
func (s *Scanner) Bytes() []byte
func (s *Scanner) Err() error
func (s *Scanner) Scan() bool
func (s *Scanner) Split(split SplitFunc)
func (s *Scanner) Text() string
</code></pre>
<p>來看看讀取文字檔案的例子：</p>
<pre><code class="language-prettyprint">package main

import (
    "bufio"
    "os"
    "fmt"
)

func main() {
    var filename string
    fmt.Print("檔案名稱：")
    fmt.Scanf("%s", &amp;filename);

    f, err := os.Open(filename)
    if err != nil {
        panic(err)
    }
    defer f.Close()

    scanner := bufio.NewScanner(f)
    for scanner.Scan() {
        fmt.Println(scanner.Text())
    }
    if err := scanner.Err(); err != nil {
        panic(err)
    }
}
</code></pre>
<div class="ad336-280" style="text-align: center;">
</div>
<div class="recommend" style="text-align: center;">
<hr />
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><div id="main" role="main" style="height: auto !important;">
<div class="header">
<h1 id="檔案操作"><a class="header" href="#檔案操作">檔案操作</a></h1>
</div>
<p>想要進行目錄、檔案等的操作，基本上就是查看 <code>os</code> 套件，可以使用的函式很多，逐一談好像也沒太大意義，基本上若對目錄、檔案以及權限等有所認識，應該查查文件、搜尋一些範例，大致就知道怎麼用吧！</p>
<p>無論如何，輸入輸出中最基本的就是檔案讀寫，至今為止看過，要開啟檔案進行讀取的話，使用的是 <code>os.Open</code> 函式，這會以唯讀方式開啟既有的檔案（否則會有 <code>PathError</code>）：</p>
<pre><code class="language-prettyprint">func Open(name string) (*File, error)
</code></pre>
<p>如果要指定讀寫方式與權限的話，要使用 <code>os.OpenFile</code>：</p>
<pre><code class="language-prettyprint">func OpenFile(name string, flag int, perm FileMode) (*File, error)
</code></pre>
<p><code>flag</code> 可以指定的常數有：</p>
<pre><code class="language-prettyprint">const (
    // 必須指定 O_RDONLY、O_WRONLY 或 O_RDWR
    O_RDONLY int = syscall.O_RDONLY // 唯讀
    O_WRONLY int = syscall.O_WRONLY // 唯寫
    O_RDWR   int = syscall.O_RDWR   // 讀寫
    // 接下來這些可以用 | 的方式附加行為
    O_APPEND int = syscall.O_APPEND // 寫入時使用附加方式
    O_CREATE int = syscall.O_CREAT  // 檔案不存在時建立新檔
    O_EXCL   int = syscall.O_EXCL   // 與 O_CREATE 併用，檔案必須不存在
    O_SYNC   int = syscall.O_SYNC   // 以同步 I/O 開啟
    O_TRUNC  int = syscall.O_TRUNC  // 檔案開啟時清空文件
)
</code></pre>
<p><code>perm</code> 的話是檔案<a href="https://en.wikipedia.org/wiki/Chmod#Octal_modes">八進位權限</a>，例如 0777；另外，還有個 <code>os.Create</code>，實現上就是使用 <code>OpenFile</code> 以 0666 的方式建立可讀寫的檔案（清空文件）：</p>
<pre><code class="language-prettyprint">func Create(name string) (*File, error) {
    return OpenFile(name, O_RDWR|O_CREATE|O_TRUNC, 0666)
}
</code></pre>
<p><code>Open</code>、<code>OpenFile</code> 或 <code>Create</code> 都會傳回 <code>*os.File</code>；另外還有個 <code>NewFile</code>，多數情況下用不到，主要是在將檔案描述（File descriptor）以 <code>*os.File</code> 來表示，例如，<code>os.Stdin</code>、<code>os.Stdout</code>、<code>os.Stderr</code>，在〈<a href="StdOutInErr.html">從標準輸入、輸出認識 io</a>〉看過它的使用：</p>
<pre><code class="language-prettyprint">var (
    Stdin  = NewFile(uintptr(syscall.Stdin), "/dev/stdin")
    Stdout = NewFile(uintptr(syscall.Stdout), "/dev/stdout")
    Stderr = NewFile(uintptr(syscall.Stderr), "/dev/stderr")
)
</code></pre>
<p><code>syscall.Stdin</code>、<code>syscall.Stdout</code>、<code>syscall.Stderr</code> 分別是標準輸入、輸出、錯誤的檔案描述，這在 <a href="https://golang.org/pkg/syscall/#pkg-variables"><code>syscall</code> 的文件</a>可以看到：</p>
<pre><code class="language-prettyprint">var (
    Stdin  = 0
    Stdout = 1
    Stderr = 2
)
</code></pre>
<p><code>os.File</code> 實作了 <code>io.Reader</code>、<code>io.Writer</code> 等行為，因此只要知道〈<a href="ReaderWriter.html">io.Reader、io.Writer</a>〉，剩下的就是查詢文件，看看有哪些方法可以使用，沒什麼特別需要示範的了，倒是若需要簡單的檔案讀寫，可以看看 <a href="https://golang.org/pkg/io/ioutil/"><code>ioutil</code> 套件</a>，其中有些簡便的函式：</p>
<pre><code class="language-prettyprint">func NopCloser(r io.Reader) io.ReadCloser
func ReadAll(r io.Reader) ([]byte, error)
func ReadDir(dirname string) ([]os.FileInfo, error)
func ReadFile(filename string) ([]byte, error)
func TempDir(dir, prefix string) (name string, err error)
func TempFile(dir, pattern string) (f *os.File, err error)
func WriteFile(filename string, data []byte, perm os.FileMode) error
</code></pre>
<p><code>ReadFile</code>、<code>WriteFile</code> 只要指定檔案名稱等，程式碼上不需要自行建立檔案、緩衝區之類的，這些函式在 <a href="https://golang.org/pkg/io/ioutil/"><code>ioutil</code> 套件</a> 的文件中，都有範例可以參考。</p>
<div class="ad336-280" style="text-align: center;">
</div>
<div class="recommend" style="text-align: center;">
<hr />
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><div id="main" role="main" style="height: auto !important;">
<div class="header">
<h1 id="err-是否-nil"><a class="header" href="#err-是否-nil">err 是否 nil？</a></h1>
</div>
<p>對於錯誤，Go 不採取例外處理機制，而是透過傳回 <code>error</code> 值來表示是否發生了什麼錯誤，最基本的做法就是：</p>
<pre><code class="language-prettyprint">if err != nil {
    // 做些什麼
}
</code></pre>
<p>然而，接觸 Go 不用多久就會發現，若要認真地檢查、處理錯誤，<code>if err != nil</code> 之類的程式碼就會到處充斥，特別是在進行 IO 之類的操作時更是如此，單純地 <code>if err != nil</code> 寫法最後會寫到懷疑人生，這麼寫真的是對的嗎？</p>
<p>這時可能會做的選擇之一是：就別檢查了吧！如果寫的是特定目的之程式、不太需要考慮太多狀況、不用考慮過多的穩固性、想要很快地寫出原型之類的，這個選擇可能是正確的，畢竟真要認真寫 Go 中的錯誤檢查，某些程度上就像 Java 中常被人嫌的受檢例外（Checked exception）一樣囉嗦，還好 Go 可以選擇不檢查…XD</p>
<p>只不過，如果想寫出較通用、具有穩固性的程式，錯誤檢查就是必需的，Go 也鼓勵開發者積極地檢查錯誤；那麼…乾脆全 <code>panic</code> 好了？</p>
<pre><code class="language-prettyprint">func check(err) {
    if err != nil {
        panic(err)
    }
}
</code></pre>
<div class="google-auto-placed" style="width: 100%; height: auto; clear: both; text-align: center;">
</div>
<p>這麼一來，遇到要檢查錯誤時，就呼叫 <code>check</code> 來檢查，這樣就能少寫些 <code>if err != nil</code> 了吧！這種做法其實並不建議，因為 <code>panic</code> 是 <code>panic</code>，<code>error</code> 是 <code>error</code>，<code>panic</code> 的場合，應該用在適用 <code>panic</code> 的場合，也就是那些實際上真的無法處理的錯誤，發生這類錯誤最重要的引發開發者恐慌，讓開發者知道要修改程式的演算，避免發生 <code>panic</code>。</p>
<p><code>panic</code> 就像 Java 中發生 <code>RuntimeException</code>，其實不建議捕捉，而是停下程式，修正演算上的錯誤。</p>
<p>不過，可以想想為什麼會有人想在發生錯誤時，一律引發 <code>panic</code>，因為可以從目前的執行處中斷，就像例外處理機制中例外發生時，後續程式碼就不會執行那樣。</p>
<p>這就是以檢查是否有錯誤的方式，沒辦法直接做到的事，因為不在檢查出錯誤的時候進行 <code>return</code>、<code>break</code> 之類的動作，程式碼就會往下執行。</p>
<p>為了能在錯誤發生時中斷流程，就有可能寫出這類的程式碼：</p>
<pre><code class="language-prettyprint">_, err = fd.Write(p0[a:b])
if err != nil {
    return err
}
_, err = fd.Write(p1[c:d])
if err != nil {
    return err
}
_, err = fd.Write(p2[e:f])
if err != nil {
    return err
}
// 諸如此類
</code></pre>
<div class="google-auto-placed" style="width: 100%; height: auto; clear: both; text-align: center;">
</div>
<p>這段程式碼摘自〈<a href="https://blog.golang.org/errors-are-values">Errors are values</a>〉，該文章中提到一個解決的方式是：</p>
<pre><code class="language-prettyprint">var err error
write := func(buf []byte) {
    if err != nil {
        return
    }
    _, err = w.Write(buf)
}
write(p0[a:b])
write(p1[c:d])
write(p2[e:f])
// 諸如此類
if err != nil {
    return err
}
</code></pre>
<div class="google-auto-placed" style="width: 100%; height: auto; clear: both; text-align: center;">
</div>
<p>這麼一來，每一次 <code>write</code> 呼叫時，就都會檢查 <code>err</code> 是否為 <code>nil</code>，如果不是 <code>nil</code> 就 <code>return</code>，實際上也就不會執行 <code>w.Write</code>，雖然程式碼上呼叫了 <code>write</code> 多次；然而，某次呼叫若發生了錯誤，後續的 <code>write</code> 並不會真正執行寫出的動作，而透過這個方式，可以將發生錯誤時要進行的動作，統整在最後檢查並執行。</p>
<p>匿名函式的方式建立了 Closure，捕捉了 <code>err</code> 變數，這麼一來就得做些迴避同名變數的問題，另外匿名函式的寫法也不是那麼簡明，因此文章中定義了：</p>
<pre><code class="language-prettyprint">type errWriter struct {
    w   io.Writer
    err error
}

func (ew *errWriter) write(buf []byte) {
    if ew.err != nil {
        return
    }
    _, ew.err = ew.w.Write(buf)
}
</code></pre>
<p>這麼一來，每個 <code>io.Writer</code> 可以有個別的 <code>err</code> 可以使用，而原本的程式就可以改寫為：</p>
<pre><code class="language-prettyprint">ew := &amp;errWriter{w: fd}
ew.write(p0[a:b])
ew.write(p1[c:d])
ew.write(p2[e:f])
// 諸如此類
if ew.err != nil {
    return ew.err
}
</code></pre>
<p>在〈<a href="bufio.html">bufio 套件</a>〉中看過的 <code>bufio.Writer</code> 就是這類的設計：</p>
<pre><code class="language-prettyprint">type Writer struct {
    err error
    buf []byte
    n   int
    wr  io.Writer
}

...略

func (b *Writer) Write(p []byte) (nn int, err error) {
    for len(p) &gt; b.Available() &amp;&amp; b.err == nil {
        var n int
        if b.Buffered() == 0 {
            // Large write, empty buffer.
            // Write directly from p to avoid copy.
            n, b.err = b.wr.Write(p)
        } else {
            n = copy(b.buf[b.n:], p)
            b.n += n
            b.Flush()
        }
        nn += n
        p = p[n:]
    }
    if b.err != nil {
        return nn, b.err
    }
    n := copy(b.buf[b.n:], p)
    b.n += n
    nn += n
    return nn, nil
}

... 略

func (b *Writer) Flush() error {
    if b.err != nil {
        return b.err
    }
    if b.n == 0 {
        return nil
    }
    n, err := b.wr.Write(b.buf[0:b.n])
    if n &lt; b.n &amp;&amp; err == nil {
        err = io.ErrShortWrite
    }
    if err != nil {
        if n &gt; 0 &amp;&amp; n &lt; b.n {
            copy(b.buf[0:b.n-n], b.buf[n:b.n])
        }
        b.n -= n
        b.err = err
        return err
    }
    b.n = 0
    return nil
}
</code></pre>
<p>在 <code>b.err</code> 不為 <code>nil</code> 的情況下，實際上不會有實際的寫出，而 <code>Flush</code> 時，若 <code>b.err</code> 不為 <code>nil</code> 就會被 <code>return</code>，因此在使用 <code>bufio.Writer</code> 時，可以如下撰寫，在最後檢查</p>
<pre><code class="language-prettyprint">b := bufio.NewWriter(fd)
b.Write(p0[a:b])
b.Write(p1[c:d])
b.Write(p2[e:f])
// 諸如此類
if b.Flush() != nil {
    return b.Flush()
}
</code></pre>
<p>這個模式可以進一步應用，例如在〈<a href="bufio.html">bufio 套件</a>〉中看過 <code>bufio.Scanner</code> 的使用，語意上比較高階：</p>
<pre><code class="language-prettyprint">scanner := bufio.NewScanner(f)
for scanner.Scan() {
    fmt.Println(scanner.Text())
}
if err := scanner.Err(); err != nil {
    panic(err)
}
</code></pre>
<p><code>scanner.Scan()</code> 傳回布林值，表示是否掃描到下一行，沒有下一行或中途發生錯誤，就會傳回 <code>false</code>；然而迴圈檢查就只在乎有沒有下一行，離開迴圈後再來檢查錯誤，兩個程式區塊各司其職。</p>
<p><code>bufio.Scanner</code> 本身的組成中有 <code>io.Reader</code> 與 <code>err</code>：</p>
<pre><code class="language-prettyprint">type Scanner struct {
    r            io.Reader 
    ...略
    err          error
    ...略
}
</code></pre>
<p>若你查看 <code>Scan</code> 方法的實作，會傳回 <code>false</code> 的情況之一，就是 <code>Scanner</code> 的 <code>err</code> 不是 <code>nil</code>：</p>
<pre><code class="language-prettyprint">    ...略
    if s.err != nil {
        // Shut it down.
        s.start = 0
        s.end = 0
        return false
    }
    ...略
</code></pre>
<p>Go 不以特定語法處理錯誤（例如 Java 使用 <code>try..catch</code>），正因為錯誤發生是傳回錯誤，也就會有許多方式可以檢查錯誤，這邊只是談到幾個可用的設計，重點在於觀察程式碼的需求，適時地重構，看看如何以設計的方式，優雅地處理錯誤，而不是避免檢查錯誤，如果一開始沒什麼方向，可以多觀察 Go 程式庫的原始碼實作中是怎麼處理錯誤的。</p>
<div class="ad336-280" style="text-align: center;">
</div>
<div class="recommend" style="text-align: center;">
<hr />
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><div id="main" role="main" style="height: auto !important;">
<div class="header">
<h1 id="錯誤的比對"><a class="header" href="#錯誤的比對">錯誤的比對</a></h1>
</div>
<p>如果函式或方法傳回錯誤，要比對的不單只是 <code>nil</code> 與否，例如，讀取檔案時，會需要判斷傳回的錯誤是否為 <code>io.EOF</code>，那麼 <code>io.EOF</code> 這些錯誤是什麼呢？在 <code>io</code> 套件的 <a href="https://golang.org/src/io/io.go">io.go</a> 原始碼中可以看到，它們就是個 <code>errors.New</code> 建出的值罷了：</p>
<pre><code class="language-prettyprint">var ErrShortWrite = errors.New("short write")
var ErrShortBuffer = errors.New("short buffer")
var EOF = errors.New("EOF")
var ErrUnexpectedEOF = errors.New("unexpected EOF")
var ErrNoProgress = errors.New("multiple Read calls return no data or error")
</code></pre>
<p>在 <code>errors</code> 套件的 <a href="https://golang.org/src/errors/errors.go">errors.go</a> 可以看到，<code>errors.New</code> 建立的是個結構值，只有一個 <code>string</code> 欄位，並且實作了 <code>Error</code> 方法：</p>
<pre><code class="language-prettyprint">func New(text string) error {
    return &amp;errorString{text}
}

// errorString is a trivial implementation of error.
type errorString struct {
    s string
}

func (e *errorString) Error() string {
    return e.s
}
</code></pre>
<p>字串是可以比較的（Comparable），<code>errorString</code> 結構也是個可以比較的，因此可以直接使用 <code>==</code> 來比較錯誤是否為 <code>io.EOF</code> 等，在開發自己的應用程式或程式庫時，對於通用、簡單的錯誤，也可以如上定義。</p>
<p><code>errors.New</code> 建立的實例，能攜帶的資訊就只是字串罷了，如果錯誤發生時，需要傳遞更多的環境資訊，怎麼辦呢？</p>
<p>在方法宣告傳回錯誤時的 <code>error</code> 其實是個內建的介面，定義的正是 <code>Error</code> 方法：</p>
<pre><code class="language-prettyprint">type error interface {
    Error() string
}
</code></pre>
<p>也就是說，只要有實作 <code>Error</code> 方法，都可以作為 <code>error</code> 實例傳回，例如，<code>os.PathError</code> 在 <code>os</code> 套件的 <a href="https://golang.org/src/os/error.go">error.go</a> 是這麼定義的：</p>
<pre><code class="language-prettyprint">type PathError struct {
    Op   string
    Path string
    Err  error
}

func (e *PathError) Error() string { return e.Op + " " + e.Path + ": " + e.Err.Error() }

func (e *PathError) Unwrap() error { return e.Err }

func (e *PathError) Timeout() bool {
    t, ok := e.Err.(timeout)
    return ok &amp;&amp; t.Timeout()
}
</code></pre>
<p>也就是說，若錯誤是 <code>PathError</code> 實例，可以有透過欄位或者是方法來取得更多資訊，例如：</p>
<pre><code class="language-prettyprint">if e, ok := err.(*PathError); ok {
    // 透過 e 取得欄位或呼叫方法
}
</code></pre>
<p>若要多種類型要判斷，可以使用型態 <code>switch</code> 語法，例如 <code>os</code> 套件的 <a href="https://golang.org/src/os/error.go">error.go</a> 內部實作就有個例子：</p>
<pre><code class="language-prettyprint">func underlyingError(err error) error {
    switch err := err.(type) {
    case *PathError:
        return err.Err
    case *LinkError:
        return err.Err
    case *SyscallError:
        return err.Err
    }
    return err
}
</code></pre>
<p>像 <code>PathError</code> 中還包含了 <code>Err</code> 欄位，這並非必要，其應用的情境是在呼叫某函式時檢查到錯誤，除了建立另一個錯誤實例收集當時的環境資訊之外，你可能會想要包裹來源的錯誤實例，以便後續呼叫者可以進一步檢視錯誤根源。</p>
<p>然而，當某個錯誤包裹了另一個錯誤，也就表示後續呼叫者得知道該錯誤的細節，如果這些細節來自另一個底層，而你不想曝露，就不要直接包裹它，這時在目前應用程式或程式庫的抽象層面中，抽取出來源錯誤中的資訊，包裝為目前層次的錯誤就可以了。</p>
<div class="ad336-280" style="text-align: center;">
</div>
<div class="recommend" style="text-align: center;">
<hr />
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><div id="main" role="main" style="height: auto !important;">
<div class="header">
<h1 id="errors-套件"><a class="header" href="#errors-套件">errors 套件</a></h1>
</div>
<p>在 Go 1.13 之前，<code>errors</code> 套件只公開了 <code>New</code> 函式，從 Go 1.13 之後，增加了 <code>Is</code>、<code>As</code>、與 <code>Unwrap</code> 函式。</p>
<p><code>Is</code> 函式是用於取代 <code>==</code> 判斷錯誤的場合，例如以下的程式片段：</p>
<pre><code class="language-prettyprint">if err == io.EOF {
    ...
}
</code></pre>
<p>可以改用 <code>Is</code> 函式：</p>
<pre><code class="language-prettyprint">if errors.Is(err, io.EOF) {
    ...
}
</code></pre>
<p><code>Is</code> 也可以用於判斷 <code>nil</code>，<code>err</code> 若有實作 <code>Is</code> 方法，也可以使用 <code>Is</code> 函式來判斷，因為 <code>Is</code> 函式的原始碼是這麼實作的：</p>
<pre><code class="language-prettyprint">func Is(err, target error) bool {
    if target == nil {
        return err == target
    }

    isComparable := reflectlite.TypeOf(target).Comparable()
    for {
        if isComparable &amp;&amp; err == target {
            return true
        }
        if x, ok := err.(interface{ Is(error) bool }); ok &amp;&amp; x.Is(target) {
            return true
        }
        // TODO: consider supporing target.Is(err). This would allow
        // user-definable predicates, but also may allow for coping with sloppy
        // APIs, thereby making it easier to get away with them.
        if err = Unwrap(err); err == nil {
            return false
        }
    }
}
</code></pre>
<p>（從原始碼中的註解可以看到，未來可能進一步支援 <code>target</code> 實作 <code>Is</code> 方法的情況。）</p>
<p><code>As</code> 函式是用於取代型態斷言判斷錯誤類型的場合，例如以下的程式片段：</p>
<pre><code class="language-prettyprint">if e, ok := err.(*PathError); ok {
    ...
}
</code></pre>
<p>可以改用 <code>As</code> 函式：</p>
<pre><code class="language-prettyprint">var e *PathError
if errors.As(err, &amp;e) {
    ...
}
</code></pre>
<p>來看看 <code>As</code> 函式的實作：</p>
<pre><code class="language-prettyprint">func As(err error, target interface{}) bool {
    if target == nil {
        panic("errors: target cannot be nil")
    }
    val := reflectlite.ValueOf(target)
    typ := val.Type()
    if typ.Kind() != reflectlite.Ptr || val.IsNil() {
        panic("errors: target must be a non-nil pointer")
    }
    if e := typ.Elem(); e.Kind() != reflectlite.Interface &amp;&amp; !e.Implements(errorType) {
        panic("errors: *target must be interface or implement error")
    }
    targetType := typ.Elem()
    for err != nil {
        if reflectlite.TypeOf(err).AssignableTo(targetType) {
            val.Elem().Set(reflectlite.ValueOf(err))
            return true
        }
        if x, ok := err.(interface{ As(interface{}) bool }); ok &amp;&amp; x.As(target) {
            return true
        }
        err = Unwrap(err)
    }
    return false
}
</code></pre>
<p><code>target</code> 若不是指標就會 <code>panic</code>；另外，<code>err</code> 可以是個實作 <code>As</code> 方法的實例。</p>
<p>在 <code>Is</code> 與 <code>As</code> 的實作中，都看到了 <code>Unwrap</code> 函式：</p>
<pre><code class="language-prettyprint">func Unwrap(err error) error {
    u, ok := err.(interface {
        Unwrap() error
    })
    if !ok {
        return nil
    }
    return u.Unwrap()
} 
</code></pre>
<p>從 Go 1.13 開始，錯誤可以實作 <code>Unwrap</code> 方法，如果 <code>e1.Unwrap()</code> 可以得到 <code>e2</code>，那麼 <code>e1</code> 實例包裹了 <code>e2</code>，因此，對於需要包含根源錯誤的情況，保存根源錯誤的欄位不需要是公開的，可以透過 <code>Unwrap</code> 來傳回，<code>Unwrap</code> 為取得包裹的錯誤提供了統一的名稱。</p>
<p><code>fmt</code> 套件有個 <code>Errorf</code> 函式，可以格式化字串並傳回 <code>error</code> 實例，在 Go 1.13 之前的版本，就只是將格式化後的字串傳給 <code>errors.New</code>；從 Go 1.13 開始，<code>Errorf</code> 支援 <code>%w</code>，這會令傳回的 <code>error</code> 實例會包裹指定的錯誤，並具有 <code>Unwrap</code> 方法。</p>
<div class="ad336-280" style="text-align: center;">
</div>
<div class="recommend" style="text-align: center;">
<hr />
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><div id="main" role="main" style="height: auto !important;">
<div class="header">
<h1 id="sort-套件"><a class="header" href="#sort-套件">sort 套件</a></h1>
</div>
<p>Go 提供了 <code>sort</code> 套件來協助排序、搜尋任務，對於 <code>[]int</code>、<code>[]float64</code> 與 <code>[]string</code>，可以透過 <code>Ints</code>、<code>Float64s</code>、<code>Strings</code> 來由小而大排序，可以使用 <code>IntsAreSorted</code>、<code>Float64sAreSorted</code>、<code>StringsAreSorted</code> 來看看是否已經排序。</p>
<p>若想在已由小而大排序的 <code>[]int</code>、<code>[]float64</code> 與 <code>[]string</code> 中進行搜尋，可以使用 <code>SearchInts</code>、<code>SearchFloat64s</code>、<code>SearchStrings</code> 函式，搜尋結果將傳回找到搜尋值的索引位置，<strong>沒有搜尋到的話，傳回的會是可以安插搜尋值的索引位置</strong>。例如：</p>
<pre><code class="language-prettyprint">package main

import (
    "fmt"
    "sort"
)

func main() {
    s := []int{8, 2, 6, 3, 1, 4} 
    sort.Ints(s)
    fmt.Println(sort.IntsAreSorted(s)) // true
    fmt.Println(s)                     // [1 2 3 4 6 8]
    fmt.Println(sort.SearchInts(s, 7)) // 5
}
</code></pre>
<div class="google-auto-placed" style="width: 100%; height: auto; clear: both; text-align: center;">
</div>
<p>如果想要由大而小排序呢？可以透過 <code>Slice</code>、<code>SliceStable</code>，指定一個 <code>less</code> 函式，該函式接受兩個索引，你要傳回布林值表示 <code>i</code> 處的值順序上是否小於 <code>j</code>：</p>
<pre><code class="language-prettyprint">package main

import (
    "fmt"
    "sort"
)

func main() {
    s := []int{8, 2, 6, 3, 1, 4} 
    sort.Slice(s, func(i, j int) bool {
        return s[i] &gt; s[j]
    })
    fmt.Println(s)  // [8 6 4 3 2 1]
}
</code></pre>
<p>實際上，<code>Slice</code>、<code>SliceStable</code> 可用於任意的結構，例如：</p>
<pre><code class="language-prettyprint">package main

import (
    "fmt"
    "sort"
)

func main() {
    family := []struct {
        Name string
        Age  int
    } {{"Irene", 12}, {"Justin", 45}, {"Monica", 42}}

    // 依年齡由小而大排序
    sort.SliceStable(family, func(i, j int) bool {
        return family[i].Age &lt; family[j].Age
    })

    fmt.Println(family) // [{Irene 12} {Monica 42} {Justin 45}]
}
</code></pre>
<div class="google-auto-placed" style="width: 100%; height: auto; clear: both; text-align: center;">
</div>
<p>那麼怎麼搜尋上面的 <code>family</code> 呢？例如，找出年齡 45 歲的資料？這可以用 <code>Search</code>，例如：</p>
<pre><code class="language-prettyprint">package main

import (
    "fmt"
    "sort"
)

func main() {
    family := []struct {
        Name string
        Age  int
    } {{"Irene", 12}, {"Justin", 45}, {"Monica", 42}}

    // 依年齡由小而大排序
    sort.SliceStable(family, func(i, j int) bool {
        return family[i].Age &lt; family[j].Age
    })

    fmt.Println(family) // [{Irene 12} {Monica 42} {Justin 45}]

    idx := sort.Search(len(family), func (i int) bool {
        return family[i].Age == 45
    })
    fmt.Println(idx)
}
</code></pre>
<p><code>Search</code> 會使用二分搜尋，第二個參數指定的函式要傳回布林值，表示是否符合搜尋條件，若找到第一個符合的話傳回索引位置，否則傳回第一個參數指定的值。</p>
<div class="google-auto-placed" style="width: 100%; height: auto; clear: both; text-align: center;">
</div>
<p>在 <a href="https://golang.org/pkg/sort/#Search">Search</a> 說明中，還有個猜數字的有趣範例，由程式猜出你心中想的數字：</p>
<pre><code class="language-prettyprint">func GuessingGame() {
    var s string
    fmt.Printf("Pick an integer from 0 to 100.\n")
    answer := sort.Search(100, func(i int) bool {
        fmt.Printf("Is your number &lt;= %d? ", i)
        fmt.Scanf("%s", &amp;s)
        return s != "" &amp;&amp; s[0] == 'y'
    })
    fmt.Printf("Your number is %d.\n", answer)
}
</code></pre>
<div class="google-auto-placed" style="width: 100%; height: auto; clear: both; text-align: center;">
</div>
<p><code>sort</code> 還提供了 <code>Sort</code>、<code>Stable</code> 函式，乍看很奇怪：</p>
<pre><code class="language-prettyprint">func Sort(data Interface)
func Stable(data Interface)
</code></pre>
<p><code>Interface</code> 的定義是：</p>
<pre><code class="language-prettyprint">type Interface interface {
    Len() int
    Less(i, j int) bool
    Swap(i, j int)
}
</code></pre>
<p>這是給有序、具索引的資料結構實現的行為，任何具有 <code>Interface</code> 行為的資料結構，都可以透過 <code>Sort</code>、<code>Stable</code> 函式排序，<code>sort</code> 套件提供的實作有 <code>IntSlice</code>、<code>Float64Slice</code>、<code>StringSlice</code>，以 <code>IntSlice</code> 的原始碼實現為例：</p>
<pre><code class="language-prettyprint">type IntSlice []int

func (p IntSlice) Len() int           { return len(p) }
func (p IntSlice) Less(i, j int) bool { return p[i] &lt; p[j] }
func (p IntSlice) Swap(i, j int)      { p[i], p[j] = p[j], p[i] }
</code></pre>
<p>因此，若要對整數排序，也可以如下：</p>
<pre><code class="language-prettyprint">package main

import (
    "fmt"
    "sort"
)

func main() {
    s := sort.IntSlice([]int{8, 2, 6, 3, 1, 4})
    sort.Sort(s)
    fmt.Println(s)                     // [1 2 3 4 6 8]
}
</code></pre>
<p>實際上，<code>Ints</code>、<code>Float64s</code>、<code>Strings</code> 函式，內部也只是轉換為 <code>IntSlice</code>、<code>Float64Slice</code>、<code>StringSlice</code>，然後呼叫 <code>Sort</code> 罷了：</p>
<pre><code class="language-prettyprint">func Ints(a []int) { Sort(IntSlice(a)) }
func Float64s(a []float64) { Sort(Float64Slice(a)) }
func Strings(a []string) { Sort(StringSlice(a)) }
</code></pre>
<p>對於一個實現了 <code>Interface</code> 的資料結構，除了可以使用 <code>Sort</code>、<code>Stable</code> 函式外，若需要反向排序，可以有個簡單方式，透過 <code>Reverse</code> 來包裹。例如：</p>
<pre><code class="language-prettyprint">package main

import (
    "fmt"
    "sort"
)

func main() {
    s := sort.IntSlice([]int{8, 2, 6, 3, 1, 4})
    sort.Sort(sort.Reverse(s))
    fmt.Println(s)                     // [8 6 4 3 2 1]
}
</code></pre>
<p>有趣的是 <code>Reverse</code> 的實作，它不過就是將給原本資料結構 <code>Less</code> 方法的 <code>i</code>、<code>j</code> 對調罷了：</p>
<pre><code class="language-prettyprint">type reverse struct {
    Interface
}

func (r reverse) Less(i, j int) bool {
    return r.Interface.Less(j, i)
}

func Reverse(data Interface) Interface {
    return &amp;reverse{data}
} 
</code></pre>
<p>來自己實現一下 <code>Interface</code>，使用家人的年齡來排序：</p>
<pre><code class="language-prettyprint">package main

import (
    "fmt"
    "sort"
)

type Person struct {
    Name string
    Age  int
}

type Family []Person

func (f Family) Len() int {
    return len(f)
}

func (f Family) Less(i, j int) bool {
    return f[i].Age &lt; f[j].Age
}

func (f Family) Swap(i, j int) {
    f[i], f[j] = f[j], f[i]
}

func main() {
    family := Family{{"Irene", 12}, {"Justin", 45}, {"Monica", 42}}

    sort.Sort(family)
    fmt.Println(family)  // [{Irene 12} {Monica 42} {Justin 45}]

    sort.Sort(sort.Reverse(family))
    fmt.Println(family)  // [{Justin 45} {Monica 42} {Irene 12}]
}
</code></pre>
<div class="ad336-280" style="text-align: center;">
</div>
<div class="recommend" style="text-align: center;">
<hr />
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><div id="main" role="main" style="height: auto !important;">
<div class="header">
<h1 id="list-套件"><a class="header" href="#list-套件">list 套件</a></h1>
</div>
<p>如果想連續地看待一組資料，可以使用 slice，優點是可以透過索引快速存取，透過 <code>append</code> 也可以附加元素，若偶而需要安插、刪除元素，可以透過切片等操作來實現。</p>
<p>然而，如果經常性地需要安插、刪除元素，透過 slice 實現缺乏效率時，Go 提供了 <code>container/list</code> 套件，可讓開發者基於雙向鏈結的 <code>list.List</code> 實作來達成需求。</p>
<p>想要建立 <code>list.List</code> 實例，可以透過 <code>list.New</code>，實例可使用的方法有：</p>
<pre><code class="language-prettyprint">func (l *List) Back() *Element
func (l *List) Front() *Element
func (l *List) Init() *List
func (l *List) InsertAfter(v interface{}, mark *Element) *Element
func (l *List) InsertBefore(v interface{}, mark *Element) *Element
func (l *List) Len() int
func (l *List) MoveAfter(e, mark *Element)
func (l *List) MoveBefore(e, mark *Element)
func (l *List) MoveToBack(e *Element)
func (l *List) MoveToFront(e *Element)
func (l *List) PushBack(v interface{}) *Element
func (l *List) PushBackList(other *List)
func (l *List) PushFront(v interface{}) *Element
func (l *List) PushFrontList(other *List)
func (l *List) Remove(e *Element) interface{}
</code></pre>
<p>從 <code>PushBack</code>、<code>PushFront</code> 方法的參數型態 <code>interface{}</code> 就能知道，<code>list.List</code> 可以保存任意型態的資料，它們會傳回 <code>*Element</code>，<code>Element</code> 是個結構，公開的欄位有 <code>Value</code>，公開的方法為 <code>Next</code> 與 <code>Prev</code>：</p>
<pre><code class="language-prettyprint">type Element struct {
    Value interface{}
}

func (e *Element) Next() *Element

func (e *Element) Prev() *Element
</code></pre>
<p>因此，若你保留傳回的 <code>*Element</code>，可以透過 <code>Value</code> 取得放入 <code>list.List</code> 的值，必要時也可以透過 <code>Next</code> 或 <code>Prev</code> 方法，往後探尋下一元素或往前探尋前一元素，<code>Next</code> 與 <code>Prev</code> 方法傳回的也是 <code>*Element</code>，因此隨時可以往前探尋元素前或後全部的清單。</p>
<p><code>Back</code>、<code>Front</code> 方法，分別傳回 <code>list.List</code> 最後、最前一個元素，因此，若要從清單頭走訪至尾，基本的模式就是：</p>
<pre><code class="language-prettyprint">package main

import (
    "fmt"
    "container/list"
)

func printAll(lt *list.List) {
    for e := lt.Front(); e != nil; e = e.Next() {
        fmt.Println(e.Value)
    }
}

func main() {
    lt := list.New()
    for i := 1; i &lt;= 10; i++ {
        lt.PushBack(i)
    }

    printAll(lt)
}
</code></pre>
<p>你可能會有問題，<code>Element</code> 的 <code>Value</code> 型態是 <code>interface{}</code>，那麼想操作保存的元素值上的欄位、方法時，不就要知道型態嗎？就目前來說，Go 不支援泛型，必須透過型態斷言：</p>
<pre><code class="language-prettyprint">package main

import (
    "fmt"
    "container/list"
)

type Person struct {
    Name string
    Age  int
}

func printAllPerson(persons *list.List) {
    for e := persons.Front(); e != nil; e = e.Next() {
        p := e.Value.(*Person)
        fmt.Printf("姓名：%s\t年齡：%d\n", p.Name, p.Age)
    }
}

func main() {
    persons := list.New()

    persons.PushBack(&amp;Person{"Irene", 12})
    persons.PushBack(&amp;Person{"Justin", 45})
    persons.PushBack(&amp;Person{"Monica", 42})

    printAllPerson(persons)
}
</code></pre>
<p>你可能還會有其他問題，例如 <code>list.List</code> 怎麼不支援索引？要怎麼進行排序等？…唔…<code>list.List</code> 提供的方法怎麼這麼少？</p>
<p>嚴格來說，不會直接使用 <code>list.List</code> 來保存資料，而是如果某資料結構底層需要雙向鏈結的特性，可以透過 <code>list.List</code> 來實現。例如，實現一個 <code>PersonQueue</code>：</p>
<pre><code class="language-prettyprint">package main

import (
    "fmt"
    "container/list"
)

type Person struct {
    Name string
    Age  int
}

type PersonQueue struct {
    list *list.List
}

func NewPersonQueue() *PersonQueue {
    return &amp;PersonQueue{list.New()}
}

func (q *PersonQueue) Len() int {
    return q.list.Len()
}

func (q *PersonQueue) Offer(p *Person) {
    q.list.PushBack(p)
}

func (q *PersonQueue) Peek() *Person {
    if q.list.Len() == 0 {
        return nil
    }

    e := q.list.Remove(q.list.Front())
    return e.(*Person)
}

func main() {
    q := NewPersonQueue()

    q.Offer(&amp;Person{"Irene", 12})
    q.Offer(&amp;Person{"Justin", 45})
    q.Offer(&amp;Person{"Monica", 42})

    for p := q.Peek(); p != nil; p = q.Peek() {
        fmt.Printf("姓名：%s\t年齡：%d\n", p.Name, p.Age)
    }
}
</code></pre>
<p>因此，並不是 <code>list.List</code> 不常用，而是你可能很少自行實現資料結構（都拿別人寫好的來用？）；另一種說法「每當想使用 <code>list.List</code> 時，都該思考一下是否優先使用 slice。」的說法也不是完全正確…</p>
<p>若想使用 <code>list.List</code>，應該問的是，你的資料結構在實現上需要雙向鏈結的特性嗎？例如，也許你會需要有個具索引的資料結構，同時底層實現必須是雙向鏈結（像是 Java 的 <code>LinkedList</code>）？那麼就可以考慮透過 <code>list.List</code> 來實現。</p>
<div class="ad336-280" style="text-align: center;">
</div>
<div class="recommend" style="text-align: center;">
<hr />
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><div id="main" role="main" style="height: auto !important;">
<div class="header">
<h1 id="heap-套件"><a class="header" href="#heap-套件">heap 套件</a></h1>
</div>
<p>如果在收集元素的過程中，想要一併排序，方式之一是使用<a href="https://openhome.cc/Gossip/AlgorithmGossip/HeapSort.htm">堆積排序</a>，對於這個需求，Go 提供了 <code>heap</code> 套件作為實現上的輔助。</p>
<p><code>heap</code> 套件提供的是最小堆積樹演算，底層的資料結構必須實現 <code>heap.Interface</code>：</p>
<pre><code class="language-prettyprint">type Interface interface {
    sort.Interface
    Push(x interface{}) 
    Pop() interface{} 
}
</code></pre>
<p>也就是說，除了實現 <code>sort.Interface</code> 的 <code>Len</code>、<code>Less</code>、<code>Swap</code> 方法之外，還要實現 <code>Push</code> 與 <code>Pop</code> 的行為，在 <a href="https://golang.org/pkg/container/heap/"><code>heap</code> 的 Go 官方文件說明</a> 有個簡單範例：</p>
<pre><code class="language-prettyprint">type IntHeap []int

func (h IntHeap) Len() int           { return len(h) }
func (h IntHeap) Less(i, j int) bool { return h[i] &lt; h[j] }
func (h IntHeap) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }

func (h *IntHeap) Push(x interface{}) {
    *h = append(*h, x.(int))
}

func (h *IntHeap) Pop() interface{} {
    old := *h
    n := len(old)
    x := old[n-1]
    *h = old[0 : n-1]
    return x
}
</code></pre>
<p>實現了 <code>heap.Interface</code> 的資料結構，就可以透過 <code>heap</code> 套件中的 <code>Init</code>、<code>Push</code>、<code>Pop</code> 等函式來進行操作：</p>
<pre><code class="language-prettyprint">h := &amp;IntHeap{2, 1, 5}
heap.Init(h)
heap.Push(h, 3)
fmt.Printf("minimum: %d\n", (*h)[0])
for h.Len() &gt; 0 {
    fmt.Printf("%d ", heap.Pop(h))
}
</code></pre>
<p>在 <code>Push</code>、<code>Pop</code> 過程中有關堆積樹的調整，就都由 <code>heap.Push</code>、<code>heap.Pop</code> 等函式來處理了。</p>
<p>官方文件提供的範例是可以簡單示範 <code>heap</code> 套件的使用，不過，一下子使用 <code>heap.Xxx</code>，一下子又是使用 <code>h.Xxx</code> 的混合風格，看來蠻怪的，可以來改變一下：</p>
<pre><code class="language-prettyprint">package main

import (
    "container/heap"
    "fmt"
)

// IntSlice 實現了 heap.Interface
type IntSlice []int

func (s IntSlice) Len() int           { return len(s) }
func (s IntSlice) Less(i, j int) bool { return s[i] &lt; s[j] }
func (s IntSlice) Swap(i, j int)      { s[i], s[j] = s[j], s[i] }

func (s *IntSlice) Push(x interface{}) {
    *s = append(*s, x.(int))
}

func (s *IntSlice) Pop() interface{} {
    old := *s
    n := len(old)
    x := old[n-1]
    *s = old[0 : n-1]
    return x
}

// IntHeap 封裝了 IntSlice
type IntHeap struct {
    elems IntSlice
}

// 實現相關函式或方法時，透過 heap 提供的函式
func NewIntHeap(numbers ...int) *IntHeap {
    h := &amp;IntHeap{IntSlice(numbers)}
    heap.Init(&amp;(h.elems))
    return h
}

func (h *IntHeap) Push(n int) {
    heap.Push(&amp;(h.elems), n)
}

func (h *IntHeap) Pop() int {
    return heap.Pop(&amp;(h.elems)).(int)
}

func (h *IntHeap) Len() int {
    return len(h.elems)
}

// 一律透過 h 來操作
func main() {
    h := NewIntHeap(2, 1, 5)
    h.Push(3)
    for h.Len() &gt; 0 {
        fmt.Printf("%d ", h.Pop())
    }
}
</code></pre>
<p>官方文件提供的範例中，還有個 <code>PriorityQueue</code> 的實現，類似地，該範例是簡單示範，混合了兩種操作風格，你也可以試著自行把 <code>heap.Xxx</code> 的操作給封裝起來。</p>
<div class="ad336-280" style="text-align: center;">
</div>
<div class="recommend" style="text-align: center;">
<hr />
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><div id="main" role="main" style="height: auto !important;">
<div class="header">
<h1 id="ring-套件"><a class="header" href="#ring-套件">ring 套件</a></h1>
</div>
<p>對於環狀資料結構，Go 提供了 <code>container/ring</code> 套件，<code>Ring</code> 結構有 <code>Value</code> 欄位，可以使用 <code>New</code> 指定元素數量來建立實例，可用的方法有：</p>
<pre><code class="language-prettyprint">func (r *Ring) Do(f func(interface{}))  // 走訪每個元素並傳入 f
func (r *Ring) Len() int                // 元素數量
func (r *Ring) Link(s *Ring) *Ring      // 銜接另一個 Ring
func (r *Ring) Move(n int) *Ring        // 移動 n 個元素，n 可正或負
func (r *Ring) Next() *Ring             // 下一個鏈（也就是下一個元素）
func (r *Ring) Prev() *Ring             // 上一個鏈（也就是上一個元素）
func (r *Ring) Unlink(n int) *Ring      // 解除指定數量的 Ring，傳回被解除的子鏈
</code></pre>
<p>因為是環狀結構，每個元素都可視為一個鏈的開頭或結尾，因此 <code>Link</code> 等操作都傳回 <code>*Ring</code>。底下是個建立 <code>Ring</code> 並設值的簡單範例：</p>
<pre><code class="language-prettyprint">package main

import (
    "fmt"
    "container/ring"
)

func main() {
    numbers := ring.New(10)
    for i := 0; i &lt; numbers.Len(); i++ {
        numbers.Value = i
        numbers = numbers.Next()
    }

    numbers.Do(func(n interface{}) {
        fmt.Printf("%d ", n.(int))
    })
}
</code></pre>
<p><a href="https://golang.org/pkg/container/ring/"><code>ring</code> 的官方文件</a>有相關方法的範例，這邊就不重複列出了，實際應用上，<code>ring</code> 可以用來管理有限筆數的歷史記錄、輪播等。</p>
<p>這邊的話拿來解一下 <a href="https://openhome.cc/Gossip/AlgorithmGossip/">約瑟夫問題（Josephus Problem）</a> 好了：</p>
<pre><code class="language-prettyprint">package main

import (
    "fmt"
    "container/ring"
)

type Person struct {
    Number int
}

func main() {
    persons := ring.New(41)
    // 給每個人編號
    for i := 1; i &lt;= persons.Len(); i++ {
        persons.Value = &amp;Person{i}
        persons = persons.Next()    
    }

    persons = persons.Prev()

    // 最後只留下兩人
    for persons.Len() &gt; 2 {
        for i := 1; i &lt;= 2; i++ {
            persons = persons.Next()
        }
        // 報數 3 Out
        persons.Unlink(1)
    }

    fmt.Print("安全位置：")
    persons.Do(func(p interface{}) {
        person := p.(*Person)
        fmt.Printf("%d ", person.Number)
    })
}
</code></pre>
<div class="ad336-280" style="text-align: center;">
</div>
<div class="recommend" style="text-align: center;">
<hr />
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><div id="main" role="main" style="height: auto !important;">
<div class="header">
<h1 id="strconvstrings-套件"><a class="header" href="#strconvstrings-套件">strconv、strings 套件</a></h1>
</div>
<p>Go 的字串基本上是個 <code>[]byte</code>，在程式語言強弱型別的光譜中，Go 位於強型別的一端，對於字串與其他型態之間的轉換，往往得自行處理，在這方面，<a href="https://golang.org/pkg/strconv/"><code>strconv</code> 套件</a>就提供了不少的函式。</p>
<p>例如，最常用的是將字串剖析為某個型態：</p>
<pre><code class="language-prettyprint">func ParseBool(str string) (bool, error)
func ParseFloat(s string, bitSize int) (float64, error)
func ParseInt(s string, base int, bitSize int) (i int64, err error)
func ParseUint(s string, base int, bitSize int) (uint64, error)
</code></pre>
<p>若是剖析失敗，傳回的錯誤會是 <code>*NumError</code>：</p>
<pre><code class="language-prettyprint">type NumError struct {
    Func string // 來源函式（ParseBool、ParseInt、ParseUint、ParseFloat）
    Num  string // 輸入字串
    Err  error  // 失敗的源由（ErrRange、ErrSyntax 等）
}
</code></pre>
<p>如果要將其他型態附加至字串，可以使用 Append 名稱開頭的函式：</p>
<pre><code class="language-prettyprint">func AppendBool(dst []byte, b bool) []byte
func AppendFloat(dst []byte, f float64, fmt byte, prec, bitSize int) []byte
func AppendInt(dst []byte, i int64, base int) []byte
func AppendQuote(dst []byte, s string) []byte
func AppendQuoteRune(dst []byte, r rune) []byte
func AppendQuoteRuneToASCII(dst []byte, r rune) []byte
func AppendQuoteRuneToGraphic(dst []byte, r rune) []byte
func AppendQuoteToASCII(dst []byte, s string) []byte
func AppendQuoteToGraphic(dst []byte, s string) []byte
func AppendUint(dst []byte, i uint64, base int) []byte
</code></pre>
<p>以上的附加函式設計上接收 <code>[]byte</code>，Go 字串本質上是個 <code>[]byte</code>，呼叫這些函式時只要明確型態轉換就可以了，例如：</p>
<pre><code class="language-prettyprint">b := []byte("bool:")
b = strconv.AppendBool(b, true)
fmt.Println(string(b))
</code></pre>
<p>對於大量的字串附加處理，可以使用 <a href="https://golang.org/pkg/strings/"><code>strings</code> 套件</a>的 <code>Builder</code>，一來操作上比較方便，二來可看看是否可取得較好的效能表現：</p>
<pre><code class="language-prettyprint">type Builder
    func (b *Builder) Cap() int
    func (b *Builder) Grow(n int)
    func (b *Builder) Len() int
    func (b *Builder) Reset()
    func (b *Builder) String() string
    func (b *Builder) Write(p []byte) (int, error)
    func (b *Builder) WriteByte(c byte) error
    func (b *Builder) WriteRune(r rune) (int, error)
    func (b *Builder) WriteString(s string) (int, error)
</code></pre>
<p>例如，來個簡單的評測：</p>
<pre><code class="language-prettyprint">package mypackage

import (
    "testing"
    "strings"
)

func plusAppend() string {
    c := ""
    for i := 0; i &lt; 100000; i++ {
        c += "test"
    }
    return c
}

func buliderAppend() string {
    var b strings.Builder
    for i := 0; i &lt; 100000; i++ {
        b.WriteString("test")
    }
    return b.String()
}

func BenchmarkPlusAppend(b *testing.B) {
    for i := 0; i &lt; b.N; i++ {
        plusAppend()
    }
}

func BenchmarkBuilderAppend(b *testing.B) {
    for i := 0; i &lt; b.N; i++ {
        buliderAppend()
    }
}
</code></pre>
<p>看一下效能上是否有差異：</p>
<pre><code class="language-prettyprint">C:\workspace\go-exercise&gt;go test -bench="." mypackage
goos: windows
goarch: amd64
pkg: mypackage
BenchmarkPlusAppend-4                  1        4162865000 ns/op
BenchmarkBuilderAppend-4            1946            655490 ns/op
PASS
ok      mypackage       6.614s
</code></pre>
<p>如果想將字串當成是個 <code>io.Reader</code> 來源，可以使用 <code>strings.Reader</code>：</p>
<pre><code class="language-prettyprint">type Reader
    func NewReader(s string) *Reader
    func (r *Reader) Len() int
    func (r *Reader) Read(b []byte) (n int, err error)
    func (r *Reader) ReadAt(b []byte, off int64) (n int, err error)
    func (r *Reader) ReadByte() (byte, error)
    func (r *Reader) ReadRune() (ch rune, size int, err error)
    func (r *Reader) Reset(s string)
    func (r *Reader) Seek(offset int64, whence int) (int64, error)
    func (r *Reader) Size() int64
    func (r *Reader) UnreadByte() error
    func (r *Reader) UnreadRune() error
    func (r *Reader) WriteTo(w io.Writer) (n int64, err error)
</code></pre>
<p><code>strings</code> 還有個 <code>Replacer</code>，用於一對一的字串取代：</p>
<pre><code class="language-prettyprint">type Replacer
    func NewReplacer(oldnew ...string) *Replacer
    func (r *Replacer) Replace(s string) string
    func (r *Replacer) WriteString(w io.Writer, s string) (n int, err error)
</code></pre>
<p>什麼是一對一的取代呢？看看官方文件中提到的範例就知道了：</p>
<pre><code class="language-prettyprint">package main

import (
    "fmt"
    "strings"
)

func main() {
    r := strings.NewReplacer("&lt;", "&amp;lt;", "&gt;", "&amp;gt;")
    fmt.Println(r.Replace("This is &lt;b&gt;HTML&lt;/b&gt;!"))
}
</code></pre>
<p>其他對於字串的比較、分割、大小寫轉換等處理，<code>strings</code> 中提供了一系列的函式，<a href="https://golang.org/pkg/strings/"><code>strings</code> 套件</a>的文件中都有程式碼示範。</p>
<div class="ad336-280" style="text-align: center;">
</div>
<div class="recommend" style="text-align: center;">
<hr />
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><div id="main" role="main" style="height: auto !important;">
<div class="header">
<h1 id="bytes-套件"><a class="header" href="#bytes-套件">bytes 套件</a></h1>
</div>
<p>Go 字串的本質是 <code>[]byte</code>，如果想基於位元組來處理字串，或者是想處理其他來源的 <code>[]byte</code>，可以使用 <a href="https://golang.org/pkg/bytes/"><code>bytes</code></a> 套件。</p>
<p>因為 Go 字串本質上就是一組 Unicode 碼點的 UTF-8 編碼位元組，<a href="https://golang.org/pkg/bytes/"><code>bytes</code></a> 與 <a href="https://golang.org/pkg/strings/"><code>strings</code></a> 套件中提供的函式，有著很大的相似性，只不過前者針對 <code>[]byte</code>，後者針對 <code>string</code>…唔…好像在說廢話…也就是說…儘管兩者提供的函式在名稱上有重疊，除了函式上的參數或傳回型態不同之外，兩者處理的粒度等也不同，例如 Compare，一個是逐一比較位元組，另一個是逐一比較 Unicode 碼點。</p>
<p>類似地，對於頻繁性的字串操作，可以使用 <code>strings.Builder</code>，對於對於頻繁性的位元組操作，可以使用 <code>bytes.Buffer</code>：</p>
<pre><code class="language-prettyprint">type Buffer
    func NewBuffer(buf []byte) *Buffer
    func NewBufferString(s string) *Buffer
    func (b *Buffer) Bytes() []byte
    func (b *Buffer) Cap() int
    func (b *Buffer) Grow(n int)
    func (b *Buffer) Len() int
    func (b *Buffer) Next(n int) []byte
    func (b *Buffer) Read(p []byte) (n int, err error)
    func (b *Buffer) ReadByte() (byte, error)
    func (b *Buffer) ReadBytes(delim byte) (line []byte, err error)
    func (b *Buffer) ReadFrom(r io.Reader) (n int64, err error)
    func (b *Buffer) ReadRune() (r rune, size int, err error)
    func (b *Buffer) ReadString(delim byte) (line string, err error)
    func (b *Buffer) Reset()
    func (b *Buffer) String() string
    func (b *Buffer) Truncate(n int)
    func (b *Buffer) UnreadByte() error
    func (b *Buffer) UnreadRune() error
    func (b *Buffer) Write(p []byte) (n int, err error)
    func (b *Buffer) WriteByte(c byte) error
    func (b *Buffer) WriteRune(r rune) (n int, err error)
    func (b *Buffer) WriteString(s string) (n int, err error)
    func (b *Buffer) WriteTo(w io.Writer) (n int64, err error)
</code></pre>
<p>建立 <code>Buffer</code> 時可以使用 <code>NewBuffer</code> 指定初始的位元組大小，如果你想要處理的是字串的 UTF-8 位元組，可以使用 <code>NewBufferString</code>。例如，來簡單地針對中文做百分比編碼：</p>
<pre><code class="language-prettyprint">package main

import (
    "fmt"
    "bytes"
    "strings"
)

func encodeURI(s string) string {
    buf := bytes.NewBufferString(s)

    var builder strings.Builder
    for {
        b, e := buf.ReadByte()
        if e != nil {
            break
        }
        builder.WriteString(fmt.Sprintf("%%%X", b))
    }

    return builder.String()
}

func main() {
    fmt.Println(encodeURI("良葛格")) // %E8%89%AF%E8%91%9B%E6%A0%BC
}
</code></pre>
<p>類似地，你也可以透過 <code>bytes.Reader</code>，將 <code>[]byte</code> 作為來源讀取：</p>
<pre><code class="language-prettyprint">type Reader
    func NewReader(b []byte) *Reader
    func (r *Reader) Len() int
    func (r *Reader) Read(b []byte) (n int, err error)
    func (r *Reader) ReadAt(b []byte, off int64) (n int, err error)
    func (r *Reader) ReadByte() (byte, error)
    func (r *Reader) ReadRune() (ch rune, size int, err error)
    func (r *Reader) Reset(b []byte)
    func (r *Reader) Seek(offset int64, whence int) (int64, error)
    func (r *Reader) Size() int64
    func (r *Reader) UnreadByte() error
    func (r *Reader) UnreadRune() error
    func (r *Reader) WriteTo(w io.Writer) (n int64, err error)
</code></pre>
<div class="ad336-280" style="text-align: center;">
</div>
<div class="recommend" style="text-align: center;">
<hr />
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><div id="main" role="main" style="height: auto !important;">
<div class="header">
<h1 id="unicode-套件"><a class="header" href="#unicode-套件">unicode 套件</a></h1>
</div>
<p><code>unicode</code>、<code>unicode/utf8</code>、<code>unicode/utf16</code> 是用來判斷、處理 Unicode 以及 UTF-8、UTF-16 編碼的套件，在使用這些套件之前，要先知道的是，Go 認為「字元」的定義過於模糊，在 Go 中使用 <code>rune</code> 儲存 Unicode 碼點（Code point），而 Go 中字串是 UTF-8 編碼的位元組組成。</p>
<p><a href="https://golang.org/pkg/unicode/"><code>unicode</code></a> 套件主要用來判斷 Unicode 碼點的特性（properties），在 Unicode 規範中，每個碼點會被指定某些特性，具有相同特性的一組碼點構成一個集合，以便於理解、判斷這組碼點。</p>
<p>例如，<a href="https://en.wikipedia.org/wiki/Template:General_Category_(Unicode)">General Category</a> 特性有 Letter/L 代表字母、Number/N 代表數字等，在 Go 的 <a href="https://golang.org/pkg/unicode/#pkg-variables">unicode 套件文件的 Variables</a> 一開頭，列出的就是這類特性的變數：</p>
<pre><code class="language-prettyprint">var (
    ...
    Digit  = _Nd // 十進位數字的集合

    Letter = _L  // 字母集合
    L      = _L
    ...
    Number = _N  // 數字集合
    N      = _N
    ...
}
</code></pre>
<p>每個變數的型態都是 <code>*RangeTable</code>，由碼點的範圍等欄位組成：</p>
<pre><code class="language-prettyprint">type RangeTable struct {
    R16         []Range16   // 用 uint16 記錄碼點低位至高位
    R32         []Range32   // 記錄 R16 無法表示的範圍，用 uint32 記錄碼點低位至高位
    LatinOffset int 
}
</code></pre>
<div class="google-auto-placed" style="width: 100%; height: auto; clear: both; text-align: center;">
</div>
<p>碼點範圍表可以在 <a href="https://golang.org/src/unicode/tables.go">tables.go</a> 找到。舉例來說，字母集合的碼點範圍：</p>
<pre><code class="language-prettyprint">var _L = &amp;RangeTable{
    R16: []Range16{
        {0x0041, 0x005a, 1},
        {0x0061, 0x007a, 1},
        {0x00aa, 0x00b5, 11},
        很長的清單...
</code></pre>
<p>透過指定 <code>RangeTable</code>，就可以簡單地判斷碼點是否有某特性，例如，<code>²³¹¼½¾𝟏𝟐𝟑𝟜𝟝𝟞𝟩𝟪𝟫𝟬𝟭𝟮𝟯𝟺𝟻𝟼㉛㉜㉝ⅠⅡⅢⅣⅤⅥⅦⅧⅨⅩⅪⅫⅬⅭⅮⅯⅰⅱⅲⅳⅴⅵⅶⅷⅸⅹⅺⅻⅼⅽⅾⅿ</code> 都是數字：</p>
<pre><code class="language-prettyprint">package main

import (
    "fmt"
    "unicode"
)

func allNumbers(s string) bool {
    for _, r := range []rune(s) {
        if !unicode.Is(unicode.Number, r) {
            return false
        }
    }
    return true
}

func main() {
    // true
    fmt.Println(allNumbers("²³¹¼½¾𝟏𝟐𝟑𝟜𝟝𝟞𝟩𝟪𝟫𝟬𝟭𝟮𝟯𝟺𝟻𝟼㉛㉜㉝ⅠⅡⅢⅣⅤⅥⅦⅧⅨⅩⅪⅫⅬⅭⅮⅯⅰⅱⅲⅳⅴⅵⅶⅷⅸⅹⅺⅻⅼⅽⅾⅿ"))
}
</code></pre>
<p>Unicode 將希臘文、漢字等以<a href="https://en.wikipedia.org/wiki/Script_(Unicode)">文字（Script）</a>特性標示，在 Go 的 <a href="https://golang.org/pkg/unicode/#pkg-variables">unicode 套件文件的 Variables</a> 第二組列出的變數清單，就是對應的 <code>RangeTable</code>，例如 <code>unicode.Han</code> 是正體中文、簡體中文，以及日、韓、越南文的全部漢字範圍。</p>
<p>另外還有一些其他特性，列在 Go 的 <a href="https://golang.org/pkg/unicode/#pkg-variables">unicode 套件文件的 Variables</a> 第三組變數清單，例如 <code>unicode.White_Space</code> 代表被標示為空白特性的碼點，這包括了半形、全形、Tab 等。</p>
<p>如果想要使用多個 RangeTable，<code>可以透過 IsOneOf</code>：</p>
<pre><code class="language-prettyprint">func IsOneOf(ranges []*RangeTable, r rune) bool
</code></pre>
<p><code>unicode</code> 也提供了一些常用的判斷函式：</p>
<pre><code class="language-prettyprint">func IsControl(r rune) bool
func IsDigit(r rune) bool
func IsGraphic(r rune) bool
func IsLetter(r rune) bool
func IsLower(r rune) bool
func IsMark(r rune) bool
func IsNumber(r rune) bool
func IsPrint(r rune) bool
func IsPunct(r rune) bool
func IsSpace(r rune) bool
func IsSymbol(r rune) bool
func IsTitle(r rune) bool
func IsUpper(r rune) bool
</code></pre>
<p>在大小寫或特定轉換上，有以下的函式：</p>
<pre><code class="language-prettyprint">func To(_case int, r rune) rune
func ToLower(r rune) rune
func ToTitle(r rune) rune
func ToUpper(r rune) rune
</code></pre>
<p>基本上，這可以應付大多數語言的轉換，像是全形字母的大小寫或首字母大寫等，<code>To</code> 可使用的常數有：</p>
<pre><code class="language-prettyprint">const (
    UpperCase = iota
    LowerCase
    TitleCase
    MaxCase
)
</code></pre>
<p>例如，<code>unicode.To(unicode.UpperCase, rune('ａ'))</code> 可以得到 <code>'Ａ'</code>。</p>
<h1 id="unicodeutf8unicodeutf16-套件"><a class="header" href="#unicodeutf8unicodeutf16-套件">unicode/utf8、unicode/utf16 套件</a></h1>
<p><code>unicode/utf8</code> 套件提供的函式，主要是進行 <code>rune</code> 與 UTF-8 編碼之間的處理。例如驗證是否為合法的 UTF-8 <code>[]byte</code> 或字串：</p>
<pre><code class="language-prettyprint">func Valid(p []byte) bool
func ValidString(s string) bool
</code></pre>
<p>驗證 <code>rune</code> 可否編碼為 UTF-8：</p>
<pre><code class="language-prettyprint">func ValidRune(r rune) bool
</code></pre>
<p>在 <code>rune</code> 與 UTF-8 編碼之間轉換：</p>
<pre><code class="language-prettyprint">func DecodeLastRune(p []byte) (r rune, size int)
func DecodeLastRuneInString(s string) (r rune, size int)
func DecodeRune(p []byte) (r rune, size int)
func DecodeRuneInString(s string) (r rune, size int)
func EncodeRune(p []byte, r rune) int
</code></pre>
<p><code>unicode/utf16</code> 主要是進行 <code>rune</code> 與 UTF-16 編碼之間的處理，只不過目前函式只有幾個：</p>
<pre><code class="language-prettyprint">func Decode(s []uint16) []rune
func DecodeRune(r1, r2 rune) rune
func Encode(s []rune) []uint16
func EncodeRune(r rune) (r1, r2 rune)
func IsSurrogate(r rune) bool
</code></pre>
<p>UTF-8 編碼下，碼元（code unit）是 8 個位元，Go 中使用 <code>byte</code> 也就是 <code>uint8</code> 來儲存，UTF-16 編碼下，碼元（code unit）是 16 個位元，Go 中使用 <code>uint16</code> 來儲存。</p>
<p>來看個簡單的範例，使用 <code>unicode/utf8</code> 與 <code>unicode/utf16</code> 套件來顯示「Hello, 世界」的 UTF-16 碼元：</p>
<pre><code class="language-prettyprint">package main

import (
    "fmt"
    "unicode/utf8"
    "unicode/utf16"
)

func main() {    
    b := []byte("Hello, 世界")

    for len(b) &gt; 0 {
        r, size := utf8.DecodeRune(b)
        u16 := utf16.Encode([]rune{r})
        fmt.Printf("%#U:\n  Code unit %04X\n", r, u16)
        b = b[size:]
    }
}
</code></pre>
<p>顯示結果如下：</p>
<pre><code class="language-prettyprint">U+0048 'H':       
  Code unit [0048]
U+0065 'e':       
  Code unit [0065]
U+006C 'l':       
  Code unit [006C]
U+006C 'l':       
  Code unit [006C]
U+006F 'o':
  Code unit [006F]
U+002C ',':
  Code unit [002C]
U+0020 ' ':
  Code unit [0020]
U+4E16 '世':
  Code unit [4E16]
U+754C '界':
  Code unit [754C]
</code></pre>
<p>Unicode 碼點號碼與碼元顯示剛好一樣對吧？這就是為什麼常有人會亂說「Unicode 使用 16 位元儲存」的原因之一吧！… XD</p>
<div class="ad336-280" style="text-align: center;">
</div>
<div class="recommend" style="text-align: center;">
<hr />
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><div id="main" role="main" style="height: auto !important;">
<div class="header">
<h1 id="編碼轉換"><a class="header" href="#編碼轉換">編碼轉換</a></h1>
</div>
<p>不論從哪個面向，都可以看出 Go 獨厚 UTF-8，這可能是因為 Go 的設計者之一 Ken Thompson，也曾經參與了 UTF-8 的設計。</p>
<p>如果文字資料的來源並非 UTF-8 呢？例如，儲存時並非使用 UTF-8 的檔案？解決的方法之一，是將檔案另行儲存為 UTF-8，再使用 Go 來讀取，當然，並非所有的的場合都可以這麼做，另一個方式是，使用 <a href="https://godoc.org/golang.org/x/text"><code>golang.org/x/text</code></a> 套件。</p>
<p>Go 除了本身自帶的標準套件之外，還有另外一系列官方的擴充套件，這些擴充套件組織在 <a href="https://godoc.org/-/subrepo"><code>golang/x</code></a> 底下，依文件上的說明，這些套件也是 Go 專案的一部份，只不過在相容性的維護上比較沒那麼嚴格。</p>
<p>在官方擴充套件中，<code>golang.org/x/text</code> 主要包含了文字編碼、轉換、國際化、本地化等文字性任務的套件，可以透過 <code>go get</code> 來取得、安裝：</p>
<pre><code class="language-prettyprint">go get golang.org/x/text
</code></pre>
<p>文字編碼的轉換主要由 <a href="https://godoc.org/golang.org/x/text/transform"><code>golang.org/x/text/transform</code></a> 套件來處理，看看其中的函式或結構方法，都會需要 <code>Transformer</code> 介面的實現，例如最基本的 <code>String</code>：</p>
<pre><code class="language-prettyprint">func String(t Transformer, s string) (result string, n int, err error)
</code></pre>
<p><code>Transformer</code> 定義的主要是 <code>Transform</code> 方法，代表著編碼的轉換：</p>
<pre><code class="language-prettyprint">type Transformer interface {
    Transform(dst, src []byte, atEOF bool) (nDst, nSrc int, err error)
    Reset()
}
</code></pre>
<p><code>dst</code>、<code>src</code> 代表著同一文字兩個不同編碼的位元組，由於 Go 使用 UTF-8，從 UTF-8 轉換為其他編碼，這個動作稱為 <code>Encode</code>，從其他編碼轉換為 UTF-8，這個動作稱為 Decode。</p>
<p>Encode、Decode 的動作，分別由 <a href="https://godoc.org/golang.org/x/text/encoding"><code>golang.org/x/text/encoding</code></a> 套件的 <code>Encoder</code>、<code>Decoder</code> 來處理，它們都是 <code>transform.Transformer</code> 的實現：</p>
<pre><code class="language-prettyprint">type Encoder struct {
    transform.Transformer
    ...
}

type Decoder struct {
    transform.Transformer
    ...
}
</code></pre>
<p>為了便於使用，<code>encoding</code> 定義了 <code>Encoding</code> 的行為：</p>
<pre><code class="language-prettyprint">type Encoding interface {
    NewDecoder() *Decoder
    NewEncoder() *Encoder
}
</code></pre>
<p><a href="https://godoc.org/golang.org/x/text/encoding"><code>golang.org/x/text/encoding</code></a> 套件之中，定義了不同的編碼轉換套件，例如，想處理 Big5（Code Page 950） 編碼轉換的話，需要 <code>golang.org/x/text/encoding/traditionalchinese</code> 套件，它的 <code>Big5</code> 就實現了 <code>Encoding</code>，因此想要獲得 UTF-8 &lt;-&gt; Big5 的 <code>Encoder</code>、<code>Decoder</code>，可以如下：</p>
<pre><code class="language-prettyprint">utf8ToBig5 := traditionalchinese.Big5.NewEncoder()
big5ToUtf8 := traditionalchinese.Big5.NewDecoder()
</code></pre>
<p>因此，若要讀取一個底層為 Big5 編碼的字串，轉換為 UTF-8 編碼字串，可以如下：</p>
<pre><code class="language-prettyprint">package main

import (
    "golang.org/x/text/encoding/traditionalchinese"
    "golang.org/x/text/transform"
    "fmt"
)

func main() {
    big5ToUTF8 := traditionalchinese.Big5.NewDecoder()
    big5Test := "\xb4\xfa\xb8\xd5" // 測試的 Big5 編碼
    utf8, _, _ := transform.String(big5ToUTF8, big5Test)
    fmt.Println(utf8) // 顯示「測試」
}
</code></pre>
<p>要將一個 UTF-8 編碼字串，轉換為 Big5 編碼的字串，可以如下：</p>
<pre><code class="language-prettyprint">package main

import (
    "golang.org/x/text/encoding/traditionalchinese"
    "golang.org/x/text/transform"
    "fmt"
)

func main() {
    utf8ToBig5 := traditionalchinese.Big5.NewEncoder()
    big5, _, _ := transform.String(utf8ToBig5, "測試")
    fmt.Printf("%q", big5)  // 顯示 "\xb4\xfa\xb8\xd5"
}
</code></pre>
<p><code>transform</code> 也定義了 <code>Reader</code>、<code>Writer</code>，可以用來將 <code>Transformer</code> 與 <code>io.Reader</code>、<code>io.Writer</code> 包裹在一起：</p>
<pre><code class="language-prettyprint">type Reader
    func NewReader(r io.Reader, t Transformer) *Reader
    func (r *Reader) Read(p []byte) (int, error)

type Writer
    func NewWriter(w io.Writer, t Transformer) *Writer
    func (w *Writer) Close() error
    func (w *Writer) Write(data []byte) (n int, err error)
</code></pre>
<p>例如，想要讀取 Big5 文件的話，底下是個示範：</p>
<pre><code class="language-prettyprint">package main

import (
    "golang.org/x/text/encoding/traditionalchinese"
    "golang.org/x/text/transform"
    "fmt"
    "io"
    "os"
    "io/ioutil"
)

func printBig5(r io.Reader) error {
    var big5R = transform.NewReader(r, traditionalchinese.Big5.NewDecoder())

    b, err := ioutil.ReadAll(big5R)
    fmt.Println(string(b))

    return err
}

func main() {
    fmt.Print("檔案來源：")
    var filename string
    fmt.Scanf("%s", &amp;filename)

    f, err := os.Open(filename)
    if err != nil {
        panic(err)
    }
    defer f.Close()

    printBig5(f)
}
</code></pre>
<div class="ad336-280" style="text-align: center;">
</div>
<div class="recommend" style="text-align: center;">
<hr />
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><div id="main" role="main" style="height: auto !important;">
<div class="header">
<h1 id="反射入門"><a class="header" href="#反射入門">反射入門</a></h1>
</div>
<p>反射（Reflection）是探知資料自身結構的一種能力，不同的語言提供不同的反射機制，在 Go 語言中，反射的能力主要由 <code>reflect</code> 套件提供。</p>
<h1 id="資料的-type"><a class="header" href="#資料的-type">資料的 Type</a></h1>
<p>在先前的文件中，有時會用到 <code>reflect.TypeOf()</code> 來顯示資料的型態名稱，實際上，<code>reflect.TypeOf()</code> 傳回 <code>Type</code> 的實例，<code>Type</code> 是個介面定義，目前包含了以下的方法定義：</p>
<pre><code class="language-prettyprint">type Type interface {
    Align() int
    FieldAlign() int
    Method(int) Method
    MethodByName(string) (Method, bool)
    NumMethod() int
    Name() string
    PkgPath() string
    Size() uintptr
    String() string
    Kind() Kind
    Implements(u Type) bool
    AssignableTo(u Type) bool
    ConvertibleTo(u Type) bool
    Comparable() bool
    Bits() int
    ChanDir() ChanDir
    IsVariadic() bool
    Elem() Type
    Field(i int) StructField
    FieldByIndex(index []int) StructField
    FieldByName(name string) (StructField, bool)
    FieldByNameFunc(match func(string) bool) (StructField, bool)
    In(i int) Type
    Key() Type
    Len() int
    NumField() int
    NumIn() int
    NumOut() int
    Out(i int) Type
}
</code></pre>
<div class="google-auto-placed" style="width: 100%; height: auto; clear: both; text-align: center;">
</div>
<p>因此，你可以透過 <code>Type</code> 的方法定義，取得某個型態的相關結構資訊，舉例來說：</p>
<pre><code class="language-prettyprint">package main

import (
    "fmt"
    "reflect"
)

type Account struct {
    id      string
    name    string
    balance float64
}

func main() {
    account := Account{"X123", "Justin Lin", 1000}
    t := reflect.TypeOf(account)
    fmt.Println(t.Kind())   // struct
    fmt.Println(t.String()) // main.Account
    /*
       底下顯示
       id string
       name string
       balance float64
    */
    for i, n := 0, t.NumField(); i &lt; n; i++ {
        f := t.Field(i)
        fmt.Println(f.Name, f.Type)
    }
}
</code></pre>
<p>如果 <code>reflect.TypeOf()</code> 接受的是個指標，因為指標實際上只是個位址值，必須要透過 <code>Type</code> 的 <code>Elem</code> 方法取得指標的目標 <code>Type</code>，才能取得型態的相關成員：</p>
<pre><code class="language-prettyprint">package main

import (
    "errors"
    "fmt"
    "reflect"
)

type Savings interface {
    Deposit(amount float64) error
    Withdraw(amount float64) error
}

type Account struct {
    id      string
    name    string
    balance float64
}

func (ac *Account) Deposit(amount float64) error {
    if amount &lt;= 0 {
        return errors.New("必須存入正數")
    }
    ac.balance += amount
    return nil
}

func (ac *Account) Withdraw(amount float64) error {
    if amount &gt; ac.balance {
        return errors.New("餘額不足")
    }
    ac.balance -= amount
    return nil
}

func main() {
    var savings Savings = &amp;Account{"X123", "Justin Lin", 1000}
    t := reflect.TypeOf(savings)

    for i, n := 0, t.NumMethod(); i &lt; n; i++ {
        f := t.Method(i)
        fmt.Println(f.Name, f.Type)
    }

    if t.Kind() == reflect.Ptr {
        t = t.Elem()
    }

    fmt.Println(t.Kind())
    fmt.Println(t.String())
    for i, n := 0, t.NumField(); i &lt; n; i++ {
        f := t.Field(i)
        fmt.Println(f.Name, f.Type)
    }
}
</code></pre>
<div class="google-auto-placed" style="width: 100%; height: auto; clear: both; text-align: center;">
</div>
<p>有上面的範例中，也示範了如何取得介面定義的方法資訊，這個範例會顯示以下的結果：</p>
<pre><code class="language-prettyprint">Deposit func(*main.Account, float64) error
Withdraw func(*main.Account, float64) error
struct
main.Account
id string
name string
</code></pre>
<h1 id="資料的-kind"><a class="header" href="#資料的-kind">資料的 Kind</a></h1>
<p>上面的範例中，使用了 <code>Type</code> 的 <code>Kind()</code> 方法，這會傳回 <code>Kind</code> 列舉值：</p>
<pre><code class="language-prettyprint">type Kind uint

const (
    Invalid Kind = iota
    Bool
    Int
    Int8
    Int16
    Int32
    Int64
    Uint
    Uint8
    Uint16
    Uint32
    Uint64
    Uintptr
    Float32
    Float64
    Complex64
    Complex128
    Array
    Chan
    Func
    Interface
    Map
    Ptr
    Slice
    String
    Struct
    UnsafePointer
)
</code></pre>
<div class="google-auto-placed" style="width: 100%; height: auto; clear: both; text-align: center;">
</div>
<p>以下是個簡單的型態測試：</p>
<pre><code class="language-prettyprint">package main

import (
    "fmt"
    "reflect"
)

type Duck struct {
    name string
}

func main() {
    values := [...](interface{}){
        Duck{"Justin"},
        Duck{"Monica"},
        [...]int{1, 2, 3, 4, 5},
        map[string]int{"caterpillar": 123456, "monica": 54321},
        10,
    }

    for _, value := range values {
        switch t := reflect.TypeOf(value); t.Kind() {
        case reflect.Struct:
            fmt.Println("it's a struct.")
        case reflect.Array:
            fmt.Println("it's a array.")
        case reflect.Map:
            fmt.Println("it's a map.")
        case reflect.Int:
            fmt.Println("it's a integer.")
        default:
            fmt.Println("非預期之型態")
        }
    }
}
</code></pre>
<h1 id="資料的-value"><a class="header" href="#資料的-value">資料的 Value</a></h1>
<div class="google-auto-placed" style="width: 100%; height: auto; clear: both; text-align: center;">
</div>
<p>如果想實際獲得資料的值，可以使用 <code>reflect.ValueOf()</code> 函式，這會傳回 <code>Value</code> 實例，<code>Value</code> 是個結構，定義了一些方法可以使用，可用來取得實際的值，例如：</p>
<pre><code class="language-prettyprint">package main

import (
    "fmt"
    "reflect"
)

type Account struct {
    id      string
    name    string
    balance float64
}

func main() {
    x := 10
    vx := reflect.ValueOf(x)
    fmt.Printf("x = %d\n", vx.Int())

    account := Account{"X123", "Justin Lin", 1000}
    vacct := reflect.ValueOf(account)
    fmt.Printf("id = %s\n", vacct.FieldByName("id").String())
    fmt.Printf("name = %s\n", vacct.FieldByName("name").String())
    fmt.Printf("balance = %.2f\n", vacct.FieldByName("balance").Float())
}
</code></pre>
<p>如果是個指標，一樣也是要透過 <code>Elem()</code> 方法取得目標值，例如：</p>
<pre><code class="language-prettyprint">package main

import (
    "fmt"
    "reflect"
)

type Account struct {
    id      string
    name    string
    balance float64
}

func main() {
    x := 10
    vx := reflect.ValueOf(&amp;x)
    fmt.Printf("x = %d\n", vx.Elem().Int())

    account := &amp;Account{"X123", "Justin Lin", 1000}
    vacct := reflect.ValueOf(account).Elem()
    fmt.Printf("id = %s\n", vacct.FieldByName("id").String())
    fmt.Printf("name = %s\n", vacct.FieldByName("name").String())
    fmt.Printf("balance = %.2f\n", vacct.FieldByName("balance").Float())
}
</code></pre>
<p>可以透過 <code>Value</code> 對值進行變動，不過，<code>Value</code> 必須是可定址的，具體來說，就是 <code>reflect.ValueOf()</code> 必須接受指標：</p>
<pre><code class="language-prettyprint">package main

import (
    "fmt"
    "reflect"
)

type Account struct {
    id      string
    name    string
    balance float64
}

func main() {
    x := 10
    vx := reflect.ValueOf(&amp;x).Elem()
    fmt.Printf("x = %d\n", vx.Int()) // x = 10

    vx.SetInt(20)
    fmt.Printf("x = %d\n", x) // x = 20
}
</code></pre>
<p>上面的例子若改成以下，就會出現錯誤：</p>
<pre><code class="language-prettyprint">package main

import (
    "fmt"
    "reflect"
)

type Account struct {
    id      string
    name    string
    balance float64
}

func main() {
    x := 10
    vx := reflect.ValueOf(x)
    fmt.Printf("x = %d\n", vx.Int())

    vx.SetInt(20) // panic: reflect: reflect.Value.SetInt using unaddressable value
    fmt.Printf("x = %d\n", x)
}
</code></pre>
<p>技術上來說，上面的例子，只是傳了 <code>x</code> 的值複本給 <code>reflect.ValueOf()</code>，因此，對其設值並無意義。</p>
<p>若對反射想進一步研究，可以參考〈<a href="http://blog.golang.org/laws-of-reflection">The Laws of Reflection</a>〉。</p>
<div class="ad336-280" style="text-align: center;">
</div>
<div class="recommend" style="text-align: center;">
<hr />
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><div id="main" role="main" style="height: auto !important;">
<div class="header">
<h1 id="結構欄位標籤"><a class="header" href="#結構欄位標籤">結構欄位標籤</a></h1>
</div>
<p>對於 JSON 或 XML 等具有結構性的資料，在 Go 中經常會使用 <code>struct</code> 定義資料結構，例如，底下這個程式可以將簡單的結構轉為 JSON：</p>
<pre><code class="language-prettyprint">package main

import (
    "fmt"
    "reflect"
    "strings"
)

type Customer struct {
    Name string
    City string
}

func ToJSON(obj interface{}) string {
    t := reflect.TypeOf(obj)
    v := reflect.ValueOf(obj)

    var b []string  
    for i, n := 0, t.NumField(); i &lt; n; i++ {
        f := t.Field(i)
        b = append(b, fmt.Sprintf(`"%s": "%s"`, f.Name, v.FieldByName(f.Name)))
    }

    return fmt.Sprintf("{%s}", strings.Join(b, ","))
}

func main() {
    cust := Customer{"Justin", "Kaohsiung"}
    // 顯示 {"Name": "Justin","City": "Kaohsiung"}
    fmt.Println(ToJSON(cust))
}
</code></pre>
<p>然而，Go 的慣例中，公開的結構欄位名稱通常是大寫的，如果你的 JSON 要求的是小寫的欄位名稱，或者是其他名稱，可以使用欄位標籤（Field tag）。例如：</p>
<pre><code class="language-prettyprint">package main

import (
    "fmt"
    "reflect"
    "strings"
)

type Customer struct {
    Name string `name`
    City string `city`
}

func ToJSON(obj interface{}) string {
    t := reflect.TypeOf(obj)
    v := reflect.ValueOf(obj)
    var b []string

    for i, n := 0, t.NumField(); i &lt; n; i++ {
        f := t.Field(i)
        b = append(b, fmt.Sprintf(`"%s": "%s"`, f.Tag, v.FieldByName(f.Name)))
    }

    return fmt.Sprintf("{%s}", strings.Join(b, ","))
}

func main() {
    cust := Customer{"Justin", "Kaohsiung"}
    // 顯示 {"name": "Justin","city": "Kaohsiung"}
    fmt.Println(ToJSON(cust))
}
</code></pre>
<p>欄位標籤可以在反射時，使用 <code>Field</code> 的 <code>Tag</code> 來取得，雖然欄位標籤可以是任意格式字串，然而慣例上，會由 <code>key: "value"</code> 的格式組成，符合此格式的話，可以使用 <code>Tag</code> 的 <code>Lookup</code> 來查找 <code>value</code>，它傳回兩個值，第一個值是 <code>value</code>，第二個值指出是否有對應的名稱，例如：</p>
<pre><code class="language-prettyprint">package main

import (
    "fmt"
    "reflect"
    "strings"
)

type Customer struct {
    Name string `json:"name"`
    City string `json:"city"`
}

func ToJSON(obj interface{}) string {
    t := reflect.TypeOf(obj)
    v := reflect.ValueOf(obj)
    var b []string

    for i, n := 0, t.NumField(); i &lt; n; i++ {
        f := t.Field(i)
        fv, _ := f.Tag.Lookup("json")
        b = append(b, fmt.Sprintf(`"%s": "%s"`, fv, v.FieldByName(f.Name)))
    }

    return fmt.Sprintf("{%s}", strings.Join(b, ","))
}

func main() {
    cust := Customer{"Justin", "Kaohsiung"}
    // 顯示 {"name": "Justin","city": "Kaohsiung"}
    fmt.Println(ToJSON(cust))
}
</code></pre>
<p>實際上，如果要將結構轉為 JSON 格式字串，可以使用 <code>encoding/json</code>，例如：</p>
<pre><code class="language-prettyprint">package main

import (
    "encoding/json"
    "fmt"
)

type Customer struct {
    Name string `json:"name"`
    City string `json:"city"`
}

func main() {
    cust := Customer{"Justin", "Kaohsiung"}
    b, _ := json.Marshal(cust)
    // 顯示 {"name": "Justin","city": "Kaohsiung"}
    fmt.Println(string(b))
}
</code></pre>
<div class="ad336-280" style="text-align: center;">
</div>
<div class="recommend" style="text-align: center;">
<hr />
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><div id="main" role="main" style="height: auto !important;">
<div class="header">
<h1 id="goroutine"><a class="header" href="#goroutine">Goroutine</a></h1>
</div>
<p>在 Go 中要讓指定的流程並行執行非常簡單，只需要將流程寫在函式中，並在函式加個 <code>go</code> 就可以了，這樣我們稱之為啟動一個 Goroutine。</p>
<h1 id="使用-gorutine"><a class="header" href="#使用-gorutine">使用 Gorutine</a></h1>
<p>先來看個沒有啟用 Goroutine，卻要寫個龜兔賽跑遊戲的例子，你可能是這麼寫的：</p>
<pre><code class="language-prettyprint">package main

import (
    "fmt"
    "math/rand"
    "time"
)

func random(min, max int) int {
    rand.Seed(time.Now().Unix())
    return rand.Intn(max-min) + min
}

func main() {
    flags := [...]bool{true, false}
    totalStep := 10
    tortoiseStep := 0
    hareStep := 0
    fmt.Println("龜兔賽跑開始...")
    for tortoiseStep &lt; totalStep &amp;&amp; hareStep &lt; totalStep {
        tortoiseStep++
        fmt.Printf("烏龜跑了 %d 步...\n", tortoiseStep)
        isHareSleep := flags[random(1, 10)%2]
        if isHareSleep {
            fmt.Println("兔子睡著了zzzz")
        } else {
            hareStep += 2
            fmt.Printf("兔子跑了 %d 步...\n", hareStep)
        }
    }
}
</code></pre>
<p>由於程式只有一個流程，所以只能將烏龜與兔子的行為混雜在這個流程中撰寫，而且為什麼每次都先遞增烏龜再遞增兔子步數呢？這樣對兔子很不公平啊！如果可以撰寫程式再啟動兩個流程，一個是烏龜流程，一個兔子流程，程式邏輯會比較清楚。</p>
<p>你可以將烏龜的流程與兔子的流程分別寫在一個函式中，並用 <code>go</code> 啟動執行：</p>
<pre><code class="language-prettyprint">package main

import (
    "fmt"
    "math/rand"
    "time"
)

func random(min, max int) int {
    rand.Seed(time.Now().Unix())
    return rand.Intn(max-min) + min
}

func tortoise(totalStep int) {
    for step := 1; step &lt;= totalStep; step++ {
        fmt.Printf("烏龜跑了 %d 步...\n", step)
    }
}

func hare(totalStep int) {
    flags := [...]bool{true, false}
    step := 0
    for step &lt; totalStep {
        isHareSleep := flags[random(1, 10)%2]
        if isHareSleep {
            fmt.Println("兔子睡著了zzzz")
        } else {
            step += 2
            fmt.Printf("兔子跑了 %d 步...\n", step)
        }
    }
}

func main() {
    totalStep := 10

    go tortoise(totalStep)
    go hare(totalStep)

    time.Sleep(5 * time.Second) // 給予時間等待 Goroutine 完成
}
</code></pre>
<p>現在烏龜的流程與兔子的流程都清楚多了，程式的最後使用 <code>time.Sleep()</code> 讓主流程沉睡了五秒鐘，這是因為主流程一結束，所有的 Goroutine 就會停止。</p>
<h1 id="使用-syncwaitgroup"><a class="header" href="#使用-syncwaitgroup">使用 sync.WaitGroup</a></h1>
<p>有沒有辦法知道 Goroutine 執行結束呢？實際上沒有任何方法可以得知，除非你主動設計一種機制，可以在 Goroutine 結束時執行通知，使用 Channel 是一種方式，這在之後的文件再說明，這邊先說明另一種方式，也就是使用 <code>sync.WaitGroup</code>。</p>
<p><code>sync.WaitGroup</code> 可以用來等待一組 Goroutine 的完成，主流程中建立 <code>sync.WaitGroup</code>，並透過 <code>Add</code> 告知要等待的 Goroutine 數量，並使用 <code>Wait</code> 等待 Goroutine 結束，而每個 Goroutine 結束前，必須執行 <code>sync.WaitGroup</code> 的 <code>Done</code> 方法。</p>
<p>因此，我們可以使用 <code>sync.WaitGroup</code> 來改寫以上的範例：</p>
<pre><code class="language-prettyprint">package main

import (
    "fmt"
    "math/rand"
    "sync"
    "time"
)

func random(min, max int) int {
    rand.Seed(time.Now().Unix())
    return rand.Intn(max-min) + min
}

func tortoise(totalStep int, wg *sync.WaitGroup) {
    defer wg.Done()

    for step := 1; step &lt;= totalStep; step++ {
        fmt.Printf("烏龜跑了 %d 步...\n", step)
    }
}

func hare(totalStep int, wg *sync.WaitGroup) {
    defer wg.Done()

    flags := [...]bool{true, false}
    step := 0
    for step &lt; totalStep {
        isHareSleep := flags[random(1, 10)%2]
        if isHareSleep {
            fmt.Println("兔子睡著了zzzz")
        } else {
            step += 2
            fmt.Printf("兔子跑了 %d 步...\n", step)
        }
    }
}

func main() {
    wg := new(sync.WaitGroup)
    wg.Add(2)

    totalStep := 10

    go tortoise(totalStep, wg)
    go hare(totalStep, wg)

    wg.Wait()
}
</code></pre>
<p>有個 <code>runtime.GOMAXPROCS()</code> 函式，可以設定 Go 同時間能使用的 CPU 數量，它會傳回上一次設定的數字，如果傳入小於 1 的值，不會改變任何設定，因此，可以使用 <code>runtime.GOMAXPROCS(0)</code> 知道目前的設定值。想在執行時期得知可用的 CPU 數量，可以使用 <code>runtime.NumCPU()</code> 函式，因此，為了確保 Go 會使用全部的 CPU 來運行，可以這麼撰寫：</p>
<pre><code class="language-prettyprint">runtime.GOMAXPROCS(runtime.NumCPU()) 
</code></pre>
<p>除了透過 <code>runtime.GOMAXPROCS()</code> 設定之外，也可以透過環境變數 <code>GOMAXPROCS</code> 來設置，實際上，Go 1.5 已經預設會使用所有的 CPU 核心，不過，仍可以透過 <code>runtime.GOMAXPROCS()</code> 函式或環境變數來改變設定。</p>
<div class="ad336-280" style="text-align: center;">
</div>
<div class="recommend" style="text-align: center;">
<hr />
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><div id="main" role="main" style="height: auto !important;">
<div class="header">
<h1 id="channel"><a class="header" href="#channel">Channel</a></h1>
</div>
<p>在〈<a href="http://openhome.cc/Gossip/Go/Goroutine.html">Goroutine</a>〉中提到，想要通知主流程 Goroutine 已經結束，使用 Channel 是一種方式，實際上，Channel 是 Groutine 間的溝通管道。</p>
<h1 id="使用-channel"><a class="header" href="#使用-channel">使用 Channel</a></h1>
<p>Channel 就像是個佇列，可以對它發送值，也可以從它上頭取得值，想要建立一個 Channel，要在型態之前加上個 <code>chan</code>，每個 <code>chan</code> 都要宣告可容納的型態。</p>
<p>舉例來說，使用 Channel 來修改之前的龜兔賽跑程式：</p>
<pre><code class="language-prettyprint">package main

import (
    "fmt"
    "math/rand"
    "time"
)

func random(min, max int) int {
    rand.Seed(time.Now().Unix())
    return rand.Intn(max-min) + min
}

func tortoise(totalStep int, goal chan string) {
    for step := 1; step &lt;= totalStep; step++ {
        fmt.Printf("烏龜跑了 %d 步...\n", step)
    }
    goal &lt;- "烏龜"
}

func hare(totalStep int, goal chan string) {
    flags := [...]bool{true, false}
    step := 0
    for step &lt; totalStep {
        isHareSleep := flags[random(1, 10)%2]
        if isHareSleep {
            fmt.Println("兔子睡著了zzzz")
        } else {
            step += 2
            fmt.Printf("兔子跑了 %d 步...\n", step)
        }
    }
    goal &lt;- "兔子"
}

func main() {
    goal := make(chan string)

    totalStep := 10

    go tortoise(totalStep, goal)
    go hare(totalStep, goal)

    fmt.Printf("%s 抵達終點\n", &lt;-goal)
    fmt.Printf("%s 抵達終點\n", &lt;-goal)
}
</code></pre>
<p>在這個範例中，使用 <code>make</code> 建立了一個 Channel，當烏龜或兔子抵達終點時，使用 <code>goal &lt;-</code> 發送一個字串至 Channel 中，而在主流程中，使用 <code>&lt;- goal</code> 從 Channel 取得字串，若 Channel 中無法取得資料，這時會發生阻斷，直到可從 Channel 中取得字串為止。實際上，使用 <code>goal &lt;-</code> 發送資料至 Channel 時，若 Channel 中已有資料，也會發生阻斷，直到該資料被取走為止。</p>
<h1 id="buffered-channel"><a class="header" href="#buffered-channel">Buffered Channel</a></h1>
<div class="google-auto-placed" style="width: 100%; height: auto; clear: both; text-align: center;">
</div>
<p>上頭的範例建立 Channel 時並沒有指定 Channel 中可以容納多少資料，Channel 中預設只能容納一個資料，你可以在建立 Channel 時指定當中可以容納的資料數量。例如，建立一個生產者、消費者的程式：</p>
<pre><code class="language-prettyprint">package main

import "fmt"

func producer(clerk chan int) {
    fmt.Println("生產者開始生產整數......")
    for product := 1; product &lt;= 10; product++ {
        clerk &lt;- product
        fmt.Printf("生產了 (%d)\n", product)
    }
}

func consumer(clerk chan int) {
    fmt.Println("消費者開始消耗整數......")
    for i := 1; i &lt;= 10; i++ {
        fmt.Printf("消費了 (%d)\n", &lt;-clerk)
    }
}

func main() {
    clerk := make(chan int, 2)

    go producer(clerk)
    consumer(clerk)
}                                                                                                       
</code></pre>
<div class="google-auto-placed ap_container" style="width: 100%; height: auto; clear: both; text-align: center;">
</div>
<p>在這個程式中，建立的 Channel 的容量為 2，因此在 Channel 的容量未滿前，發送數據至 Channel 並不會發生阻斷。</p>
<h1 id="close-與-range"><a class="header" href="#close-與-range">close 與 range</a></h1>
<p>在這篇文件的第一個範例中，由於預期只會從 Channel 中收到兩個字串，因此主流程中使用了兩次 <code>&lt;- goal</code>，然而有時，我們無法事先知道，能從 Channel 得到幾筆資料。</p>
<p>舉例來說，你也許想寫個猜數字遊戲，在隨機猜測數字的情況下，你無法事先知道要猜幾次才會猜中，而你想將先前猜測的數字透過 Channel 傳送：</p>
<pre><code class="language-prettyprint">package main

import (
    "fmt"
    "math/rand"
    "time"
)

func random(min, max int) int {
    rand.Seed(time.Now().Unix())
    return rand.Intn(max-min) + min
}

func guess(n int, ch chan int) {
    for {
        number := random(1, 10)
        ch &lt;- number
        if number == n {
            close(ch)
        }
        time.Sleep(time.Second)
    }
}

func main() {
    ch := make(chan int)

    go guess(5, ch)

    for i := range ch {
        fmt.Println(i)
    }

    fmt.Println("I hit 5....Orz")
}
</code></pre>
<div class="google-auto-placed ap_container" style="width: 100%; height: auto; clear: both; text-align: center;">
</div>
<p>在這個範例中，每次猜測的數字，都會使用 <code>ch &lt;- number</code> 傳至 Channel 中，而最後猜中數字時，使用 <code>close()</code> 關閉 Channel，Go 的 <code>range</code> 可以搭配 Channel 使用，在 Channel 尚未關閉前，搭配 <code>for</code> 就可以持續從 Channel 中取出資料。</p>
<h1 id="select"><a class="header" href="#select">select</a></h1>
<p>如果有多個 Channel 需要協調，可以使用 <code>select</code>，直接來看個多個生產者與一個消費者的例子：</p>
<pre><code class="language-prettyprint">package main

import "fmt"

func producer(clerk chan int) {
    fmt.Println("生產者開始生產整數......")
    for product := 1; product &lt;= 10; product++ {
        clerk &lt;- product
        fmt.Printf("生產了 (%d)\n", product)
    }
}

func consumer(clerk1 chan int, clerk2 chan int) {
    fmt.Println("消費者開始消耗整數......")
    for i := 1; i &lt;= 20; i++ {
        select {
        case p1 := &lt;-clerk1:
            fmt.Printf("消費了生產者一的 (%d)\n", p1)
        case p2 := &lt;-clerk2:
            fmt.Printf("消費了生產者二的 (%d)\n", p2)
        }

    }
}

func main() {
    clerk1 := make(chan int)
    clerk2 := make(chan int)

    go producer(clerk1)
    go producer(clerk2)

    consumer(clerk1, clerk2)
}
</code></pre>
<p>在 <code>select</code> 的 <code>case</code> 中，會監看哪個 Channel 可以取得資料（或發送資料至 Channel），如果都有資料的話，就會隨機選取，如果都無法取得資料（或發送資料至 Channel）就會發生 panic，這可以設置 <code>default</code> 來解決，也就是監看的 Channel 中都沒有資料的話就會執行，或者利用 <code>select</code> 來做些超時設定。例如：</p>
<div class="google-auto-placed ap_container" style="width: 100%; height: auto; clear: both; text-align: center;">
</div>
<pre><code class="language-prettyprint">package main

import (
    "fmt"
    "math/rand"
    "time"
)

func random(min, max int) int {
    rand.Seed(time.Now().Unix())
    return rand.Intn(max-min) + min
}

func producer(clerk chan int) {
    fmt.Println("生產者開始生產整數......")
    for product := 1; product &lt;= 10; product++ {
        time.After(time.Duration(random(1, 5)) * time.Second)
        clerk &lt;- product
        fmt.Printf("生產了 (%d)\n", product)
    }
}

func consumer(clerk1 chan int, clerk2 chan int) {
    fmt.Println("消費者開始消耗整數......")
    for i := 1; i &lt;= 20; i++ {
        select {
        case p1 := &lt;-clerk1:
            fmt.Printf("消費了生產者一的 (%d)\n", p1)
        case p2 := &lt;-clerk2:
            fmt.Printf("消費了生產者二的 (%d)\n", p2)
        case &lt;-time.After(3 * time.Second):
            fmt.Printf("消費者抱怨中…XD")
        }

    }
}

func main() {
    clerk1 := make(chan int)
    clerk2 := make(chan int)

    go producer(clerk1)
    go producer(clerk2)

    consumer(clerk1, clerk2)
}
</code></pre>
<p>如果過了 3 秒鐘，另兩個 Channel 都還是阻斷，<code>case &lt;- time.After(3 * time.Second)</code> 該行就會成立，因此就可以看到消費者的抱怨了…XD</p>
<p>在 <code>select</code> 中若有相同的 Channel，會隨機選取。例如底下會顯示哪個結果是不一定的：</p>
<pre><code class="language-prettyprint">package main

import "fmt"

func main() {
    ch := make(chan int, 1)

    ch &lt;- 1
    select {
    case &lt;-ch:
        fmt.Println("隨機任務 1")
    case &lt;-ch:
        fmt.Println("隨機任務 2")
    case &lt;-ch:
        fmt.Println("隨機任務 3")        
    }
}
</code></pre>
<h1 id="單向-channel"><a class="header" href="#單向-channel">單向 Channel</a></h1>
<p>可以將 Channel 轉為只可發送或只可取值的 Channel，例如：</p>
<pre><code class="language-prettyprint">package main

import "fmt"

func producer(clerk chan&lt;- int) {
    fmt.Println("生產者開始生產整數......")
    for product := 1; product &lt;= 10; product++ {
        clerk &lt;- product
        fmt.Printf("生產了 (%d)\n", product)
    }
}

func consumer(clerk &lt;-chan int) {
    fmt.Println("消費者開始消耗整數......")
    for i := 1; i &lt;= 10; i++ {
        fmt.Printf("消費了 (%d)\n", &lt;-clerk)
    }
}

func main() {
    clerk := make(chan int, 2)

    go producer(clerk)
    consumer(clerk)
}   
</code></pre>
<p><code>clerk chan&lt;- int</code> 是只能發送的 Channel，而 <code>clerk &lt;-chan int</code> 是只能接收的 Channel，從一個只能發送的 Channel 接收資料，或者是對一個只能接收的 Channel 發送資料，都會引發 invalid operation 的錯誤。</p>
<p>透過 Channel 來作為 Goroutine 間的溝通機制，是 Go 中比較建議的方式，如果你真的不想要透過 Channel，而想要直接共用某些資料結構，就必須注意有無 Race condition的問題，若必要，可透過鎖定資源的方式來避免相關問題，有關鎖定的方式，可以參考 <a href="https://tour.golang.org/concurrency/9">sync.Mutex</a> 的使用。</p>
<div class="ad336-280" style="text-align: center;">
</div>
<div class="recommend" style="text-align: center;">
<hr />
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><div id="main" role="main" style="height: auto !important;">
<div class="header">
<h1 id="vendor"><a class="header" href="#vendor">vendor</a></h1>
</div>
<p>在只有一個專案的情況下，<code>GOPATH</code> 非常合情合理而且簡單，如果有多個專案，各個專案的原始碼也可以放在同一個 <code>GOPATH</code> 之中，有著各自的套件結構，使用著來自 <code>GOPATH</code> 的非標準套件，此時整個 <code>GOPATH</code> 目錄就是一個巨大的 repository，具稱 Google 內部就是這樣的場景，才會有 <code>GOPATH</code> 這樣的設計，Go 社群中也有著「如果必須切換 <code>GOPATH</code>，大概有哪些地方不對了」的說法。</p>
<p>問題在於，這並不是社群或其他公司中使用 Go 的方式，如果個別專案有個別的套件，比較單純的做法是各個專案有個專用的 <code>GOPATH</code>，想要開發哪個專案，就切換至該專案使用的 <code>GOPATH</code>，然而很快地，如果有專案相依在這些個別專案上呢？將它們組織為巨大的 repository 是個做法，或者是令 <code>GOPATH=prj1:prj2:prj3</code>，prjx 是指向各專案原始碼的路徑，也就是說 <code>GOPATH</code> 會是一大串路徑結合後的產物。</p>
<p>在上述的設定中，維持了一個 <code>GOPATH</code> 不用切換，新專案可以加入至 <code>GOPATH</code> 最前頭，<code>go get</code> 的第三方套件會下載到最前面的路徑中，然而，若需要 prj2 也在開發中，若 prj2 需要新的第三方套件時，<code>go get</code> 卻會下載到新專案之中；在各自不同的情境中，無論怎麼調整 <code>GOPATH</code> 的順序，總是會有各自不同的問題發生。</p>
<p>另一方面，<code>GOPATH</code> 本身不涉及套件來源的版本問題，因此，若專案依賴的 repository 被修改了，日後建構專案就會受到影響，對依賴於Github之類來源，而且第三方套件本身非常活躍的專案來說，重新建構專案時無法有穩定的結果，這顯然是個大問題。</p>
<p>例如在〈<a href="Package.html">Go 套件管理</a>〉中看過的例子，使用 <code>go get github.com/JustinSDK/goexample</code>，然後撰寫底下的程式：</p>
<pre><code class="language-prettyprint">package main

import "github.com/JustinSDK/goexample"

func main() {
    goexample.Hi()
    goexample.Hello()
}
</code></pre>
<p>這簡單的程式被發佈為一個範例了，某年某月的某一天，我修改了 goexample 的內容，讓 <code>Hi</code>、<code>Hello</code> 顯示中文並發佈到 Github 上的檔案庫，有位讀者，依舊照著〈<a href="Package.html">Go 套件管理</a>〉中的說明進行操作，然而看到的不是英文，而是中文的招呼。</p>
<p>為了避免這個問題，通常會將下載的檔案庫複製出來，例如放到 deps 中：</p>
<pre><code class="language-prettyprint">project
    └─src
        ├─deps
        │  └─src
        │      └─github.com
        │          └─JustinSDK
        │              └─goexample
        │                      .gitignore
        │                      hello.go
        │                      hi.go
        │                      LICENSE
        │                      README.md
        │
        └─main
                main.go
</code></pre>
<p>問題是放到 deps 的檔案庫該怎麼用呢？其中一個方式是修改 <code>import</code>：</p>
<pre><code class="language-prettyprint">package main

import "deps/src/github.com/JustinSDK/goexample"

func main() {
    goexample.Hi()
    goexample.Hello()
}
</code></pre>
<p>另一個方式是透過工具修改 <code>GOPATH</code> 自動包含 deps 目錄，這類的概念主要成為了 <a href="https://github.com/tools/godep">godep</a> 等工具早期在管理 Go 套件時的思考出發點。</p>
<p>Go 在 1.5 時實驗性地加入了 vendor，需要透過 <code>GO15VENDOREXPERIMENT="1"</code> 來啟用，1.6 預設 <code>GO15VENDOREXPERIMENT="1"</code>，1.7 拿掉 <code>GO15VENDOREXPERIMENT</code> 環境變數，使得vendor成為正式的內建特性。</p>
<p>簡單來說，如果你的套件中有個 vendor 資料夾，例如：</p>
<pre><code class="language-prettyprint">project
    └─src
        └─main
            │  main.go
            │
            └─vender
                └─github.com
                    └─JustinSDK
                        └─goexample
                                .gitignore
                                hello.go
                                hi.go
                                LICENSE
                                README.md
</code></pre>
<p>對於 <code>import "github.com/JustinSDK/goexample"</code> 來說，尋找相依套件的順序會變成 vendor -&gt; GOROOT 的 src -&gt; GOPATH 的 src。</p>
<p>在 vendor 推出後，<code>godep</code> 也改使用 vendor了，而 <a href="https://github.com/Masterminds/glide">glide</a> 等工具，也都基於 vendor 了。</p>
<div class="ad336-280" style="text-align: center;">
</div>
<div class="recommend" style="text-align: center;">
<hr />
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><div id="main" role="main" style="height: auto !important;">
<div class="header">
<h1 id="模組入門"><a class="header" href="#模組入門">模組入門</a></h1>
</div>
<p>Go 在 1.11 時內建了實驗性的模組管理功能，並藉由 <code>GO111MODULE</code> 來決定是否啟用，可設定的值是 <code>auto</code>（1.11 ~ 1.13 預設）、<code>on</code> 與 <code>off</code>。</p>
<p>若使用 Go 1.13，當設定值是 <code>auto</code>，執行建構指令時，會看看是否有個 go.mod 檔案（用來定義依賴的模組），若有就使用 Go 模組功能，如果沒有 go.mod 檔案，就採用舊式 <code>GOPATH</code>、vendor 的特性。</p>
<p>當設定值為 <code>on</code> 時，就是始終使用 Go 模組功能（從 1.12 之後，go.mod 可以在必要時再新增），模組下載後會自動安裝至 <code>GOPATH</code>。</p>
<p>go.mod 不可以在 <code>GOPATH</code> 之中。</p>
<p>設定值為 <code>off</code> 時就是不使用 Go 模組功能。</p>
<p>例如，現在有個 pkgfoo 釋出了 <a href="https://github.com/JustinSDK/pkgfoo/tree/v1.0.0">v1.0.0</a> 版，而你打算基於它寫個 go-exercise，go-exercise 資料夾中有個 src/main/main.go：</p>
<pre><code class="language-prettyprint">package main

import "github.com/JustinSDK/pkgfoo"

func main() {
    kgfoo.Hi()
    pkgfoo.Hello()
}
</code></pre>
<p>現在進入你的 go-exercise 資料夾底下，執行 <code>go mod init go-exercise</code>，這會建立一個 go.mod，使用 Go 1.13 的話，預設內容是：</p>
<pre><code class="language-prettyprint">module go-exercise

go 1.13
</code></pre>
<p>從 Go 1.12 開始，預設的 go.mod 中會有版本字段，放置了 go.mod 的資料夾稱為模組根（module root）目錄，通常就是一個 repository 的根目錄，該目錄下的全部套件都屬於該模組（除了那些本身包含 go.mod 檔案的子目錄之外）。</p>
<p>接著執行 <code>go build -o bin/main.exe src/main/main.go</code>，這時會自動找出 <code>import</code> 陳述，執行了套件的下載並完成建構，此時會顯示以下訊息：</p>
<pre><code class="language-prettyprint">go: finding github.com/JustinSDK/pkgfoo v1.0.0
go: downloading github.com/JustinSDK/pkgfoo v1.0.0
go: extracting github.com/JustinSDK/pkgfoo v1.0.0
</code></pre>
<p>而 go.mod 也有了底下內容：</p>
<pre><code class="language-prettyprint">module exercise

go 1.13

require github.com/JustinSDK/pkgfoo v1.0.0
</code></pre>
<p>go.mod 定義了相依的套件與版本，若是第一次執行 <code>go build</code>，那麼總是會下載最新版本，你也可以自行編輯 go.mod 的內容，來取得想要的版本，另外你也會發現多了個 go.sum，其中包含了套件的 hash 等訊息，這用來確認取得的是正確的版本：</p>
<pre><code class="language-prettyprint">github.com/JustinSDK/pkgfoo v1.0.0 h1:XOi67njsT9pcRrsT40Oi3LCA3b1TyIxHd6+9ceGwa0U=
github.com/JustinSDK/pkgfoo v1.0.0/go.mod h1:5PAHGmqvfj2XbzxxOeiJJjOflE/p6zTVRFfaiEeSn1w=
</code></pre>
<p>接著在執行建構出來的可執行檔時會看到：</p>
<pre><code class="language-prettyprint">Hi
Helo
</code></pre>
<p>喔！Hello 少了一個小寫的 l，這是一個小 bug，在修正之後，發佈了 <a href="https://github.com/JustinSDK/pkgfoo/tree/v1.0.1">v1.0.1</a>：</p>
<p>現在 appfoo 為了要能取得更新，可以使用 <code>go get -u</code>，這會昇級到最新的 MINOR 或 PATCH 版本，像是從 1.0.0 到 1.0.1，或者是 1.0.0 到 1.1.0，是的，這採用的是 <a href="https://semver.org/">Semantic Versioning</a>；若是使用 <code>go get -u=patch all</code>，會將用到的套件昇級至最新的 PATCH 版本，像是從 1.0.0 到 1.0.1；若是使用 <code>go get package@version</code>，可以指定昇級至某個版本號，例如 <code>go get github.com/JustinSDK/pkgfoo@v1.0.1</code>，然而，不建議以此方式昇級至新的 MAJOR 版本，原因後述。</p>
<p>在這邊因為只是小 bug 更新，就使用 <code>go get -u=patch all</code>，這會看到底下的訊息：</p>
<pre><code class="language-prettyprint">go: finding github.com/JustinSDK/pkgfoo v1.0.1
go: downloading github.com/JustinSDK/pkgfoo v1.0.1
go: extracting github.com/JustinSDK/pkgfoo v1.0.1
</code></pre>
<p>go.mod 的內容也更新了（go.sum 也會更新）：</p>
<pre><code class="language-prettyprint">module go-exercise

go 1.13

require github.com/JustinSDK/pkgfoo v1.0.1
</code></pre>
<p>重新執行 <code>go build</code>，就會顯示正確的訊息了：</p>
<pre><code class="language-prettyprint">Hi
Hello
</code></pre>
<p>假設現在 pkgfoo 中的訊息都改成中文，並更新為 v2.0.0 了，雖然可以使用 <code>go get github.com/JustinSDK/pkgfoo@v2.0.0</code> 來下載最新版本，然而會出現 +incompatible 字樣：</p>
<pre><code class="language-prettyprint">go: finding github.com/JustinSDK/pkgfoo v2.0.0
go: downloading github.com/JustinSDK/pkgfoo v2.0.0+incompatible
</code></pre>
<p>雖然可以順利建構，執行時也會是最新版本的結果，然而，若要昇級至最新的 MAJOR 版本，依賴的套件，必須明確地屬於某個模組，因此，pkgfoo 中必須有個 go.mod，並定義版本資訊：</p>
<pre><code class="language-prettyprint">module github.com/JustinSDK/pkgfoo/v2
</code></pre>
<p>go.mod 在加入了 pkgfoo 之後，發佈了 <a href="https://github.com/JustinSDK/pkgfoo/tree/v2.0.0">v2.0.0</a> ，現在 appfoo 打算使用這 v2.0.0，可以在 <code>import</code> 時指定：</p>
<pre><code class="language-prettyprint">package main

import "github.com/JustinSDK/pkgfoo/v2"

func main() {
    pkgfoo.Hi()
    pkgfoo.Hello()
}
</code></pre>
<p>直接 <code>go build -o bin/main.exe src/main/main.go</code>，就會看到下載了 v2.0.0：</p>
<pre><code class="language-prettyprint">go: finding github.com/JustinSDK/pkgfoo/v2 v2.0.0
go: downloading github.com/JustinSDK/pkgfoo/v2 v2.0.0
go: extracting github.com/JustinSDK/pkgfoo/v2 v2.0.0
</code></pre>
<p>而且你可以看到 appfoo 的 go.mod 更新為：</p>
<pre><code class="language-prettyprint">module go-exercise

go 1.13

require (
    github.com/JustinSDK/pkgfoo v1.0.1
    github.com/JustinSDK/pkgfoo/v2 v2.0.0
)
</code></pre>
<p>現在它依賴在…兩個版本？是的，事實上，你也可以同時在 appfoo 中使用：</p>
<pre><code class="language-prettyprint">package main

import "github.com/JustinSDK/pkgfoo/v2"
import pkgfooV1 "github.com/JustinSDK/pkgfoo"

func main() {
    pkgfoo.Hi()
    pkgfoo.Hello()
    pkgfooV1.Hi()
    pkgfooV1.Hello()        
}
</code></pre>
<p>不同模組版本的套件，被視為不同的套件，上面的程式執行過時會顯示：</p>
<pre><code class="language-prettyprint">嗨
哈囉
Hi
Hello
</code></pre>
<div class="ad336-280" style="text-align: center;">
</div>
<div class="recommend" style="text-align: center;">
<hr />
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><div id="main" role="main" style="height: auto !important;">
<div class="header">
<h1 id="哈囉webassembly"><a class="header" href="#哈囉webassembly">哈囉！WebAssembly！</a></h1>
</div>
<p>Go 1.11 實驗性地加入了 WebAssembly 的支援，這表示你可以使用 Go 來撰寫程式碼，然後令其在網頁中執行，也可以與瀏覽器互動，像是瀏覽器的 JavaScript 環境、DOM 操作等。</p>
<p>對 Go 開發者而言，理想的狀況下，若 Go 封裝的好，最好是可以完全忽略 JavaScript、瀏覽器環境等事實，也不需要知道 WebAssembly 的細節，然而，畢竟目前還是實驗性質，如果能認識 JavaScript、瀏覽器、WebAssembly 的特性，對使用 Go 撰寫程式並編譯為 WebAssembly 來說，是有很大的幫助的。</p>
<p>如果對 JavaScript、瀏覽器的細節有興趣，建議參考〈<a href="https://openhome.cc/Gossip/ECMAScript/">ECMAScript 本質部份</a>〉，如果對 WebAssembly 的細節有興趣，建議參考〈<a href="https://openhome.cc/Gossip/WebAssembly/">WebAssembly</a>〉文件。</p>
<p>無論如何，來看個簡單的 Go 程式如何編譯為 WebAssembly，首先，來個簡單的 Go 程式：</p>
<pre><code class="language-prettyprint">package main

func main() {
    println("Hello, WebAssembly")
}
</code></pre>
<p>再簡單也不過，在編譯為 WebAssembly 之後，<code>println</code> 的輸出預設會是瀏覽器主控台（console），接下來，若要編譯為 WebAssembly，環境變數 <code>GOOS</code> 必須設定為 <code>js</code>，<code>GOARCH</code> 必須設定為 <code>wasm</code>。</p>
<p>如果你是使用 Visual Studio Code，安裝了 <a href="https://github.com/Microsoft/vscode-go">vscode-go</a> 擴充，可以在 settings.json 中設定：</p>
<pre><code class="language-prettyprint">{
    "go.toolsEnvVars": {"GOOS":"js", "GOARCH": "wasm"}
}
</code></pre>
<p>如果是要在 Visual Studio Code 開啟的終端機中設定環境變數，因為它是基於 Power Shell，可以如下設定環境變數：</p>
<pre><code class="language-prettyprint">$env:GOOS="js"
$env:GOARCH="wasm"
</code></pre>
<p>如果是在 Windows 的命令提示字元，就是使用 <code>set</code> 了：</p>
<pre><code class="language-prettyprint">SET GOOS=js
SET GOARCH=wasm
</code></pre>
<p>接下來，可以執行建構：</p>
<pre><code class="language-prettyprint">go build -o test.wasm main.go
</code></pre>
<p>test.wasm 是編譯出來的 WebAssembly 模組位元組碼，除了你撰寫的程式之外，根據〈<a href="https://goo.gl/YfaETG">Go 1.11 Release Notes</a>〉，編譯出來的 WebAssembly 模組也包含了 goroutine、垃圾收集、maps 等功能的執行環境，最小約在 2MB 左右，壓縮後可以減至 500KB。</p>
<p>接下來就是開個 HTML 檔案，在當中使用 JavaScript，運用 Fetch API、WebAssembly API 等，取得、編譯、初始化 WebAssembly 模組，這些細節在〈<a href="https://openhome.cc/Gossip/WebAssembly/">WebAssembly</a>〉文件都有談到。</p>
<p>如果想要直接有個現成的載入頁面可以使用，可以複製 Go 安裝目錄的 misc\wasm 中 wasm_exec.html 與 wasm_exec.js 到你的工作目錄之中，wasm_exec.html 裏頭寫的 JavaScript，會使用 Fetch API 來取得 test.wasm，這也是為什麼，方才編譯時指定輸出檔案名稱為 test.wasm 的原因。</p>
<p>如果你有安裝 Node.js，那麼可以直接搭配 wasm_exec.js 來運行 test.wasm，這會顯示 Hello, WebAssembly：</p>
<pre><code class="language-prettyprint">node wasm_exec.js test.wasm
</code></pre>
<p>如果要在瀏覽器中運行，你需要有個 HTTP 伺服器，例如 Node.js 的 <code>http-server</code>，在啟動之後，請求你的 http://localhost:8080/wasm_exec.html。</p>
<p>這會看到一個 Run 按鈕，開啟你瀏覽器上的開發者工具，然後按下網頁中的 Run 按鈕，你就會看到開發者工具中的主控台顯示了文字：</p>
<div class="pure-g">
<div class="pure-u-1">
<img src="images/WebAssembly-1.JPG" class="pure-img-responsive" alt="哈囉！WebAssembly！" />
</div>
</div>
<p>要注意的是，在執行完 Go 的 <code>main</code> 之後，程式就結束了，就網頁中 Run 按鈕的事件來說，每按一次是會重新跑一次 WebAssembly 模組實例，也就是重新跑一次 <code>main</code> 流程，有時這不會是你想要的，這時就要在 Go 中以某種方式，阻斷 <code>main</code> 的流程，這之後還會看到。</p>
<p>這只是個體驗，之後的文件還會談到，如何操作瀏覽器中的 JavaScript、DOM，以及 Go 中定義的函式，如何能被 JavaScript 取得呼叫。</p>
<div class="ad336-280" style="text-align: center;">
</div>
<div class="recommend" style="text-align: center;">
<hr />
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><div id="main" role="main" style="height: auto !important;">
<div class="header">
<h1 id="go-呼叫-javascript"><a class="header" href="#go-呼叫-javascript">Go 呼叫 JavaScript</a></h1>
</div>
<p>Go 社群中有不少人直言，Go 支援 WebAssembly 就是要取代 Javascript，雖然我個人覺得，這就姑且當成是個崇高的理想就好，不過這也表示，在編譯為 WebAssembly 之後，可以呼叫 JavaScript 或操作 DOM，自然也是 Go 應該照料之事，為此，Go 1.11 提供了個實驗性的 <code>syscall/js</code> 套件來負責這項任務。</p>
<p>Go 與 JavaScript 畢竟是兩個不同的語言，各擁有不同的資料型態與結構，因而必須先知道，兩個語言間的型態如何對應，這主要定義在 <code>syscall/js</code> 套件的 js.go 中。</p>
<p>例如，<code>js.Value</code> 結構代表 JavaScript 中的值，定義有 <code>Get</code> 與 <code>Set</code> 方法，可以對物件上的特性存取；若想存取的對象實際上是陣列，可以使用 <code>Index</code>、<code>SetIndex</code> 並指定索引；若對象是個函式，可以使用 <code>Invoke</code> 指定引數來呼叫，若想呼叫的是物件上的方法，可以使用 <code>Call</code> 指定方法名稱與呼叫時的引數等。</p>
<p>在 js.go 中預先定義了一些 <code>js.Value</code> 的實例，可以透過公開的 <code>js.Undefined</code>、<code>js.Null</code>、<code>js.Global</code> 等函式呼叫取得。</p>
<div class="google-auto-placed" style="width: 100%; height: auto; clear: both; text-align: center;">
</div>
<p>因而，你可以開啟〈<a href="WebAssembly.html">哈囉！WebAssembly！</a>〉中談到的 wasm_exec.html，在 <code>&lt;button onClick="run();" id="runButton" disabled&gt;Run&lt;/button&gt;</code> 標籤底下加上 <code>&lt;div id="c1"&gt;Hello, WebAssembly!&lt;/div&gt;</code>：</p>
<pre><code class="language-prettyprint">&lt;!doctype html&gt;
&lt;!--
Copyright 2018 The Go Authors. All rights reserved.
Use of this source code is governed by a BSD-style
license that can be found in the LICENSE file.
--&gt;
&lt;html&gt;

&lt;head&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;title&gt;Go wasm&lt;/title&gt;
&lt;/head&gt;

&lt;body&gt;
    &lt;script src="wasm_exec.js"&gt;&lt;/script&gt;
    &lt;script&gt;
        WebAssembly API 等... 略
    &lt;/script&gt;

    &lt;button onClick="run();" id="runButton" disabled&gt;Run&lt;/button&gt;
    &lt;div id="c1"&gt;Hello, WebAssembly!&lt;/div&gt;
&lt;/body&gt;

&lt;/html&gt;
</code></pre>
<p>若想撰寫 Go 來取得對應的 DOM 物件，並在主控台顯示 <code>innerHTML</code> 特性值，可以如下撰寫：</p>
<pre><code class="language-prettyprint">package main

import "syscall/js"

func main() {
    window := js.Global()                       // 取得全域的 window
    doc := window.Get("document")               // 相當於 window.document
    c1 := doc.Call("getElementById", "c1")      // 相當於 document.getElementById('c1')
    innerHTML := c1.Get("innerHTML").String()   // 相當於 c1.innerHTML
    println(innerHTML)
}
</code></pre>
<p>這邊特意使用數個變數，代逐一對照取得的各是哪個 JavaScript 值，實際上當然可以直接寫成底下：</p>
<pre><code class="language-prettyprint">package main

import "syscall/js"

func main() {
    innerHTML :=
        js.Global().
            Get("document").
            Call("getElementById", "c1").
            Get("innerHTML").
            String()
    println(innerHTML)
}
</code></pre>
<p>也就是相當於在 JavaScript 中撰寫 <code>document.getElementById("c1").innerHTML</code>；在編譯為 WebAssembly、使用瀏覽器連線至網頁之後，按下 Run 按鈕，就可以取得目標 <code>c1</code> 的 <code>innerHTML</code>：</p>
<div class="pure-g">
<div class="pure-u-1">
<img src="images/JavaScript-1.JPG" class="pure-img-responsive" alt="Go 呼叫 JavaScript" />
</div>
</div>
<p>類似地，如果想在 Go 中呼叫瀏覽器提供的 <code>alert</code> 全域函式，可以如下撰寫：</p>
<pre><code class="language-prettyprint">package main

import "syscall/js"

func main() {
    alert := js.Global().Get("alert")
    // 相當於 alert('Hello, WebAssembly!')
    alert.Invoke("Hello, WebAssembly!")
}
</code></pre>
<p>在編譯為 WebAssembly、使用瀏覽器連線至網頁之後，按下 Run 按鈕，會令瀏覽器出現警示對話方塊：</p>
<div class="pure-g">
<div class="pure-u-1">
<img src="images/JavaScript-2.JPG" class="pure-img-responsive" alt="Go 呼叫 JavaScript" />
</div>
</div>
<p>因此，如果有個自定義的 JavaScript 函式，而你想在 Go 中呼叫它，就是看看，那個函式是在哪個物件之上，想辦法取得該物件，之後就可以加以呼叫了，例如：</p>
<pre><code class="language-prettyprint">&lt;!doctype html&gt;
&lt;!--
Copyright 2018 The Go Authors. All rights reserved.
Use of this source code is governed by a BSD-style
license that can be found in the LICENSE file.
--&gt;
&lt;html&gt;

&lt;head&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;title&gt;Go wasm&lt;/title&gt;
&lt;/head&gt;

&lt;body&gt;
    &lt;script src="wasm_exec.js"&gt;&lt;/script&gt;
    &lt;script&gt;
        WebAssembly API 等... 略
    &lt;/script&gt;
    &lt;script&gt;
        function hi_wasm(name) {
            document.getElementById('c1').innerHTML = 'Hi, ' + name;
        }
    &lt;/script&gt;

    &lt;button onClick="run();" id="runButton" disabled&gt;Run&lt;/button&gt;
    &lt;div id="c1"&gt;Hello, WebAssembly!&lt;/div&gt;
&lt;/body&gt;

&lt;/html&gt;
</code></pre>
<p>在上例中，<code>hi_wasm</code> 函式實際上是 <code>window</code> 的一個特性，因此在 Go 中可以這麼呼叫：</p>
<pre><code class="language-prettyprint">package main

import "syscall/js"

func main() {
    hi_wasm := js.Global().Get("hi_wasm")
    hi_wasm.Invoke("WebAssembly")
}
</code></pre>
<p>在編譯為 WebAssembly、使用瀏覽器連線至網頁之後，按下 Run 按鈕，就會將 <code>c1</code> 的文字改變為 Hi, WebAssembly。</p>
<p>如果自訂的 JavaScript 函式有傳回值的話，那會成為 <code>Invoke</code> 方法的傳回值，然而記得，JavaScript 的值在 Go 中是對應至 <code>js.Value</code>，<code>Invoke</code> 的傳回型態正是 <code>js.Value</code>，取得之後，就看它代表著什麼 JavaScript 值（數值、字串、陣列、函式？），再進一步操作。</p>
<div class="ad336-280" style="text-align: center;">
</div>
<div class="recommend" style="text-align: center;">
<hr />
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><div id="main" role="main" style="height: auto !important;">
<div class="header">
<h1 id="javascript-回呼-go"><a class="header" href="#javascript-回呼-go">JavaScript 回呼 Go</a></h1>
</div>
<p>在〈<a href="JavaScript.html">Go 呼叫 JavaScript</a>〉看過如何在 Go 中取得 JavaScript 的函式，然後予以呼叫，若你曾稍微瞭解過〈<a href="https://openhome.cc/Gossip/WebAssembly/">WebAssembly</a>〉，就會發覺，這跟 WebAssembly 匯入函式至 WebAssembly 的方式不同。</p>
<p>這是 JavaScript 的 wasm_exec.js 以及 Go 的 <code>syscall/js</code> 居中之緣故，在 wasm_exec.html 中你也可以看到載入、編譯、實例化 WebAssembly 的過程：</p>
<pre><code class="language-prettyprint">if (!WebAssembly.instantiateStreaming) { // polyfill
    WebAssembly.instantiateStreaming = async (resp, importObject) =&gt; {
        const source = await (await resp).arrayBuffer();
        return await WebAssembly.instantiate(source, importObject);
    };
}

const go = new Go();
let mod, inst;
WebAssembly.instantiateStreaming(fetch("test.wasm"), go.importObject).then((result) =&gt; {
    mod = result.module;
    inst = result.instance;
    document.getElementById("runButton").disabled = false;
});

async function run() {
    console.clear();
    await go.run(inst);
    inst = await WebAssembly.instantiate(mod, go.importObject); // reset instance
}
</code></pre>
<div class="google-auto-placed" style="width: 100%; height: auto; clear: both; text-align: center;">
</div>
<p>Go 有自己的匯入物件，也就是 <code>go.importObject</code>，這個物件主要是 JavaScript 環境與 Go 編譯出來的 WebAssembly 之橋樑，將 JavaScript 的值與 Go 的結構實例作了個對應，因此，不用自己匯入某個函式，只要取得某個作為名稱空間的 JavaScript 物件，取得上頭對應的特性，像是函式，就可以在 Go 中操作。</p>
<p>也就是說，如果想要在 Go 中定義函式，然後在 JavaScript 中呼叫，就是將 Go 中定義的函式，設定給某個對應的 JavaScript 物件，之後就可以在 JavaScript 環境中使用了，只不過在定義時，必須留意 JavaScript 與 Go 的型態對應。</p>
<p>可以被 JavaScript 環境呼叫的 Go 函式，必須被包裝為 <code>js.Callback</code> 型態，這個結構型態內嵌 <code>js.Value</code>，也就是它也是一種值，想要建立 <code>js.Callback</code> 實例，可以透過 <code>js.NewCallback</code> 函式（定義在 callback.go）。</p>
<p>要能被 JavaScript 呼叫的 Go 函式，參數型態是 <code>[]js.Value</code>，也就是 <code>js.Value</code> 的 <code>slice</code>，<code>slice</code> 的元素代表著呼叫函式時傳入的引數，你可以想像 JavaScript 函式中 <code>arguments</code> 的對應型態。</p>
<div class="google-auto-placed" style="width: 100%; height: auto; clear: both; text-align: center;">
</div>
<p>例如，顯示加總至某個指定 DOM 物件的函式，可以如下定義：</p>
<pre><code class="language-prettyprint">package main

import "syscall/js"

func main() {
    // 註冊在 JavaScript 全域
    js.Global().Set("printSumTo", js.NewCallback(printSum))
    // 阻斷 main 流程
    select {}   
}

func printSum(args []js.Value) {
    c1 := args[0]         // 結果顯示到這個 div 
    numbers := args[1:]   // 接下來是要加總的數字
    c1.Set("innerHTML", sum(numbers))
}

func sum(numbers []js.Value) int {
    var sum int
    for _, val := range numbers {
        sum += val.Int()
    }
    return sum
}
</code></pre>
<div class="google-auto-placed" style="width: 100%; height: auto; clear: both; text-align: center;">
</div>
<p>目前 Go 給 JavaScript 回呼用的函式不支援傳回值，未來也許會進一步支援，如果你想將結果帶回 JavaScript 環境，就是以副作用的方式實現，例如改變某個 JavaScript 物件的狀態，像是這邊是改變某個 DOM 的 <code>innerHTML</code>。</p>
<p>因為 Go 的 <code>main</code> 執行完，模組的程式就結束了，這樣 Go 中定義的函式就沒有了，然而，事件會是在之後才發生，因而要被回呼的函式必須存活著，為了這個目的，範例中使用 <code>select {}</code> 來阻斷流程，視需求而定，你也可以用別的方式來設計某種阻斷。</p>
<p>至於 JavaScript 的部份，來稍微修改一下 wasm_exec.html：</p>
<pre><code class="language-prettyprint">&lt;!doctype html&gt;
&lt;!--
Copyright 2018 The Go Authors. All rights reserved.
Use of this source code is governed by a BSD-style
license that can be found in the LICENSE file.
--&gt;
&lt;html&gt;

&lt;head&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;title&gt;Go wasm&lt;/title&gt;
&lt;/head&gt;

&lt;body&gt;

    &lt;script src="wasm_exec.js"&gt;&lt;/script&gt;
    &lt;script&gt;
        if (!WebAssembly.instantiateStreaming) { // polyfill
            WebAssembly.instantiateStreaming = async (resp, importObject) =&gt; {
                const source = await (await resp).arrayBuffer();
                return await WebAssembly.instantiate(source, importObject);
            };
        }

        const go = new Go();
        let mod, inst;
        WebAssembly.instantiateStreaming(fetch("test.wasm"), go.importObject).then((result) =&gt; {
            mod = result.module;
            inst = result.instance;
            document.getElementById("runButton").disabled = false;
        }).then(_ =&gt; {   // 實例化模組之後就執行
            console.clear();
            go.run(inst);       
        });
    &lt;/script&gt;   

    &lt;script&gt;
        function run() {
            // 呼叫 Go 定義的回呼函式
            printSumTo(document.getElementById('c1'), 
                1, 2, 3, 4, 5);
        }
    &lt;/script&gt;

    &lt;button onClick="run();" id="runButton" disabled&gt;Run&lt;/button&gt;
    &lt;div id="c1"&gt;&lt;/div&gt;

&lt;/body&gt;
&lt;/body&gt;

&lt;/html&gt;
</code></pre>
<p>按下 Run 之後，會呼叫 <code>runAndPrintSum</code>，這會先執行 <code>run</code> 函式，執行 WebAssembly 模組實例，對應的就是執行 Go 定義的 <code>main</code>，因為 <code>run</code> 是非同步的，接下來就會執行 <code>printSumTo</code>，因此 1 到 5 的加總結果，就會顯示到 <code>id</code> 為 <code>c1</code> 的 <code>div</code> 元素之中。</p>
<p>至於 WebAssembly API 的調整，想要瞭解這部份的話，可以看看〈<a href="https://openhome.cc/Gossip/WebAssembly/">WebAssembly</a>〉中前三篇的說明。</p>
<p>故且不討論 WebAssembly API 怎麼寫，在自定義的 JavaScript 程式碼中，想要呼叫 Go 中定義的函式，其實感覺就是多了些額外的手續，而且不自然。</p>
<p>如果把一切都帶到 Go 中做，將 Go 中定義的函式，當成是某事件的回呼，會比較單純一些，例如：</p>
<pre><code class="language-prettyprint">package main

import (
    "strconv"
    "syscall/js"
)

func main() {
    // 註冊按鈕事件
    dom("runButton").Call("addEventListener", "click", js.NewCallback(cal))
    select {}
}

// 根據 id 取得 DOM 物件
func dom(id string) js.Value {
    return js.Global().Get("document").Call("getElementById", id)
}

// 按下 Run 的事件處理器
func cal(args []js.Value) {
    n1, _ := inputValue("n1")
    n2, _ := inputValue("n2")
    dom("r").Set("innerHTML", n1+n2)
}

// 取得輸入欄位值
func inputValue(id string) (int, error) {
    return strconv.Atoi(dom(id).Get("value").String())
}
</code></pre>
<p>至於 wasm_exec.html 可以如下調整：</p>
<pre><code class="language-prettyprint">&lt;!doctype html&gt;
&lt;!--
Copyright 2018 The Go Authors. All rights reserved.
Use of this source code is governed by a BSD-style
license that can be found in the LICENSE file.
--&gt;
&lt;html&gt;

&lt;head&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;title&gt;Go wasm&lt;/title&gt;
&lt;/head&gt;

&lt;body&gt;
    &lt;input id="n1"&gt; + &lt;input id="n2"&gt; = &lt;span id="r"&gt;&lt;/span&gt;&lt;br&gt;
    &lt;button id="runButton" disabled&gt;Run&lt;/button&gt;


    &lt;script src="wasm_exec.js"&gt;&lt;/script&gt;
    &lt;script&gt;
        if (!WebAssembly.instantiateStreaming) { // polyfill
            WebAssembly.instantiateStreaming = async (resp, importObject) =&gt; {
                const source = await (await resp).arrayBuffer();
                return await WebAssembly.instantiate(source, importObject);
            };
        }

        const go = new Go();
        let mod, inst;
        WebAssembly.instantiateStreaming(fetch("test.wasm"), go.importObject).then((result) =&gt; {
            mod = result.module;
            inst = result.instance;
            document.getElementById("runButton").disabled = false;
        }).then(_ =&gt; {
            console.clear();
            go.run(inst);       
        });
    &lt;/script&gt;   
&lt;/body&gt;

&lt;/html&gt;
</code></pre>
<p>這樣就可以進行頁面操作，就是個簡單的加法器：</p>
<div class="pure-g">
<div class="pure-u-1">
<img src="images/Callback-1.JPG" class="pure-img-responsive" alt="JavaScript 回呼 Go" />
</div>
</div>
<p>（這也許才是 Go 希望的，要你把東西都帶入 Go 中來做，JavaScript 環境的事件會呼叫 Go 的函式，然後在 Go 中計算，在 Go 中改變物件狀態、畫面等。）</p>
<div class="ad336-280" style="text-align: center;">
</div>
<div class="recommend" style="text-align: center;">
<hr />
</div>
</div>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
